Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> start
Rule 1     start -> language
Rule 2     start -> empty
Rule 3     language -> language NEWLINE line
Rule 4     language -> line
Rule 5     line -> expression
Rule 6     line -> var_assign
Rule 7     line -> func_assign
Rule 8     line -> iterative
Rule 9     line -> conditional
Rule 10    line -> output
Rule 11    line -> input
Rule 12    line -> empty
Rule 13    func_assign -> datatype NAME LPAREN parameters RPAREN START NEWLINE language return_stmt STOP
Rule 14    return_stmt -> RETURN expression NEWLINE
Rule 15    return_stmt -> RETURN NEWLINE
Rule 16    return_stmt -> empty
Rule 17    parameters -> first_param
Rule 18    parameters -> empty
Rule 19    first_param -> datatype NAME COMMA first_param
Rule 20    first_param -> datatype NAME
Rule 21    datatype -> INT_TYPE
Rule 22    datatype -> FLOAT_TYPE
Rule 23    datatype -> STRING_TYPE
Rule 24    datatype -> VOID_TYPE
Rule 25    input -> READ LPAREN NAME RPAREN
Rule 26    output -> output_print
Rule 27    output_print -> PRINT LPAREN expression RPAREN
Rule 28    expression -> NAME
Rule 29    var_assign -> NAME EQUALS expression
Rule 30    expression -> expression_operation
Rule 31    expression_operation -> expression MULTIPLY expression
Rule 32    expression_operation -> expression DIVIDE expression
Rule 33    expression_operation -> expression MODULO expression
Rule 34    expression_operation -> expression PLUS expression
Rule 35    expression_operation -> expression MINUS expression
Rule 36    expression_operation -> expression LD expression
Rule 37    expression_operation -> expression LDEQ expression
Rule 38    expression_operation -> expression GD expression
Rule 39    expression_operation -> expression GDEQ expression
Rule 40    expression_operation -> expression EQUALEQUAL expression
Rule 41    expression_operation -> expression NOTEQ expression
Rule 42    expression_operation -> expression AND expression
Rule 43    expression_operation -> expression OR expression
Rule 44    expression_operation -> NOT expression
Rule 45    expression -> INT
Rule 46    expression -> FLOAT
Rule 47    expression -> STRING
Rule 48    expression -> TRUE
Rule 49    expression -> FALSE
Rule 50    expression -> LBRACE int_type_array RBRACE
Rule 51    expression -> LBRACE float_type_array RBRACE
Rule 52    expression -> LBRACE string_type_array RBRACE
Rule 53    expression -> LBRACE bool_type_array RBRACE
Rule 54    int_type_array -> empty
Rule 55    int_type_array -> INT int_type_array
Rule 56    float_type_array -> empty
Rule 57    float_type_array -> FLOAT float_type_array
Rule 58    string_type_array -> empty
Rule 59    string_type_array -> STRING string_type_array
Rule 60    bool_type_array -> empty
Rule 61    bool_type_array -> TRUE bool_type_array
Rule 62    bool_type_array -> FALSE bool_type_array
Rule 63    expression -> LPAREN expression RPAREN
Rule 64    conditional -> IF expression START NEWLINE language STOP else_if_blocks else_block
Rule 65    else_if_blocks -> empty
Rule 66    else_if_blocks -> else_if_blocks else_if_block
Rule 67    else_if_block -> ELSE_IF expression START NEWLINE language STOP
Rule 68    else_block -> ELSE START NEWLINE language STOP
Rule 69    else_block -> empty
Rule 70    iterative -> WHILE expression START NEWLINE language STOP
Rule 71    empty -> <empty>

Terminals, with rules where they appear

AND                  : 42
COMMA                : 19
DIVIDE               : 32
ELSE                 : 68
ELSE_IF              : 67
EQUALEQUAL           : 40
EQUALS               : 29
FALSE                : 49 62
FLOAT                : 46 57
FLOAT_TYPE           : 22
GD                   : 38
GDEQ                 : 39
IF                   : 64
INT                  : 45 55
INT_TYPE             : 21
LBRACE               : 50 51 52 53
LD                   : 36
LDEQ                 : 37
LPAREN               : 13 25 27 63
MINUS                : 35
MODULO               : 33
MULTIPLY             : 31
NAME                 : 13 19 20 25 28 29
NEWLINE              : 3 13 14 15 64 67 68 70
NOT                  : 44
NOTEQ                : 41
OR                   : 43
PLUS                 : 34
PRINT                : 27
RBRACE               : 50 51 52 53
READ                 : 25
RETURN               : 14 15
RPAREN               : 13 25 27 63
START                : 13 64 67 68 70
STOP                 : 13 64 67 68 70
STRING               : 47 59
STRING_TYPE          : 23
TRUE                 : 48 61
VOID_TYPE            : 24
WHILE                : 70
error                : 

Nonterminals, with rules where they appear

bool_type_array      : 53 61 62
conditional          : 9
datatype             : 13 19 20
else_block           : 64
else_if_block        : 66
else_if_blocks       : 64 66
empty                : 2 12 16 18 54 56 58 60 65 69
expression           : 5 14 27 29 31 31 32 32 33 33 34 34 35 35 36 36 37 37 38 38 39 39 40 40 41 41 42 42 43 43 44 63 64 67 70
expression_operation : 30
first_param          : 17 19
float_type_array     : 51 57
func_assign          : 7
input                : 11
int_type_array       : 50 55
iterative            : 8
language             : 1 3 13 64 67 68 70
line                 : 3 4
output               : 10
output_print         : 26
parameters           : 13
return_stmt          : 13
start                : 0
string_type_array    : 52 59
var_assign           : 6

Parsing method: LALR

state 0

    (0) S' -> . start
    (1) start -> . language
    (2) start -> . empty
    (3) language -> . language NEWLINE line
    (4) language -> . line
    (71) empty -> .
    (5) line -> . expression
    (6) line -> . var_assign
    (7) line -> . func_assign
    (8) line -> . iterative
    (9) line -> . conditional
    (10) line -> . output
    (11) line -> . input
    (12) line -> . empty
    (28) expression -> . NAME
    (30) expression -> . expression_operation
    (45) expression -> . INT
    (46) expression -> . FLOAT
    (47) expression -> . STRING
    (48) expression -> . TRUE
    (49) expression -> . FALSE
    (50) expression -> . LBRACE int_type_array RBRACE
    (51) expression -> . LBRACE float_type_array RBRACE
    (52) expression -> . LBRACE string_type_array RBRACE
    (53) expression -> . LBRACE bool_type_array RBRACE
    (63) expression -> . LPAREN expression RPAREN
    (29) var_assign -> . NAME EQUALS expression
    (13) func_assign -> . datatype NAME LPAREN parameters RPAREN START NEWLINE language return_stmt STOP
    (70) iterative -> . WHILE expression START NEWLINE language STOP
    (64) conditional -> . IF expression START NEWLINE language STOP else_if_blocks else_block
    (26) output -> . output_print
    (25) input -> . READ LPAREN NAME RPAREN
    (31) expression_operation -> . expression MULTIPLY expression
    (32) expression_operation -> . expression DIVIDE expression
    (33) expression_operation -> . expression MODULO expression
    (34) expression_operation -> . expression PLUS expression
    (35) expression_operation -> . expression MINUS expression
    (36) expression_operation -> . expression LD expression
    (37) expression_operation -> . expression LDEQ expression
    (38) expression_operation -> . expression GD expression
    (39) expression_operation -> . expression GDEQ expression
    (40) expression_operation -> . expression EQUALEQUAL expression
    (41) expression_operation -> . expression NOTEQ expression
    (42) expression_operation -> . expression AND expression
    (43) expression_operation -> . expression OR expression
    (44) expression_operation -> . NOT expression
    (21) datatype -> . INT_TYPE
    (22) datatype -> . FLOAT_TYPE
    (23) datatype -> . STRING_TYPE
    (24) datatype -> . VOID_TYPE
    (27) output_print -> . PRINT LPAREN expression RPAREN

    $end            reduce using rule 71 (empty -> .)
    NEWLINE         reduce using rule 71 (empty -> .)
    NAME            shift and go to state 12
    INT             shift and go to state 14
    FLOAT           shift and go to state 15
    STRING          shift and go to state 16
    TRUE            shift and go to state 17
    FALSE           shift and go to state 18
    LBRACE          shift and go to state 19
    LPAREN          shift and go to state 20
    WHILE           shift and go to state 22
    IF              shift and go to state 23
    READ            shift and go to state 25
    NOT             shift and go to state 26
    INT_TYPE        shift and go to state 27
    FLOAT_TYPE      shift and go to state 28
    STRING_TYPE     shift and go to state 29
    VOID_TYPE       shift and go to state 30
    PRINT           shift and go to state 31

    start                          shift and go to state 1
    language                       shift and go to state 2
    empty                          shift and go to state 3
    line                           shift and go to state 4
    expression                     shift and go to state 5
    var_assign                     shift and go to state 6
    func_assign                    shift and go to state 7
    iterative                      shift and go to state 8
    conditional                    shift and go to state 9
    output                         shift and go to state 10
    input                          shift and go to state 11
    expression_operation           shift and go to state 13
    datatype                       shift and go to state 21
    output_print                   shift and go to state 24

state 1

    (0) S' -> start .



state 2

    (1) start -> language .
    (3) language -> language . NEWLINE line

    $end            reduce using rule 1 (start -> language .)
    NEWLINE         shift and go to state 32


state 3

    (2) start -> empty .
    (12) line -> empty .

  ! reduce/reduce conflict for $end resolved using rule 2 (start -> empty .)
    $end            reduce using rule 2 (start -> empty .)
    NEWLINE         reduce using rule 12 (line -> empty .)

  ! $end            [ reduce using rule 12 (line -> empty .) ]


state 4

    (4) language -> line .

    NEWLINE         reduce using rule 4 (language -> line .)
    $end            reduce using rule 4 (language -> line .)
    STOP            reduce using rule 4 (language -> line .)
    RETURN          reduce using rule 4 (language -> line .)


state 5

    (5) line -> expression .
    (31) expression_operation -> expression . MULTIPLY expression
    (32) expression_operation -> expression . DIVIDE expression
    (33) expression_operation -> expression . MODULO expression
    (34) expression_operation -> expression . PLUS expression
    (35) expression_operation -> expression . MINUS expression
    (36) expression_operation -> expression . LD expression
    (37) expression_operation -> expression . LDEQ expression
    (38) expression_operation -> expression . GD expression
    (39) expression_operation -> expression . GDEQ expression
    (40) expression_operation -> expression . EQUALEQUAL expression
    (41) expression_operation -> expression . NOTEQ expression
    (42) expression_operation -> expression . AND expression
    (43) expression_operation -> expression . OR expression

    NEWLINE         reduce using rule 5 (line -> expression .)
    $end            reduce using rule 5 (line -> expression .)
    STOP            reduce using rule 5 (line -> expression .)
    RETURN          reduce using rule 5 (line -> expression .)
    MULTIPLY        shift and go to state 33
    DIVIDE          shift and go to state 34
    MODULO          shift and go to state 35
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    LD              shift and go to state 38
    LDEQ            shift and go to state 39
    GD              shift and go to state 40
    GDEQ            shift and go to state 41
    EQUALEQUAL      shift and go to state 42
    NOTEQ           shift and go to state 43
    AND             shift and go to state 44
    OR              shift and go to state 45


state 6

    (6) line -> var_assign .

    NEWLINE         reduce using rule 6 (line -> var_assign .)
    $end            reduce using rule 6 (line -> var_assign .)
    STOP            reduce using rule 6 (line -> var_assign .)
    RETURN          reduce using rule 6 (line -> var_assign .)


state 7

    (7) line -> func_assign .

    NEWLINE         reduce using rule 7 (line -> func_assign .)
    $end            reduce using rule 7 (line -> func_assign .)
    STOP            reduce using rule 7 (line -> func_assign .)
    RETURN          reduce using rule 7 (line -> func_assign .)


state 8

    (8) line -> iterative .

    NEWLINE         reduce using rule 8 (line -> iterative .)
    $end            reduce using rule 8 (line -> iterative .)
    STOP            reduce using rule 8 (line -> iterative .)
    RETURN          reduce using rule 8 (line -> iterative .)


state 9

    (9) line -> conditional .

    NEWLINE         reduce using rule 9 (line -> conditional .)
    $end            reduce using rule 9 (line -> conditional .)
    STOP            reduce using rule 9 (line -> conditional .)
    RETURN          reduce using rule 9 (line -> conditional .)


state 10

    (10) line -> output .

    NEWLINE         reduce using rule 10 (line -> output .)
    $end            reduce using rule 10 (line -> output .)
    STOP            reduce using rule 10 (line -> output .)
    RETURN          reduce using rule 10 (line -> output .)


state 11

    (11) line -> input .

    NEWLINE         reduce using rule 11 (line -> input .)
    $end            reduce using rule 11 (line -> input .)
    STOP            reduce using rule 11 (line -> input .)
    RETURN          reduce using rule 11 (line -> input .)


state 12

    (28) expression -> NAME .
    (29) var_assign -> NAME . EQUALS expression

    MULTIPLY        reduce using rule 28 (expression -> NAME .)
    DIVIDE          reduce using rule 28 (expression -> NAME .)
    MODULO          reduce using rule 28 (expression -> NAME .)
    PLUS            reduce using rule 28 (expression -> NAME .)
    MINUS           reduce using rule 28 (expression -> NAME .)
    LD              reduce using rule 28 (expression -> NAME .)
    LDEQ            reduce using rule 28 (expression -> NAME .)
    GD              reduce using rule 28 (expression -> NAME .)
    GDEQ            reduce using rule 28 (expression -> NAME .)
    EQUALEQUAL      reduce using rule 28 (expression -> NAME .)
    NOTEQ           reduce using rule 28 (expression -> NAME .)
    AND             reduce using rule 28 (expression -> NAME .)
    OR              reduce using rule 28 (expression -> NAME .)
    NEWLINE         reduce using rule 28 (expression -> NAME .)
    $end            reduce using rule 28 (expression -> NAME .)
    STOP            reduce using rule 28 (expression -> NAME .)
    RETURN          reduce using rule 28 (expression -> NAME .)
    EQUALS          shift and go to state 46


state 13

    (30) expression -> expression_operation .

    MULTIPLY        reduce using rule 30 (expression -> expression_operation .)
    DIVIDE          reduce using rule 30 (expression -> expression_operation .)
    MODULO          reduce using rule 30 (expression -> expression_operation .)
    PLUS            reduce using rule 30 (expression -> expression_operation .)
    MINUS           reduce using rule 30 (expression -> expression_operation .)
    LD              reduce using rule 30 (expression -> expression_operation .)
    LDEQ            reduce using rule 30 (expression -> expression_operation .)
    GD              reduce using rule 30 (expression -> expression_operation .)
    GDEQ            reduce using rule 30 (expression -> expression_operation .)
    EQUALEQUAL      reduce using rule 30 (expression -> expression_operation .)
    NOTEQ           reduce using rule 30 (expression -> expression_operation .)
    AND             reduce using rule 30 (expression -> expression_operation .)
    OR              reduce using rule 30 (expression -> expression_operation .)
    NEWLINE         reduce using rule 30 (expression -> expression_operation .)
    $end            reduce using rule 30 (expression -> expression_operation .)
    RPAREN          reduce using rule 30 (expression -> expression_operation .)
    START           reduce using rule 30 (expression -> expression_operation .)
    STOP            reduce using rule 30 (expression -> expression_operation .)
    RETURN          reduce using rule 30 (expression -> expression_operation .)


state 14

    (45) expression -> INT .

    MULTIPLY        reduce using rule 45 (expression -> INT .)
    DIVIDE          reduce using rule 45 (expression -> INT .)
    MODULO          reduce using rule 45 (expression -> INT .)
    PLUS            reduce using rule 45 (expression -> INT .)
    MINUS           reduce using rule 45 (expression -> INT .)
    LD              reduce using rule 45 (expression -> INT .)
    LDEQ            reduce using rule 45 (expression -> INT .)
    GD              reduce using rule 45 (expression -> INT .)
    GDEQ            reduce using rule 45 (expression -> INT .)
    EQUALEQUAL      reduce using rule 45 (expression -> INT .)
    NOTEQ           reduce using rule 45 (expression -> INT .)
    AND             reduce using rule 45 (expression -> INT .)
    OR              reduce using rule 45 (expression -> INT .)
    NEWLINE         reduce using rule 45 (expression -> INT .)
    $end            reduce using rule 45 (expression -> INT .)
    RPAREN          reduce using rule 45 (expression -> INT .)
    START           reduce using rule 45 (expression -> INT .)
    STOP            reduce using rule 45 (expression -> INT .)
    RETURN          reduce using rule 45 (expression -> INT .)


state 15

    (46) expression -> FLOAT .

    MULTIPLY        reduce using rule 46 (expression -> FLOAT .)
    DIVIDE          reduce using rule 46 (expression -> FLOAT .)
    MODULO          reduce using rule 46 (expression -> FLOAT .)
    PLUS            reduce using rule 46 (expression -> FLOAT .)
    MINUS           reduce using rule 46 (expression -> FLOAT .)
    LD              reduce using rule 46 (expression -> FLOAT .)
    LDEQ            reduce using rule 46 (expression -> FLOAT .)
    GD              reduce using rule 46 (expression -> FLOAT .)
    GDEQ            reduce using rule 46 (expression -> FLOAT .)
    EQUALEQUAL      reduce using rule 46 (expression -> FLOAT .)
    NOTEQ           reduce using rule 46 (expression -> FLOAT .)
    AND             reduce using rule 46 (expression -> FLOAT .)
    OR              reduce using rule 46 (expression -> FLOAT .)
    NEWLINE         reduce using rule 46 (expression -> FLOAT .)
    $end            reduce using rule 46 (expression -> FLOAT .)
    RPAREN          reduce using rule 46 (expression -> FLOAT .)
    START           reduce using rule 46 (expression -> FLOAT .)
    STOP            reduce using rule 46 (expression -> FLOAT .)
    RETURN          reduce using rule 46 (expression -> FLOAT .)


state 16

    (47) expression -> STRING .

    MULTIPLY        reduce using rule 47 (expression -> STRING .)
    DIVIDE          reduce using rule 47 (expression -> STRING .)
    MODULO          reduce using rule 47 (expression -> STRING .)
    PLUS            reduce using rule 47 (expression -> STRING .)
    MINUS           reduce using rule 47 (expression -> STRING .)
    LD              reduce using rule 47 (expression -> STRING .)
    LDEQ            reduce using rule 47 (expression -> STRING .)
    GD              reduce using rule 47 (expression -> STRING .)
    GDEQ            reduce using rule 47 (expression -> STRING .)
    EQUALEQUAL      reduce using rule 47 (expression -> STRING .)
    NOTEQ           reduce using rule 47 (expression -> STRING .)
    AND             reduce using rule 47 (expression -> STRING .)
    OR              reduce using rule 47 (expression -> STRING .)
    NEWLINE         reduce using rule 47 (expression -> STRING .)
    $end            reduce using rule 47 (expression -> STRING .)
    RPAREN          reduce using rule 47 (expression -> STRING .)
    START           reduce using rule 47 (expression -> STRING .)
    STOP            reduce using rule 47 (expression -> STRING .)
    RETURN          reduce using rule 47 (expression -> STRING .)


state 17

    (48) expression -> TRUE .

    MULTIPLY        reduce using rule 48 (expression -> TRUE .)
    DIVIDE          reduce using rule 48 (expression -> TRUE .)
    MODULO          reduce using rule 48 (expression -> TRUE .)
    PLUS            reduce using rule 48 (expression -> TRUE .)
    MINUS           reduce using rule 48 (expression -> TRUE .)
    LD              reduce using rule 48 (expression -> TRUE .)
    LDEQ            reduce using rule 48 (expression -> TRUE .)
    GD              reduce using rule 48 (expression -> TRUE .)
    GDEQ            reduce using rule 48 (expression -> TRUE .)
    EQUALEQUAL      reduce using rule 48 (expression -> TRUE .)
    NOTEQ           reduce using rule 48 (expression -> TRUE .)
    AND             reduce using rule 48 (expression -> TRUE .)
    OR              reduce using rule 48 (expression -> TRUE .)
    NEWLINE         reduce using rule 48 (expression -> TRUE .)
    $end            reduce using rule 48 (expression -> TRUE .)
    RPAREN          reduce using rule 48 (expression -> TRUE .)
    START           reduce using rule 48 (expression -> TRUE .)
    STOP            reduce using rule 48 (expression -> TRUE .)
    RETURN          reduce using rule 48 (expression -> TRUE .)


state 18

    (49) expression -> FALSE .

    MULTIPLY        reduce using rule 49 (expression -> FALSE .)
    DIVIDE          reduce using rule 49 (expression -> FALSE .)
    MODULO          reduce using rule 49 (expression -> FALSE .)
    PLUS            reduce using rule 49 (expression -> FALSE .)
    MINUS           reduce using rule 49 (expression -> FALSE .)
    LD              reduce using rule 49 (expression -> FALSE .)
    LDEQ            reduce using rule 49 (expression -> FALSE .)
    GD              reduce using rule 49 (expression -> FALSE .)
    GDEQ            reduce using rule 49 (expression -> FALSE .)
    EQUALEQUAL      reduce using rule 49 (expression -> FALSE .)
    NOTEQ           reduce using rule 49 (expression -> FALSE .)
    AND             reduce using rule 49 (expression -> FALSE .)
    OR              reduce using rule 49 (expression -> FALSE .)
    NEWLINE         reduce using rule 49 (expression -> FALSE .)
    $end            reduce using rule 49 (expression -> FALSE .)
    RPAREN          reduce using rule 49 (expression -> FALSE .)
    START           reduce using rule 49 (expression -> FALSE .)
    STOP            reduce using rule 49 (expression -> FALSE .)
    RETURN          reduce using rule 49 (expression -> FALSE .)


state 19

    (50) expression -> LBRACE . int_type_array RBRACE
    (51) expression -> LBRACE . float_type_array RBRACE
    (52) expression -> LBRACE . string_type_array RBRACE
    (53) expression -> LBRACE . bool_type_array RBRACE
    (54) int_type_array -> . empty
    (55) int_type_array -> . INT int_type_array
    (56) float_type_array -> . empty
    (57) float_type_array -> . FLOAT float_type_array
    (58) string_type_array -> . empty
    (59) string_type_array -> . STRING string_type_array
    (60) bool_type_array -> . empty
    (61) bool_type_array -> . TRUE bool_type_array
    (62) bool_type_array -> . FALSE bool_type_array
    (71) empty -> .

    INT             shift and go to state 52
    FLOAT           shift and go to state 53
    STRING          shift and go to state 54
    TRUE            shift and go to state 55
    FALSE           shift and go to state 56
    RBRACE          reduce using rule 71 (empty -> .)

    int_type_array                 shift and go to state 47
    float_type_array               shift and go to state 48
    string_type_array              shift and go to state 49
    bool_type_array                shift and go to state 50
    empty                          shift and go to state 51

state 20

    (63) expression -> LPAREN . expression RPAREN
    (28) expression -> . NAME
    (30) expression -> . expression_operation
    (45) expression -> . INT
    (46) expression -> . FLOAT
    (47) expression -> . STRING
    (48) expression -> . TRUE
    (49) expression -> . FALSE
    (50) expression -> . LBRACE int_type_array RBRACE
    (51) expression -> . LBRACE float_type_array RBRACE
    (52) expression -> . LBRACE string_type_array RBRACE
    (53) expression -> . LBRACE bool_type_array RBRACE
    (63) expression -> . LPAREN expression RPAREN
    (31) expression_operation -> . expression MULTIPLY expression
    (32) expression_operation -> . expression DIVIDE expression
    (33) expression_operation -> . expression MODULO expression
    (34) expression_operation -> . expression PLUS expression
    (35) expression_operation -> . expression MINUS expression
    (36) expression_operation -> . expression LD expression
    (37) expression_operation -> . expression LDEQ expression
    (38) expression_operation -> . expression GD expression
    (39) expression_operation -> . expression GDEQ expression
    (40) expression_operation -> . expression EQUALEQUAL expression
    (41) expression_operation -> . expression NOTEQ expression
    (42) expression_operation -> . expression AND expression
    (43) expression_operation -> . expression OR expression
    (44) expression_operation -> . NOT expression

    NAME            shift and go to state 58
    INT             shift and go to state 14
    FLOAT           shift and go to state 15
    STRING          shift and go to state 16
    TRUE            shift and go to state 17
    FALSE           shift and go to state 18
    LBRACE          shift and go to state 19
    LPAREN          shift and go to state 20
    NOT             shift and go to state 26

    expression                     shift and go to state 57
    expression_operation           shift and go to state 13

state 21

    (13) func_assign -> datatype . NAME LPAREN parameters RPAREN START NEWLINE language return_stmt STOP

    NAME            shift and go to state 59


state 22

    (70) iterative -> WHILE . expression START NEWLINE language STOP
    (28) expression -> . NAME
    (30) expression -> . expression_operation
    (45) expression -> . INT
    (46) expression -> . FLOAT
    (47) expression -> . STRING
    (48) expression -> . TRUE
    (49) expression -> . FALSE
    (50) expression -> . LBRACE int_type_array RBRACE
    (51) expression -> . LBRACE float_type_array RBRACE
    (52) expression -> . LBRACE string_type_array RBRACE
    (53) expression -> . LBRACE bool_type_array RBRACE
    (63) expression -> . LPAREN expression RPAREN
    (31) expression_operation -> . expression MULTIPLY expression
    (32) expression_operation -> . expression DIVIDE expression
    (33) expression_operation -> . expression MODULO expression
    (34) expression_operation -> . expression PLUS expression
    (35) expression_operation -> . expression MINUS expression
    (36) expression_operation -> . expression LD expression
    (37) expression_operation -> . expression LDEQ expression
    (38) expression_operation -> . expression GD expression
    (39) expression_operation -> . expression GDEQ expression
    (40) expression_operation -> . expression EQUALEQUAL expression
    (41) expression_operation -> . expression NOTEQ expression
    (42) expression_operation -> . expression AND expression
    (43) expression_operation -> . expression OR expression
    (44) expression_operation -> . NOT expression

    NAME            shift and go to state 58
    INT             shift and go to state 14
    FLOAT           shift and go to state 15
    STRING          shift and go to state 16
    TRUE            shift and go to state 17
    FALSE           shift and go to state 18
    LBRACE          shift and go to state 19
    LPAREN          shift and go to state 20
    NOT             shift and go to state 26

    expression                     shift and go to state 60
    expression_operation           shift and go to state 13

state 23

    (64) conditional -> IF . expression START NEWLINE language STOP else_if_blocks else_block
    (28) expression -> . NAME
    (30) expression -> . expression_operation
    (45) expression -> . INT
    (46) expression -> . FLOAT
    (47) expression -> . STRING
    (48) expression -> . TRUE
    (49) expression -> . FALSE
    (50) expression -> . LBRACE int_type_array RBRACE
    (51) expression -> . LBRACE float_type_array RBRACE
    (52) expression -> . LBRACE string_type_array RBRACE
    (53) expression -> . LBRACE bool_type_array RBRACE
    (63) expression -> . LPAREN expression RPAREN
    (31) expression_operation -> . expression MULTIPLY expression
    (32) expression_operation -> . expression DIVIDE expression
    (33) expression_operation -> . expression MODULO expression
    (34) expression_operation -> . expression PLUS expression
    (35) expression_operation -> . expression MINUS expression
    (36) expression_operation -> . expression LD expression
    (37) expression_operation -> . expression LDEQ expression
    (38) expression_operation -> . expression GD expression
    (39) expression_operation -> . expression GDEQ expression
    (40) expression_operation -> . expression EQUALEQUAL expression
    (41) expression_operation -> . expression NOTEQ expression
    (42) expression_operation -> . expression AND expression
    (43) expression_operation -> . expression OR expression
    (44) expression_operation -> . NOT expression

    NAME            shift and go to state 58
    INT             shift and go to state 14
    FLOAT           shift and go to state 15
    STRING          shift and go to state 16
    TRUE            shift and go to state 17
    FALSE           shift and go to state 18
    LBRACE          shift and go to state 19
    LPAREN          shift and go to state 20
    NOT             shift and go to state 26

    expression                     shift and go to state 61
    expression_operation           shift and go to state 13

state 24

    (26) output -> output_print .

    NEWLINE         reduce using rule 26 (output -> output_print .)
    $end            reduce using rule 26 (output -> output_print .)
    STOP            reduce using rule 26 (output -> output_print .)
    RETURN          reduce using rule 26 (output -> output_print .)


state 25

    (25) input -> READ . LPAREN NAME RPAREN

    LPAREN          shift and go to state 62


state 26

    (44) expression_operation -> NOT . expression
    (28) expression -> . NAME
    (30) expression -> . expression_operation
    (45) expression -> . INT
    (46) expression -> . FLOAT
    (47) expression -> . STRING
    (48) expression -> . TRUE
    (49) expression -> . FALSE
    (50) expression -> . LBRACE int_type_array RBRACE
    (51) expression -> . LBRACE float_type_array RBRACE
    (52) expression -> . LBRACE string_type_array RBRACE
    (53) expression -> . LBRACE bool_type_array RBRACE
    (63) expression -> . LPAREN expression RPAREN
    (31) expression_operation -> . expression MULTIPLY expression
    (32) expression_operation -> . expression DIVIDE expression
    (33) expression_operation -> . expression MODULO expression
    (34) expression_operation -> . expression PLUS expression
    (35) expression_operation -> . expression MINUS expression
    (36) expression_operation -> . expression LD expression
    (37) expression_operation -> . expression LDEQ expression
    (38) expression_operation -> . expression GD expression
    (39) expression_operation -> . expression GDEQ expression
    (40) expression_operation -> . expression EQUALEQUAL expression
    (41) expression_operation -> . expression NOTEQ expression
    (42) expression_operation -> . expression AND expression
    (43) expression_operation -> . expression OR expression
    (44) expression_operation -> . NOT expression

    NAME            shift and go to state 58
    INT             shift and go to state 14
    FLOAT           shift and go to state 15
    STRING          shift and go to state 16
    TRUE            shift and go to state 17
    FALSE           shift and go to state 18
    LBRACE          shift and go to state 19
    LPAREN          shift and go to state 20
    NOT             shift and go to state 26

    expression                     shift and go to state 63
    expression_operation           shift and go to state 13

state 27

    (21) datatype -> INT_TYPE .

    NAME            reduce using rule 21 (datatype -> INT_TYPE .)


state 28

    (22) datatype -> FLOAT_TYPE .

    NAME            reduce using rule 22 (datatype -> FLOAT_TYPE .)


state 29

    (23) datatype -> STRING_TYPE .

    NAME            reduce using rule 23 (datatype -> STRING_TYPE .)


state 30

    (24) datatype -> VOID_TYPE .

    NAME            reduce using rule 24 (datatype -> VOID_TYPE .)


state 31

    (27) output_print -> PRINT . LPAREN expression RPAREN

    LPAREN          shift and go to state 64


state 32

    (3) language -> language NEWLINE . line
    (5) line -> . expression
    (6) line -> . var_assign
    (7) line -> . func_assign
    (8) line -> . iterative
    (9) line -> . conditional
    (10) line -> . output
    (11) line -> . input
    (12) line -> . empty
    (28) expression -> . NAME
    (30) expression -> . expression_operation
    (45) expression -> . INT
    (46) expression -> . FLOAT
    (47) expression -> . STRING
    (48) expression -> . TRUE
    (49) expression -> . FALSE
    (50) expression -> . LBRACE int_type_array RBRACE
    (51) expression -> . LBRACE float_type_array RBRACE
    (52) expression -> . LBRACE string_type_array RBRACE
    (53) expression -> . LBRACE bool_type_array RBRACE
    (63) expression -> . LPAREN expression RPAREN
    (29) var_assign -> . NAME EQUALS expression
    (13) func_assign -> . datatype NAME LPAREN parameters RPAREN START NEWLINE language return_stmt STOP
    (70) iterative -> . WHILE expression START NEWLINE language STOP
    (64) conditional -> . IF expression START NEWLINE language STOP else_if_blocks else_block
    (26) output -> . output_print
    (25) input -> . READ LPAREN NAME RPAREN
    (71) empty -> .
    (31) expression_operation -> . expression MULTIPLY expression
    (32) expression_operation -> . expression DIVIDE expression
    (33) expression_operation -> . expression MODULO expression
    (34) expression_operation -> . expression PLUS expression
    (35) expression_operation -> . expression MINUS expression
    (36) expression_operation -> . expression LD expression
    (37) expression_operation -> . expression LDEQ expression
    (38) expression_operation -> . expression GD expression
    (39) expression_operation -> . expression GDEQ expression
    (40) expression_operation -> . expression EQUALEQUAL expression
    (41) expression_operation -> . expression NOTEQ expression
    (42) expression_operation -> . expression AND expression
    (43) expression_operation -> . expression OR expression
    (44) expression_operation -> . NOT expression
    (21) datatype -> . INT_TYPE
    (22) datatype -> . FLOAT_TYPE
    (23) datatype -> . STRING_TYPE
    (24) datatype -> . VOID_TYPE
    (27) output_print -> . PRINT LPAREN expression RPAREN

    NAME            shift and go to state 12
    INT             shift and go to state 14
    FLOAT           shift and go to state 15
    STRING          shift and go to state 16
    TRUE            shift and go to state 17
    FALSE           shift and go to state 18
    LBRACE          shift and go to state 19
    LPAREN          shift and go to state 20
    WHILE           shift and go to state 22
    IF              shift and go to state 23
    READ            shift and go to state 25
    NEWLINE         reduce using rule 71 (empty -> .)
    $end            reduce using rule 71 (empty -> .)
    STOP            reduce using rule 71 (empty -> .)
    RETURN          reduce using rule 71 (empty -> .)
    NOT             shift and go to state 26
    INT_TYPE        shift and go to state 27
    FLOAT_TYPE      shift and go to state 28
    STRING_TYPE     shift and go to state 29
    VOID_TYPE       shift and go to state 30
    PRINT           shift and go to state 31

    line                           shift and go to state 65
    expression                     shift and go to state 5
    var_assign                     shift and go to state 6
    func_assign                    shift and go to state 7
    iterative                      shift and go to state 8
    conditional                    shift and go to state 9
    output                         shift and go to state 10
    input                          shift and go to state 11
    empty                          shift and go to state 66
    expression_operation           shift and go to state 13
    datatype                       shift and go to state 21
    output_print                   shift and go to state 24

state 33

    (31) expression_operation -> expression MULTIPLY . expression
    (28) expression -> . NAME
    (30) expression -> . expression_operation
    (45) expression -> . INT
    (46) expression -> . FLOAT
    (47) expression -> . STRING
    (48) expression -> . TRUE
    (49) expression -> . FALSE
    (50) expression -> . LBRACE int_type_array RBRACE
    (51) expression -> . LBRACE float_type_array RBRACE
    (52) expression -> . LBRACE string_type_array RBRACE
    (53) expression -> . LBRACE bool_type_array RBRACE
    (63) expression -> . LPAREN expression RPAREN
    (31) expression_operation -> . expression MULTIPLY expression
    (32) expression_operation -> . expression DIVIDE expression
    (33) expression_operation -> . expression MODULO expression
    (34) expression_operation -> . expression PLUS expression
    (35) expression_operation -> . expression MINUS expression
    (36) expression_operation -> . expression LD expression
    (37) expression_operation -> . expression LDEQ expression
    (38) expression_operation -> . expression GD expression
    (39) expression_operation -> . expression GDEQ expression
    (40) expression_operation -> . expression EQUALEQUAL expression
    (41) expression_operation -> . expression NOTEQ expression
    (42) expression_operation -> . expression AND expression
    (43) expression_operation -> . expression OR expression
    (44) expression_operation -> . NOT expression

    NAME            shift and go to state 58
    INT             shift and go to state 14
    FLOAT           shift and go to state 15
    STRING          shift and go to state 16
    TRUE            shift and go to state 17
    FALSE           shift and go to state 18
    LBRACE          shift and go to state 19
    LPAREN          shift and go to state 20
    NOT             shift and go to state 26

    expression                     shift and go to state 67
    expression_operation           shift and go to state 13

state 34

    (32) expression_operation -> expression DIVIDE . expression
    (28) expression -> . NAME
    (30) expression -> . expression_operation
    (45) expression -> . INT
    (46) expression -> . FLOAT
    (47) expression -> . STRING
    (48) expression -> . TRUE
    (49) expression -> . FALSE
    (50) expression -> . LBRACE int_type_array RBRACE
    (51) expression -> . LBRACE float_type_array RBRACE
    (52) expression -> . LBRACE string_type_array RBRACE
    (53) expression -> . LBRACE bool_type_array RBRACE
    (63) expression -> . LPAREN expression RPAREN
    (31) expression_operation -> . expression MULTIPLY expression
    (32) expression_operation -> . expression DIVIDE expression
    (33) expression_operation -> . expression MODULO expression
    (34) expression_operation -> . expression PLUS expression
    (35) expression_operation -> . expression MINUS expression
    (36) expression_operation -> . expression LD expression
    (37) expression_operation -> . expression LDEQ expression
    (38) expression_operation -> . expression GD expression
    (39) expression_operation -> . expression GDEQ expression
    (40) expression_operation -> . expression EQUALEQUAL expression
    (41) expression_operation -> . expression NOTEQ expression
    (42) expression_operation -> . expression AND expression
    (43) expression_operation -> . expression OR expression
    (44) expression_operation -> . NOT expression

    NAME            shift and go to state 58
    INT             shift and go to state 14
    FLOAT           shift and go to state 15
    STRING          shift and go to state 16
    TRUE            shift and go to state 17
    FALSE           shift and go to state 18
    LBRACE          shift and go to state 19
    LPAREN          shift and go to state 20
    NOT             shift and go to state 26

    expression                     shift and go to state 68
    expression_operation           shift and go to state 13

state 35

    (33) expression_operation -> expression MODULO . expression
    (28) expression -> . NAME
    (30) expression -> . expression_operation
    (45) expression -> . INT
    (46) expression -> . FLOAT
    (47) expression -> . STRING
    (48) expression -> . TRUE
    (49) expression -> . FALSE
    (50) expression -> . LBRACE int_type_array RBRACE
    (51) expression -> . LBRACE float_type_array RBRACE
    (52) expression -> . LBRACE string_type_array RBRACE
    (53) expression -> . LBRACE bool_type_array RBRACE
    (63) expression -> . LPAREN expression RPAREN
    (31) expression_operation -> . expression MULTIPLY expression
    (32) expression_operation -> . expression DIVIDE expression
    (33) expression_operation -> . expression MODULO expression
    (34) expression_operation -> . expression PLUS expression
    (35) expression_operation -> . expression MINUS expression
    (36) expression_operation -> . expression LD expression
    (37) expression_operation -> . expression LDEQ expression
    (38) expression_operation -> . expression GD expression
    (39) expression_operation -> . expression GDEQ expression
    (40) expression_operation -> . expression EQUALEQUAL expression
    (41) expression_operation -> . expression NOTEQ expression
    (42) expression_operation -> . expression AND expression
    (43) expression_operation -> . expression OR expression
    (44) expression_operation -> . NOT expression

    NAME            shift and go to state 58
    INT             shift and go to state 14
    FLOAT           shift and go to state 15
    STRING          shift and go to state 16
    TRUE            shift and go to state 17
    FALSE           shift and go to state 18
    LBRACE          shift and go to state 19
    LPAREN          shift and go to state 20
    NOT             shift and go to state 26

    expression                     shift and go to state 69
    expression_operation           shift and go to state 13

state 36

    (34) expression_operation -> expression PLUS . expression
    (28) expression -> . NAME
    (30) expression -> . expression_operation
    (45) expression -> . INT
    (46) expression -> . FLOAT
    (47) expression -> . STRING
    (48) expression -> . TRUE
    (49) expression -> . FALSE
    (50) expression -> . LBRACE int_type_array RBRACE
    (51) expression -> . LBRACE float_type_array RBRACE
    (52) expression -> . LBRACE string_type_array RBRACE
    (53) expression -> . LBRACE bool_type_array RBRACE
    (63) expression -> . LPAREN expression RPAREN
    (31) expression_operation -> . expression MULTIPLY expression
    (32) expression_operation -> . expression DIVIDE expression
    (33) expression_operation -> . expression MODULO expression
    (34) expression_operation -> . expression PLUS expression
    (35) expression_operation -> . expression MINUS expression
    (36) expression_operation -> . expression LD expression
    (37) expression_operation -> . expression LDEQ expression
    (38) expression_operation -> . expression GD expression
    (39) expression_operation -> . expression GDEQ expression
    (40) expression_operation -> . expression EQUALEQUAL expression
    (41) expression_operation -> . expression NOTEQ expression
    (42) expression_operation -> . expression AND expression
    (43) expression_operation -> . expression OR expression
    (44) expression_operation -> . NOT expression

    NAME            shift and go to state 58
    INT             shift and go to state 14
    FLOAT           shift and go to state 15
    STRING          shift and go to state 16
    TRUE            shift and go to state 17
    FALSE           shift and go to state 18
    LBRACE          shift and go to state 19
    LPAREN          shift and go to state 20
    NOT             shift and go to state 26

    expression                     shift and go to state 70
    expression_operation           shift and go to state 13

state 37

    (35) expression_operation -> expression MINUS . expression
    (28) expression -> . NAME
    (30) expression -> . expression_operation
    (45) expression -> . INT
    (46) expression -> . FLOAT
    (47) expression -> . STRING
    (48) expression -> . TRUE
    (49) expression -> . FALSE
    (50) expression -> . LBRACE int_type_array RBRACE
    (51) expression -> . LBRACE float_type_array RBRACE
    (52) expression -> . LBRACE string_type_array RBRACE
    (53) expression -> . LBRACE bool_type_array RBRACE
    (63) expression -> . LPAREN expression RPAREN
    (31) expression_operation -> . expression MULTIPLY expression
    (32) expression_operation -> . expression DIVIDE expression
    (33) expression_operation -> . expression MODULO expression
    (34) expression_operation -> . expression PLUS expression
    (35) expression_operation -> . expression MINUS expression
    (36) expression_operation -> . expression LD expression
    (37) expression_operation -> . expression LDEQ expression
    (38) expression_operation -> . expression GD expression
    (39) expression_operation -> . expression GDEQ expression
    (40) expression_operation -> . expression EQUALEQUAL expression
    (41) expression_operation -> . expression NOTEQ expression
    (42) expression_operation -> . expression AND expression
    (43) expression_operation -> . expression OR expression
    (44) expression_operation -> . NOT expression

    NAME            shift and go to state 58
    INT             shift and go to state 14
    FLOAT           shift and go to state 15
    STRING          shift and go to state 16
    TRUE            shift and go to state 17
    FALSE           shift and go to state 18
    LBRACE          shift and go to state 19
    LPAREN          shift and go to state 20
    NOT             shift and go to state 26

    expression                     shift and go to state 71
    expression_operation           shift and go to state 13

state 38

    (36) expression_operation -> expression LD . expression
    (28) expression -> . NAME
    (30) expression -> . expression_operation
    (45) expression -> . INT
    (46) expression -> . FLOAT
    (47) expression -> . STRING
    (48) expression -> . TRUE
    (49) expression -> . FALSE
    (50) expression -> . LBRACE int_type_array RBRACE
    (51) expression -> . LBRACE float_type_array RBRACE
    (52) expression -> . LBRACE string_type_array RBRACE
    (53) expression -> . LBRACE bool_type_array RBRACE
    (63) expression -> . LPAREN expression RPAREN
    (31) expression_operation -> . expression MULTIPLY expression
    (32) expression_operation -> . expression DIVIDE expression
    (33) expression_operation -> . expression MODULO expression
    (34) expression_operation -> . expression PLUS expression
    (35) expression_operation -> . expression MINUS expression
    (36) expression_operation -> . expression LD expression
    (37) expression_operation -> . expression LDEQ expression
    (38) expression_operation -> . expression GD expression
    (39) expression_operation -> . expression GDEQ expression
    (40) expression_operation -> . expression EQUALEQUAL expression
    (41) expression_operation -> . expression NOTEQ expression
    (42) expression_operation -> . expression AND expression
    (43) expression_operation -> . expression OR expression
    (44) expression_operation -> . NOT expression

    NAME            shift and go to state 58
    INT             shift and go to state 14
    FLOAT           shift and go to state 15
    STRING          shift and go to state 16
    TRUE            shift and go to state 17
    FALSE           shift and go to state 18
    LBRACE          shift and go to state 19
    LPAREN          shift and go to state 20
    NOT             shift and go to state 26

    expression                     shift and go to state 72
    expression_operation           shift and go to state 13

state 39

    (37) expression_operation -> expression LDEQ . expression
    (28) expression -> . NAME
    (30) expression -> . expression_operation
    (45) expression -> . INT
    (46) expression -> . FLOAT
    (47) expression -> . STRING
    (48) expression -> . TRUE
    (49) expression -> . FALSE
    (50) expression -> . LBRACE int_type_array RBRACE
    (51) expression -> . LBRACE float_type_array RBRACE
    (52) expression -> . LBRACE string_type_array RBRACE
    (53) expression -> . LBRACE bool_type_array RBRACE
    (63) expression -> . LPAREN expression RPAREN
    (31) expression_operation -> . expression MULTIPLY expression
    (32) expression_operation -> . expression DIVIDE expression
    (33) expression_operation -> . expression MODULO expression
    (34) expression_operation -> . expression PLUS expression
    (35) expression_operation -> . expression MINUS expression
    (36) expression_operation -> . expression LD expression
    (37) expression_operation -> . expression LDEQ expression
    (38) expression_operation -> . expression GD expression
    (39) expression_operation -> . expression GDEQ expression
    (40) expression_operation -> . expression EQUALEQUAL expression
    (41) expression_operation -> . expression NOTEQ expression
    (42) expression_operation -> . expression AND expression
    (43) expression_operation -> . expression OR expression
    (44) expression_operation -> . NOT expression

    NAME            shift and go to state 58
    INT             shift and go to state 14
    FLOAT           shift and go to state 15
    STRING          shift and go to state 16
    TRUE            shift and go to state 17
    FALSE           shift and go to state 18
    LBRACE          shift and go to state 19
    LPAREN          shift and go to state 20
    NOT             shift and go to state 26

    expression                     shift and go to state 73
    expression_operation           shift and go to state 13

state 40

    (38) expression_operation -> expression GD . expression
    (28) expression -> . NAME
    (30) expression -> . expression_operation
    (45) expression -> . INT
    (46) expression -> . FLOAT
    (47) expression -> . STRING
    (48) expression -> . TRUE
    (49) expression -> . FALSE
    (50) expression -> . LBRACE int_type_array RBRACE
    (51) expression -> . LBRACE float_type_array RBRACE
    (52) expression -> . LBRACE string_type_array RBRACE
    (53) expression -> . LBRACE bool_type_array RBRACE
    (63) expression -> . LPAREN expression RPAREN
    (31) expression_operation -> . expression MULTIPLY expression
    (32) expression_operation -> . expression DIVIDE expression
    (33) expression_operation -> . expression MODULO expression
    (34) expression_operation -> . expression PLUS expression
    (35) expression_operation -> . expression MINUS expression
    (36) expression_operation -> . expression LD expression
    (37) expression_operation -> . expression LDEQ expression
    (38) expression_operation -> . expression GD expression
    (39) expression_operation -> . expression GDEQ expression
    (40) expression_operation -> . expression EQUALEQUAL expression
    (41) expression_operation -> . expression NOTEQ expression
    (42) expression_operation -> . expression AND expression
    (43) expression_operation -> . expression OR expression
    (44) expression_operation -> . NOT expression

    NAME            shift and go to state 58
    INT             shift and go to state 14
    FLOAT           shift and go to state 15
    STRING          shift and go to state 16
    TRUE            shift and go to state 17
    FALSE           shift and go to state 18
    LBRACE          shift and go to state 19
    LPAREN          shift and go to state 20
    NOT             shift and go to state 26

    expression                     shift and go to state 74
    expression_operation           shift and go to state 13

state 41

    (39) expression_operation -> expression GDEQ . expression
    (28) expression -> . NAME
    (30) expression -> . expression_operation
    (45) expression -> . INT
    (46) expression -> . FLOAT
    (47) expression -> . STRING
    (48) expression -> . TRUE
    (49) expression -> . FALSE
    (50) expression -> . LBRACE int_type_array RBRACE
    (51) expression -> . LBRACE float_type_array RBRACE
    (52) expression -> . LBRACE string_type_array RBRACE
    (53) expression -> . LBRACE bool_type_array RBRACE
    (63) expression -> . LPAREN expression RPAREN
    (31) expression_operation -> . expression MULTIPLY expression
    (32) expression_operation -> . expression DIVIDE expression
    (33) expression_operation -> . expression MODULO expression
    (34) expression_operation -> . expression PLUS expression
    (35) expression_operation -> . expression MINUS expression
    (36) expression_operation -> . expression LD expression
    (37) expression_operation -> . expression LDEQ expression
    (38) expression_operation -> . expression GD expression
    (39) expression_operation -> . expression GDEQ expression
    (40) expression_operation -> . expression EQUALEQUAL expression
    (41) expression_operation -> . expression NOTEQ expression
    (42) expression_operation -> . expression AND expression
    (43) expression_operation -> . expression OR expression
    (44) expression_operation -> . NOT expression

    NAME            shift and go to state 58
    INT             shift and go to state 14
    FLOAT           shift and go to state 15
    STRING          shift and go to state 16
    TRUE            shift and go to state 17
    FALSE           shift and go to state 18
    LBRACE          shift and go to state 19
    LPAREN          shift and go to state 20
    NOT             shift and go to state 26

    expression                     shift and go to state 75
    expression_operation           shift and go to state 13

state 42

    (40) expression_operation -> expression EQUALEQUAL . expression
    (28) expression -> . NAME
    (30) expression -> . expression_operation
    (45) expression -> . INT
    (46) expression -> . FLOAT
    (47) expression -> . STRING
    (48) expression -> . TRUE
    (49) expression -> . FALSE
    (50) expression -> . LBRACE int_type_array RBRACE
    (51) expression -> . LBRACE float_type_array RBRACE
    (52) expression -> . LBRACE string_type_array RBRACE
    (53) expression -> . LBRACE bool_type_array RBRACE
    (63) expression -> . LPAREN expression RPAREN
    (31) expression_operation -> . expression MULTIPLY expression
    (32) expression_operation -> . expression DIVIDE expression
    (33) expression_operation -> . expression MODULO expression
    (34) expression_operation -> . expression PLUS expression
    (35) expression_operation -> . expression MINUS expression
    (36) expression_operation -> . expression LD expression
    (37) expression_operation -> . expression LDEQ expression
    (38) expression_operation -> . expression GD expression
    (39) expression_operation -> . expression GDEQ expression
    (40) expression_operation -> . expression EQUALEQUAL expression
    (41) expression_operation -> . expression NOTEQ expression
    (42) expression_operation -> . expression AND expression
    (43) expression_operation -> . expression OR expression
    (44) expression_operation -> . NOT expression

    NAME            shift and go to state 58
    INT             shift and go to state 14
    FLOAT           shift and go to state 15
    STRING          shift and go to state 16
    TRUE            shift and go to state 17
    FALSE           shift and go to state 18
    LBRACE          shift and go to state 19
    LPAREN          shift and go to state 20
    NOT             shift and go to state 26

    expression                     shift and go to state 76
    expression_operation           shift and go to state 13

state 43

    (41) expression_operation -> expression NOTEQ . expression
    (28) expression -> . NAME
    (30) expression -> . expression_operation
    (45) expression -> . INT
    (46) expression -> . FLOAT
    (47) expression -> . STRING
    (48) expression -> . TRUE
    (49) expression -> . FALSE
    (50) expression -> . LBRACE int_type_array RBRACE
    (51) expression -> . LBRACE float_type_array RBRACE
    (52) expression -> . LBRACE string_type_array RBRACE
    (53) expression -> . LBRACE bool_type_array RBRACE
    (63) expression -> . LPAREN expression RPAREN
    (31) expression_operation -> . expression MULTIPLY expression
    (32) expression_operation -> . expression DIVIDE expression
    (33) expression_operation -> . expression MODULO expression
    (34) expression_operation -> . expression PLUS expression
    (35) expression_operation -> . expression MINUS expression
    (36) expression_operation -> . expression LD expression
    (37) expression_operation -> . expression LDEQ expression
    (38) expression_operation -> . expression GD expression
    (39) expression_operation -> . expression GDEQ expression
    (40) expression_operation -> . expression EQUALEQUAL expression
    (41) expression_operation -> . expression NOTEQ expression
    (42) expression_operation -> . expression AND expression
    (43) expression_operation -> . expression OR expression
    (44) expression_operation -> . NOT expression

    NAME            shift and go to state 58
    INT             shift and go to state 14
    FLOAT           shift and go to state 15
    STRING          shift and go to state 16
    TRUE            shift and go to state 17
    FALSE           shift and go to state 18
    LBRACE          shift and go to state 19
    LPAREN          shift and go to state 20
    NOT             shift and go to state 26

    expression                     shift and go to state 77
    expression_operation           shift and go to state 13

state 44

    (42) expression_operation -> expression AND . expression
    (28) expression -> . NAME
    (30) expression -> . expression_operation
    (45) expression -> . INT
    (46) expression -> . FLOAT
    (47) expression -> . STRING
    (48) expression -> . TRUE
    (49) expression -> . FALSE
    (50) expression -> . LBRACE int_type_array RBRACE
    (51) expression -> . LBRACE float_type_array RBRACE
    (52) expression -> . LBRACE string_type_array RBRACE
    (53) expression -> . LBRACE bool_type_array RBRACE
    (63) expression -> . LPAREN expression RPAREN
    (31) expression_operation -> . expression MULTIPLY expression
    (32) expression_operation -> . expression DIVIDE expression
    (33) expression_operation -> . expression MODULO expression
    (34) expression_operation -> . expression PLUS expression
    (35) expression_operation -> . expression MINUS expression
    (36) expression_operation -> . expression LD expression
    (37) expression_operation -> . expression LDEQ expression
    (38) expression_operation -> . expression GD expression
    (39) expression_operation -> . expression GDEQ expression
    (40) expression_operation -> . expression EQUALEQUAL expression
    (41) expression_operation -> . expression NOTEQ expression
    (42) expression_operation -> . expression AND expression
    (43) expression_operation -> . expression OR expression
    (44) expression_operation -> . NOT expression

    NAME            shift and go to state 58
    INT             shift and go to state 14
    FLOAT           shift and go to state 15
    STRING          shift and go to state 16
    TRUE            shift and go to state 17
    FALSE           shift and go to state 18
    LBRACE          shift and go to state 19
    LPAREN          shift and go to state 20
    NOT             shift and go to state 26

    expression                     shift and go to state 78
    expression_operation           shift and go to state 13

state 45

    (43) expression_operation -> expression OR . expression
    (28) expression -> . NAME
    (30) expression -> . expression_operation
    (45) expression -> . INT
    (46) expression -> . FLOAT
    (47) expression -> . STRING
    (48) expression -> . TRUE
    (49) expression -> . FALSE
    (50) expression -> . LBRACE int_type_array RBRACE
    (51) expression -> . LBRACE float_type_array RBRACE
    (52) expression -> . LBRACE string_type_array RBRACE
    (53) expression -> . LBRACE bool_type_array RBRACE
    (63) expression -> . LPAREN expression RPAREN
    (31) expression_operation -> . expression MULTIPLY expression
    (32) expression_operation -> . expression DIVIDE expression
    (33) expression_operation -> . expression MODULO expression
    (34) expression_operation -> . expression PLUS expression
    (35) expression_operation -> . expression MINUS expression
    (36) expression_operation -> . expression LD expression
    (37) expression_operation -> . expression LDEQ expression
    (38) expression_operation -> . expression GD expression
    (39) expression_operation -> . expression GDEQ expression
    (40) expression_operation -> . expression EQUALEQUAL expression
    (41) expression_operation -> . expression NOTEQ expression
    (42) expression_operation -> . expression AND expression
    (43) expression_operation -> . expression OR expression
    (44) expression_operation -> . NOT expression

    NAME            shift and go to state 58
    INT             shift and go to state 14
    FLOAT           shift and go to state 15
    STRING          shift and go to state 16
    TRUE            shift and go to state 17
    FALSE           shift and go to state 18
    LBRACE          shift and go to state 19
    LPAREN          shift and go to state 20
    NOT             shift and go to state 26

    expression                     shift and go to state 79
    expression_operation           shift and go to state 13

state 46

    (29) var_assign -> NAME EQUALS . expression
    (28) expression -> . NAME
    (30) expression -> . expression_operation
    (45) expression -> . INT
    (46) expression -> . FLOAT
    (47) expression -> . STRING
    (48) expression -> . TRUE
    (49) expression -> . FALSE
    (50) expression -> . LBRACE int_type_array RBRACE
    (51) expression -> . LBRACE float_type_array RBRACE
    (52) expression -> . LBRACE string_type_array RBRACE
    (53) expression -> . LBRACE bool_type_array RBRACE
    (63) expression -> . LPAREN expression RPAREN
    (31) expression_operation -> . expression MULTIPLY expression
    (32) expression_operation -> . expression DIVIDE expression
    (33) expression_operation -> . expression MODULO expression
    (34) expression_operation -> . expression PLUS expression
    (35) expression_operation -> . expression MINUS expression
    (36) expression_operation -> . expression LD expression
    (37) expression_operation -> . expression LDEQ expression
    (38) expression_operation -> . expression GD expression
    (39) expression_operation -> . expression GDEQ expression
    (40) expression_operation -> . expression EQUALEQUAL expression
    (41) expression_operation -> . expression NOTEQ expression
    (42) expression_operation -> . expression AND expression
    (43) expression_operation -> . expression OR expression
    (44) expression_operation -> . NOT expression

    NAME            shift and go to state 58
    INT             shift and go to state 14
    FLOAT           shift and go to state 15
    STRING          shift and go to state 16
    TRUE            shift and go to state 17
    FALSE           shift and go to state 18
    LBRACE          shift and go to state 19
    LPAREN          shift and go to state 20
    NOT             shift and go to state 26

    expression                     shift and go to state 80
    expression_operation           shift and go to state 13

state 47

    (50) expression -> LBRACE int_type_array . RBRACE

    RBRACE          shift and go to state 81


state 48

    (51) expression -> LBRACE float_type_array . RBRACE

    RBRACE          shift and go to state 82


state 49

    (52) expression -> LBRACE string_type_array . RBRACE

    RBRACE          shift and go to state 83


state 50

    (53) expression -> LBRACE bool_type_array . RBRACE

    RBRACE          shift and go to state 84


state 51

    (54) int_type_array -> empty .
    (56) float_type_array -> empty .
    (58) string_type_array -> empty .
    (60) bool_type_array -> empty .

  ! reduce/reduce conflict for RBRACE resolved using rule 54 (int_type_array -> empty .)
  ! reduce/reduce conflict for RBRACE resolved using rule 54 (int_type_array -> empty .)
  ! reduce/reduce conflict for RBRACE resolved using rule 54 (int_type_array -> empty .)
    RBRACE          reduce using rule 54 (int_type_array -> empty .)

  ! RBRACE          [ reduce using rule 56 (float_type_array -> empty .) ]
  ! RBRACE          [ reduce using rule 58 (string_type_array -> empty .) ]
  ! RBRACE          [ reduce using rule 60 (bool_type_array -> empty .) ]


state 52

    (55) int_type_array -> INT . int_type_array
    (54) int_type_array -> . empty
    (55) int_type_array -> . INT int_type_array
    (71) empty -> .

    INT             shift and go to state 52
    RBRACE          reduce using rule 71 (empty -> .)

    int_type_array                 shift and go to state 85
    empty                          shift and go to state 86

state 53

    (57) float_type_array -> FLOAT . float_type_array
    (56) float_type_array -> . empty
    (57) float_type_array -> . FLOAT float_type_array
    (71) empty -> .

    FLOAT           shift and go to state 53
    RBRACE          reduce using rule 71 (empty -> .)

    float_type_array               shift and go to state 87
    empty                          shift and go to state 88

state 54

    (59) string_type_array -> STRING . string_type_array
    (58) string_type_array -> . empty
    (59) string_type_array -> . STRING string_type_array
    (71) empty -> .

    STRING          shift and go to state 54
    RBRACE          reduce using rule 71 (empty -> .)

    string_type_array              shift and go to state 89
    empty                          shift and go to state 90

state 55

    (61) bool_type_array -> TRUE . bool_type_array
    (60) bool_type_array -> . empty
    (61) bool_type_array -> . TRUE bool_type_array
    (62) bool_type_array -> . FALSE bool_type_array
    (71) empty -> .

    TRUE            shift and go to state 55
    FALSE           shift and go to state 56
    RBRACE          reduce using rule 71 (empty -> .)

    bool_type_array                shift and go to state 91
    empty                          shift and go to state 92

state 56

    (62) bool_type_array -> FALSE . bool_type_array
    (60) bool_type_array -> . empty
    (61) bool_type_array -> . TRUE bool_type_array
    (62) bool_type_array -> . FALSE bool_type_array
    (71) empty -> .

    TRUE            shift and go to state 55
    FALSE           shift and go to state 56
    RBRACE          reduce using rule 71 (empty -> .)

    bool_type_array                shift and go to state 93
    empty                          shift and go to state 92

state 57

    (63) expression -> LPAREN expression . RPAREN
    (31) expression_operation -> expression . MULTIPLY expression
    (32) expression_operation -> expression . DIVIDE expression
    (33) expression_operation -> expression . MODULO expression
    (34) expression_operation -> expression . PLUS expression
    (35) expression_operation -> expression . MINUS expression
    (36) expression_operation -> expression . LD expression
    (37) expression_operation -> expression . LDEQ expression
    (38) expression_operation -> expression . GD expression
    (39) expression_operation -> expression . GDEQ expression
    (40) expression_operation -> expression . EQUALEQUAL expression
    (41) expression_operation -> expression . NOTEQ expression
    (42) expression_operation -> expression . AND expression
    (43) expression_operation -> expression . OR expression

    RPAREN          shift and go to state 94
    MULTIPLY        shift and go to state 33
    DIVIDE          shift and go to state 34
    MODULO          shift and go to state 35
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    LD              shift and go to state 38
    LDEQ            shift and go to state 39
    GD              shift and go to state 40
    GDEQ            shift and go to state 41
    EQUALEQUAL      shift and go to state 42
    NOTEQ           shift and go to state 43
    AND             shift and go to state 44
    OR              shift and go to state 45


state 58

    (28) expression -> NAME .

    RPAREN          reduce using rule 28 (expression -> NAME .)
    MULTIPLY        reduce using rule 28 (expression -> NAME .)
    DIVIDE          reduce using rule 28 (expression -> NAME .)
    MODULO          reduce using rule 28 (expression -> NAME .)
    PLUS            reduce using rule 28 (expression -> NAME .)
    MINUS           reduce using rule 28 (expression -> NAME .)
    LD              reduce using rule 28 (expression -> NAME .)
    LDEQ            reduce using rule 28 (expression -> NAME .)
    GD              reduce using rule 28 (expression -> NAME .)
    GDEQ            reduce using rule 28 (expression -> NAME .)
    EQUALEQUAL      reduce using rule 28 (expression -> NAME .)
    NOTEQ           reduce using rule 28 (expression -> NAME .)
    AND             reduce using rule 28 (expression -> NAME .)
    OR              reduce using rule 28 (expression -> NAME .)
    START           reduce using rule 28 (expression -> NAME .)
    NEWLINE         reduce using rule 28 (expression -> NAME .)
    $end            reduce using rule 28 (expression -> NAME .)
    STOP            reduce using rule 28 (expression -> NAME .)
    RETURN          reduce using rule 28 (expression -> NAME .)


state 59

    (13) func_assign -> datatype NAME . LPAREN parameters RPAREN START NEWLINE language return_stmt STOP

    LPAREN          shift and go to state 95


state 60

    (70) iterative -> WHILE expression . START NEWLINE language STOP
    (31) expression_operation -> expression . MULTIPLY expression
    (32) expression_operation -> expression . DIVIDE expression
    (33) expression_operation -> expression . MODULO expression
    (34) expression_operation -> expression . PLUS expression
    (35) expression_operation -> expression . MINUS expression
    (36) expression_operation -> expression . LD expression
    (37) expression_operation -> expression . LDEQ expression
    (38) expression_operation -> expression . GD expression
    (39) expression_operation -> expression . GDEQ expression
    (40) expression_operation -> expression . EQUALEQUAL expression
    (41) expression_operation -> expression . NOTEQ expression
    (42) expression_operation -> expression . AND expression
    (43) expression_operation -> expression . OR expression

    START           shift and go to state 96
    MULTIPLY        shift and go to state 33
    DIVIDE          shift and go to state 34
    MODULO          shift and go to state 35
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    LD              shift and go to state 38
    LDEQ            shift and go to state 39
    GD              shift and go to state 40
    GDEQ            shift and go to state 41
    EQUALEQUAL      shift and go to state 42
    NOTEQ           shift and go to state 43
    AND             shift and go to state 44
    OR              shift and go to state 45


state 61

    (64) conditional -> IF expression . START NEWLINE language STOP else_if_blocks else_block
    (31) expression_operation -> expression . MULTIPLY expression
    (32) expression_operation -> expression . DIVIDE expression
    (33) expression_operation -> expression . MODULO expression
    (34) expression_operation -> expression . PLUS expression
    (35) expression_operation -> expression . MINUS expression
    (36) expression_operation -> expression . LD expression
    (37) expression_operation -> expression . LDEQ expression
    (38) expression_operation -> expression . GD expression
    (39) expression_operation -> expression . GDEQ expression
    (40) expression_operation -> expression . EQUALEQUAL expression
    (41) expression_operation -> expression . NOTEQ expression
    (42) expression_operation -> expression . AND expression
    (43) expression_operation -> expression . OR expression

    START           shift and go to state 97
    MULTIPLY        shift and go to state 33
    DIVIDE          shift and go to state 34
    MODULO          shift and go to state 35
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    LD              shift and go to state 38
    LDEQ            shift and go to state 39
    GD              shift and go to state 40
    GDEQ            shift and go to state 41
    EQUALEQUAL      shift and go to state 42
    NOTEQ           shift and go to state 43
    AND             shift and go to state 44
    OR              shift and go to state 45


state 62

    (25) input -> READ LPAREN . NAME RPAREN

    NAME            shift and go to state 98


state 63

    (44) expression_operation -> NOT expression .
    (31) expression_operation -> expression . MULTIPLY expression
    (32) expression_operation -> expression . DIVIDE expression
    (33) expression_operation -> expression . MODULO expression
    (34) expression_operation -> expression . PLUS expression
    (35) expression_operation -> expression . MINUS expression
    (36) expression_operation -> expression . LD expression
    (37) expression_operation -> expression . LDEQ expression
    (38) expression_operation -> expression . GD expression
    (39) expression_operation -> expression . GDEQ expression
    (40) expression_operation -> expression . EQUALEQUAL expression
    (41) expression_operation -> expression . NOTEQ expression
    (42) expression_operation -> expression . AND expression
    (43) expression_operation -> expression . OR expression

    MULTIPLY        reduce using rule 44 (expression_operation -> NOT expression .)
    DIVIDE          reduce using rule 44 (expression_operation -> NOT expression .)
    MODULO          reduce using rule 44 (expression_operation -> NOT expression .)
    PLUS            reduce using rule 44 (expression_operation -> NOT expression .)
    MINUS           reduce using rule 44 (expression_operation -> NOT expression .)
    LD              reduce using rule 44 (expression_operation -> NOT expression .)
    LDEQ            reduce using rule 44 (expression_operation -> NOT expression .)
    GD              reduce using rule 44 (expression_operation -> NOT expression .)
    GDEQ            reduce using rule 44 (expression_operation -> NOT expression .)
    EQUALEQUAL      reduce using rule 44 (expression_operation -> NOT expression .)
    NOTEQ           reduce using rule 44 (expression_operation -> NOT expression .)
    AND             reduce using rule 44 (expression_operation -> NOT expression .)
    OR              reduce using rule 44 (expression_operation -> NOT expression .)
    NEWLINE         reduce using rule 44 (expression_operation -> NOT expression .)
    $end            reduce using rule 44 (expression_operation -> NOT expression .)
    RPAREN          reduce using rule 44 (expression_operation -> NOT expression .)
    START           reduce using rule 44 (expression_operation -> NOT expression .)
    STOP            reduce using rule 44 (expression_operation -> NOT expression .)
    RETURN          reduce using rule 44 (expression_operation -> NOT expression .)

  ! MULTIPLY        [ shift and go to state 33 ]
  ! DIVIDE          [ shift and go to state 34 ]
  ! MODULO          [ shift and go to state 35 ]
  ! PLUS            [ shift and go to state 36 ]
  ! MINUS           [ shift and go to state 37 ]
  ! LD              [ shift and go to state 38 ]
  ! LDEQ            [ shift and go to state 39 ]
  ! GD              [ shift and go to state 40 ]
  ! GDEQ            [ shift and go to state 41 ]
  ! EQUALEQUAL      [ shift and go to state 42 ]
  ! NOTEQ           [ shift and go to state 43 ]
  ! AND             [ shift and go to state 44 ]
  ! OR              [ shift and go to state 45 ]


state 64

    (27) output_print -> PRINT LPAREN . expression RPAREN
    (28) expression -> . NAME
    (30) expression -> . expression_operation
    (45) expression -> . INT
    (46) expression -> . FLOAT
    (47) expression -> . STRING
    (48) expression -> . TRUE
    (49) expression -> . FALSE
    (50) expression -> . LBRACE int_type_array RBRACE
    (51) expression -> . LBRACE float_type_array RBRACE
    (52) expression -> . LBRACE string_type_array RBRACE
    (53) expression -> . LBRACE bool_type_array RBRACE
    (63) expression -> . LPAREN expression RPAREN
    (31) expression_operation -> . expression MULTIPLY expression
    (32) expression_operation -> . expression DIVIDE expression
    (33) expression_operation -> . expression MODULO expression
    (34) expression_operation -> . expression PLUS expression
    (35) expression_operation -> . expression MINUS expression
    (36) expression_operation -> . expression LD expression
    (37) expression_operation -> . expression LDEQ expression
    (38) expression_operation -> . expression GD expression
    (39) expression_operation -> . expression GDEQ expression
    (40) expression_operation -> . expression EQUALEQUAL expression
    (41) expression_operation -> . expression NOTEQ expression
    (42) expression_operation -> . expression AND expression
    (43) expression_operation -> . expression OR expression
    (44) expression_operation -> . NOT expression

    NAME            shift and go to state 58
    INT             shift and go to state 14
    FLOAT           shift and go to state 15
    STRING          shift and go to state 16
    TRUE            shift and go to state 17
    FALSE           shift and go to state 18
    LBRACE          shift and go to state 19
    LPAREN          shift and go to state 20
    NOT             shift and go to state 26

    expression                     shift and go to state 99
    expression_operation           shift and go to state 13

state 65

    (3) language -> language NEWLINE line .

    NEWLINE         reduce using rule 3 (language -> language NEWLINE line .)
    $end            reduce using rule 3 (language -> language NEWLINE line .)
    STOP            reduce using rule 3 (language -> language NEWLINE line .)
    RETURN          reduce using rule 3 (language -> language NEWLINE line .)


state 66

    (12) line -> empty .

    NEWLINE         reduce using rule 12 (line -> empty .)
    $end            reduce using rule 12 (line -> empty .)
    STOP            reduce using rule 12 (line -> empty .)
    RETURN          reduce using rule 12 (line -> empty .)


state 67

    (31) expression_operation -> expression MULTIPLY expression .
    (31) expression_operation -> expression . MULTIPLY expression
    (32) expression_operation -> expression . DIVIDE expression
    (33) expression_operation -> expression . MODULO expression
    (34) expression_operation -> expression . PLUS expression
    (35) expression_operation -> expression . MINUS expression
    (36) expression_operation -> expression . LD expression
    (37) expression_operation -> expression . LDEQ expression
    (38) expression_operation -> expression . GD expression
    (39) expression_operation -> expression . GDEQ expression
    (40) expression_operation -> expression . EQUALEQUAL expression
    (41) expression_operation -> expression . NOTEQ expression
    (42) expression_operation -> expression . AND expression
    (43) expression_operation -> expression . OR expression

    MULTIPLY        reduce using rule 31 (expression_operation -> expression MULTIPLY expression .)
    DIVIDE          reduce using rule 31 (expression_operation -> expression MULTIPLY expression .)
    MODULO          reduce using rule 31 (expression_operation -> expression MULTIPLY expression .)
    PLUS            reduce using rule 31 (expression_operation -> expression MULTIPLY expression .)
    MINUS           reduce using rule 31 (expression_operation -> expression MULTIPLY expression .)
    LD              reduce using rule 31 (expression_operation -> expression MULTIPLY expression .)
    LDEQ            reduce using rule 31 (expression_operation -> expression MULTIPLY expression .)
    GD              reduce using rule 31 (expression_operation -> expression MULTIPLY expression .)
    GDEQ            reduce using rule 31 (expression_operation -> expression MULTIPLY expression .)
    EQUALEQUAL      reduce using rule 31 (expression_operation -> expression MULTIPLY expression .)
    NOTEQ           reduce using rule 31 (expression_operation -> expression MULTIPLY expression .)
    AND             reduce using rule 31 (expression_operation -> expression MULTIPLY expression .)
    OR              reduce using rule 31 (expression_operation -> expression MULTIPLY expression .)
    NEWLINE         reduce using rule 31 (expression_operation -> expression MULTIPLY expression .)
    $end            reduce using rule 31 (expression_operation -> expression MULTIPLY expression .)
    RPAREN          reduce using rule 31 (expression_operation -> expression MULTIPLY expression .)
    START           reduce using rule 31 (expression_operation -> expression MULTIPLY expression .)
    STOP            reduce using rule 31 (expression_operation -> expression MULTIPLY expression .)
    RETURN          reduce using rule 31 (expression_operation -> expression MULTIPLY expression .)

  ! MULTIPLY        [ shift and go to state 33 ]
  ! DIVIDE          [ shift and go to state 34 ]
  ! MODULO          [ shift and go to state 35 ]
  ! PLUS            [ shift and go to state 36 ]
  ! MINUS           [ shift and go to state 37 ]
  ! LD              [ shift and go to state 38 ]
  ! LDEQ            [ shift and go to state 39 ]
  ! GD              [ shift and go to state 40 ]
  ! GDEQ            [ shift and go to state 41 ]
  ! EQUALEQUAL      [ shift and go to state 42 ]
  ! NOTEQ           [ shift and go to state 43 ]
  ! AND             [ shift and go to state 44 ]
  ! OR              [ shift and go to state 45 ]


state 68

    (32) expression_operation -> expression DIVIDE expression .
    (31) expression_operation -> expression . MULTIPLY expression
    (32) expression_operation -> expression . DIVIDE expression
    (33) expression_operation -> expression . MODULO expression
    (34) expression_operation -> expression . PLUS expression
    (35) expression_operation -> expression . MINUS expression
    (36) expression_operation -> expression . LD expression
    (37) expression_operation -> expression . LDEQ expression
    (38) expression_operation -> expression . GD expression
    (39) expression_operation -> expression . GDEQ expression
    (40) expression_operation -> expression . EQUALEQUAL expression
    (41) expression_operation -> expression . NOTEQ expression
    (42) expression_operation -> expression . AND expression
    (43) expression_operation -> expression . OR expression

    MULTIPLY        reduce using rule 32 (expression_operation -> expression DIVIDE expression .)
    DIVIDE          reduce using rule 32 (expression_operation -> expression DIVIDE expression .)
    MODULO          reduce using rule 32 (expression_operation -> expression DIVIDE expression .)
    PLUS            reduce using rule 32 (expression_operation -> expression DIVIDE expression .)
    MINUS           reduce using rule 32 (expression_operation -> expression DIVIDE expression .)
    LD              reduce using rule 32 (expression_operation -> expression DIVIDE expression .)
    LDEQ            reduce using rule 32 (expression_operation -> expression DIVIDE expression .)
    GD              reduce using rule 32 (expression_operation -> expression DIVIDE expression .)
    GDEQ            reduce using rule 32 (expression_operation -> expression DIVIDE expression .)
    EQUALEQUAL      reduce using rule 32 (expression_operation -> expression DIVIDE expression .)
    NOTEQ           reduce using rule 32 (expression_operation -> expression DIVIDE expression .)
    AND             reduce using rule 32 (expression_operation -> expression DIVIDE expression .)
    OR              reduce using rule 32 (expression_operation -> expression DIVIDE expression .)
    NEWLINE         reduce using rule 32 (expression_operation -> expression DIVIDE expression .)
    $end            reduce using rule 32 (expression_operation -> expression DIVIDE expression .)
    RPAREN          reduce using rule 32 (expression_operation -> expression DIVIDE expression .)
    START           reduce using rule 32 (expression_operation -> expression DIVIDE expression .)
    STOP            reduce using rule 32 (expression_operation -> expression DIVIDE expression .)
    RETURN          reduce using rule 32 (expression_operation -> expression DIVIDE expression .)

  ! MULTIPLY        [ shift and go to state 33 ]
  ! DIVIDE          [ shift and go to state 34 ]
  ! MODULO          [ shift and go to state 35 ]
  ! PLUS            [ shift and go to state 36 ]
  ! MINUS           [ shift and go to state 37 ]
  ! LD              [ shift and go to state 38 ]
  ! LDEQ            [ shift and go to state 39 ]
  ! GD              [ shift and go to state 40 ]
  ! GDEQ            [ shift and go to state 41 ]
  ! EQUALEQUAL      [ shift and go to state 42 ]
  ! NOTEQ           [ shift and go to state 43 ]
  ! AND             [ shift and go to state 44 ]
  ! OR              [ shift and go to state 45 ]


state 69

    (33) expression_operation -> expression MODULO expression .
    (31) expression_operation -> expression . MULTIPLY expression
    (32) expression_operation -> expression . DIVIDE expression
    (33) expression_operation -> expression . MODULO expression
    (34) expression_operation -> expression . PLUS expression
    (35) expression_operation -> expression . MINUS expression
    (36) expression_operation -> expression . LD expression
    (37) expression_operation -> expression . LDEQ expression
    (38) expression_operation -> expression . GD expression
    (39) expression_operation -> expression . GDEQ expression
    (40) expression_operation -> expression . EQUALEQUAL expression
    (41) expression_operation -> expression . NOTEQ expression
    (42) expression_operation -> expression . AND expression
    (43) expression_operation -> expression . OR expression

    MULTIPLY        reduce using rule 33 (expression_operation -> expression MODULO expression .)
    DIVIDE          reduce using rule 33 (expression_operation -> expression MODULO expression .)
    MODULO          reduce using rule 33 (expression_operation -> expression MODULO expression .)
    PLUS            reduce using rule 33 (expression_operation -> expression MODULO expression .)
    MINUS           reduce using rule 33 (expression_operation -> expression MODULO expression .)
    LD              reduce using rule 33 (expression_operation -> expression MODULO expression .)
    LDEQ            reduce using rule 33 (expression_operation -> expression MODULO expression .)
    GD              reduce using rule 33 (expression_operation -> expression MODULO expression .)
    GDEQ            reduce using rule 33 (expression_operation -> expression MODULO expression .)
    EQUALEQUAL      reduce using rule 33 (expression_operation -> expression MODULO expression .)
    NOTEQ           reduce using rule 33 (expression_operation -> expression MODULO expression .)
    AND             reduce using rule 33 (expression_operation -> expression MODULO expression .)
    OR              reduce using rule 33 (expression_operation -> expression MODULO expression .)
    NEWLINE         reduce using rule 33 (expression_operation -> expression MODULO expression .)
    $end            reduce using rule 33 (expression_operation -> expression MODULO expression .)
    RPAREN          reduce using rule 33 (expression_operation -> expression MODULO expression .)
    START           reduce using rule 33 (expression_operation -> expression MODULO expression .)
    STOP            reduce using rule 33 (expression_operation -> expression MODULO expression .)
    RETURN          reduce using rule 33 (expression_operation -> expression MODULO expression .)

  ! MULTIPLY        [ shift and go to state 33 ]
  ! DIVIDE          [ shift and go to state 34 ]
  ! MODULO          [ shift and go to state 35 ]
  ! PLUS            [ shift and go to state 36 ]
  ! MINUS           [ shift and go to state 37 ]
  ! LD              [ shift and go to state 38 ]
  ! LDEQ            [ shift and go to state 39 ]
  ! GD              [ shift and go to state 40 ]
  ! GDEQ            [ shift and go to state 41 ]
  ! EQUALEQUAL      [ shift and go to state 42 ]
  ! NOTEQ           [ shift and go to state 43 ]
  ! AND             [ shift and go to state 44 ]
  ! OR              [ shift and go to state 45 ]


state 70

    (34) expression_operation -> expression PLUS expression .
    (31) expression_operation -> expression . MULTIPLY expression
    (32) expression_operation -> expression . DIVIDE expression
    (33) expression_operation -> expression . MODULO expression
    (34) expression_operation -> expression . PLUS expression
    (35) expression_operation -> expression . MINUS expression
    (36) expression_operation -> expression . LD expression
    (37) expression_operation -> expression . LDEQ expression
    (38) expression_operation -> expression . GD expression
    (39) expression_operation -> expression . GDEQ expression
    (40) expression_operation -> expression . EQUALEQUAL expression
    (41) expression_operation -> expression . NOTEQ expression
    (42) expression_operation -> expression . AND expression
    (43) expression_operation -> expression . OR expression

    PLUS            reduce using rule 34 (expression_operation -> expression PLUS expression .)
    MINUS           reduce using rule 34 (expression_operation -> expression PLUS expression .)
    LD              reduce using rule 34 (expression_operation -> expression PLUS expression .)
    LDEQ            reduce using rule 34 (expression_operation -> expression PLUS expression .)
    GD              reduce using rule 34 (expression_operation -> expression PLUS expression .)
    GDEQ            reduce using rule 34 (expression_operation -> expression PLUS expression .)
    EQUALEQUAL      reduce using rule 34 (expression_operation -> expression PLUS expression .)
    NOTEQ           reduce using rule 34 (expression_operation -> expression PLUS expression .)
    AND             reduce using rule 34 (expression_operation -> expression PLUS expression .)
    OR              reduce using rule 34 (expression_operation -> expression PLUS expression .)
    NEWLINE         reduce using rule 34 (expression_operation -> expression PLUS expression .)
    $end            reduce using rule 34 (expression_operation -> expression PLUS expression .)
    RPAREN          reduce using rule 34 (expression_operation -> expression PLUS expression .)
    START           reduce using rule 34 (expression_operation -> expression PLUS expression .)
    STOP            reduce using rule 34 (expression_operation -> expression PLUS expression .)
    RETURN          reduce using rule 34 (expression_operation -> expression PLUS expression .)
    MULTIPLY        shift and go to state 33
    DIVIDE          shift and go to state 34
    MODULO          shift and go to state 35

  ! MULTIPLY        [ reduce using rule 34 (expression_operation -> expression PLUS expression .) ]
  ! DIVIDE          [ reduce using rule 34 (expression_operation -> expression PLUS expression .) ]
  ! MODULO          [ reduce using rule 34 (expression_operation -> expression PLUS expression .) ]
  ! PLUS            [ shift and go to state 36 ]
  ! MINUS           [ shift and go to state 37 ]
  ! LD              [ shift and go to state 38 ]
  ! LDEQ            [ shift and go to state 39 ]
  ! GD              [ shift and go to state 40 ]
  ! GDEQ            [ shift and go to state 41 ]
  ! EQUALEQUAL      [ shift and go to state 42 ]
  ! NOTEQ           [ shift and go to state 43 ]
  ! AND             [ shift and go to state 44 ]
  ! OR              [ shift and go to state 45 ]


state 71

    (35) expression_operation -> expression MINUS expression .
    (31) expression_operation -> expression . MULTIPLY expression
    (32) expression_operation -> expression . DIVIDE expression
    (33) expression_operation -> expression . MODULO expression
    (34) expression_operation -> expression . PLUS expression
    (35) expression_operation -> expression . MINUS expression
    (36) expression_operation -> expression . LD expression
    (37) expression_operation -> expression . LDEQ expression
    (38) expression_operation -> expression . GD expression
    (39) expression_operation -> expression . GDEQ expression
    (40) expression_operation -> expression . EQUALEQUAL expression
    (41) expression_operation -> expression . NOTEQ expression
    (42) expression_operation -> expression . AND expression
    (43) expression_operation -> expression . OR expression

    PLUS            reduce using rule 35 (expression_operation -> expression MINUS expression .)
    MINUS           reduce using rule 35 (expression_operation -> expression MINUS expression .)
    LD              reduce using rule 35 (expression_operation -> expression MINUS expression .)
    LDEQ            reduce using rule 35 (expression_operation -> expression MINUS expression .)
    GD              reduce using rule 35 (expression_operation -> expression MINUS expression .)
    GDEQ            reduce using rule 35 (expression_operation -> expression MINUS expression .)
    EQUALEQUAL      reduce using rule 35 (expression_operation -> expression MINUS expression .)
    NOTEQ           reduce using rule 35 (expression_operation -> expression MINUS expression .)
    AND             reduce using rule 35 (expression_operation -> expression MINUS expression .)
    OR              reduce using rule 35 (expression_operation -> expression MINUS expression .)
    NEWLINE         reduce using rule 35 (expression_operation -> expression MINUS expression .)
    $end            reduce using rule 35 (expression_operation -> expression MINUS expression .)
    RPAREN          reduce using rule 35 (expression_operation -> expression MINUS expression .)
    START           reduce using rule 35 (expression_operation -> expression MINUS expression .)
    STOP            reduce using rule 35 (expression_operation -> expression MINUS expression .)
    RETURN          reduce using rule 35 (expression_operation -> expression MINUS expression .)
    MULTIPLY        shift and go to state 33
    DIVIDE          shift and go to state 34
    MODULO          shift and go to state 35

  ! MULTIPLY        [ reduce using rule 35 (expression_operation -> expression MINUS expression .) ]
  ! DIVIDE          [ reduce using rule 35 (expression_operation -> expression MINUS expression .) ]
  ! MODULO          [ reduce using rule 35 (expression_operation -> expression MINUS expression .) ]
  ! PLUS            [ shift and go to state 36 ]
  ! MINUS           [ shift and go to state 37 ]
  ! LD              [ shift and go to state 38 ]
  ! LDEQ            [ shift and go to state 39 ]
  ! GD              [ shift and go to state 40 ]
  ! GDEQ            [ shift and go to state 41 ]
  ! EQUALEQUAL      [ shift and go to state 42 ]
  ! NOTEQ           [ shift and go to state 43 ]
  ! AND             [ shift and go to state 44 ]
  ! OR              [ shift and go to state 45 ]


state 72

    (36) expression_operation -> expression LD expression .
    (31) expression_operation -> expression . MULTIPLY expression
    (32) expression_operation -> expression . DIVIDE expression
    (33) expression_operation -> expression . MODULO expression
    (34) expression_operation -> expression . PLUS expression
    (35) expression_operation -> expression . MINUS expression
    (36) expression_operation -> expression . LD expression
    (37) expression_operation -> expression . LDEQ expression
    (38) expression_operation -> expression . GD expression
    (39) expression_operation -> expression . GDEQ expression
    (40) expression_operation -> expression . EQUALEQUAL expression
    (41) expression_operation -> expression . NOTEQ expression
    (42) expression_operation -> expression . AND expression
    (43) expression_operation -> expression . OR expression

    LD              reduce using rule 36 (expression_operation -> expression LD expression .)
    LDEQ            reduce using rule 36 (expression_operation -> expression LD expression .)
    GD              reduce using rule 36 (expression_operation -> expression LD expression .)
    GDEQ            reduce using rule 36 (expression_operation -> expression LD expression .)
    EQUALEQUAL      reduce using rule 36 (expression_operation -> expression LD expression .)
    NOTEQ           reduce using rule 36 (expression_operation -> expression LD expression .)
    AND             reduce using rule 36 (expression_operation -> expression LD expression .)
    OR              reduce using rule 36 (expression_operation -> expression LD expression .)
    NEWLINE         reduce using rule 36 (expression_operation -> expression LD expression .)
    $end            reduce using rule 36 (expression_operation -> expression LD expression .)
    RPAREN          reduce using rule 36 (expression_operation -> expression LD expression .)
    START           reduce using rule 36 (expression_operation -> expression LD expression .)
    STOP            reduce using rule 36 (expression_operation -> expression LD expression .)
    RETURN          reduce using rule 36 (expression_operation -> expression LD expression .)
    MULTIPLY        shift and go to state 33
    DIVIDE          shift and go to state 34
    MODULO          shift and go to state 35
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37

  ! MULTIPLY        [ reduce using rule 36 (expression_operation -> expression LD expression .) ]
  ! DIVIDE          [ reduce using rule 36 (expression_operation -> expression LD expression .) ]
  ! MODULO          [ reduce using rule 36 (expression_operation -> expression LD expression .) ]
  ! PLUS            [ reduce using rule 36 (expression_operation -> expression LD expression .) ]
  ! MINUS           [ reduce using rule 36 (expression_operation -> expression LD expression .) ]
  ! LD              [ shift and go to state 38 ]
  ! LDEQ            [ shift and go to state 39 ]
  ! GD              [ shift and go to state 40 ]
  ! GDEQ            [ shift and go to state 41 ]
  ! EQUALEQUAL      [ shift and go to state 42 ]
  ! NOTEQ           [ shift and go to state 43 ]
  ! AND             [ shift and go to state 44 ]
  ! OR              [ shift and go to state 45 ]


state 73

    (37) expression_operation -> expression LDEQ expression .
    (31) expression_operation -> expression . MULTIPLY expression
    (32) expression_operation -> expression . DIVIDE expression
    (33) expression_operation -> expression . MODULO expression
    (34) expression_operation -> expression . PLUS expression
    (35) expression_operation -> expression . MINUS expression
    (36) expression_operation -> expression . LD expression
    (37) expression_operation -> expression . LDEQ expression
    (38) expression_operation -> expression . GD expression
    (39) expression_operation -> expression . GDEQ expression
    (40) expression_operation -> expression . EQUALEQUAL expression
    (41) expression_operation -> expression . NOTEQ expression
    (42) expression_operation -> expression . AND expression
    (43) expression_operation -> expression . OR expression

    LD              reduce using rule 37 (expression_operation -> expression LDEQ expression .)
    LDEQ            reduce using rule 37 (expression_operation -> expression LDEQ expression .)
    GD              reduce using rule 37 (expression_operation -> expression LDEQ expression .)
    GDEQ            reduce using rule 37 (expression_operation -> expression LDEQ expression .)
    EQUALEQUAL      reduce using rule 37 (expression_operation -> expression LDEQ expression .)
    NOTEQ           reduce using rule 37 (expression_operation -> expression LDEQ expression .)
    AND             reduce using rule 37 (expression_operation -> expression LDEQ expression .)
    OR              reduce using rule 37 (expression_operation -> expression LDEQ expression .)
    NEWLINE         reduce using rule 37 (expression_operation -> expression LDEQ expression .)
    $end            reduce using rule 37 (expression_operation -> expression LDEQ expression .)
    RPAREN          reduce using rule 37 (expression_operation -> expression LDEQ expression .)
    START           reduce using rule 37 (expression_operation -> expression LDEQ expression .)
    STOP            reduce using rule 37 (expression_operation -> expression LDEQ expression .)
    RETURN          reduce using rule 37 (expression_operation -> expression LDEQ expression .)
    MULTIPLY        shift and go to state 33
    DIVIDE          shift and go to state 34
    MODULO          shift and go to state 35
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37

  ! MULTIPLY        [ reduce using rule 37 (expression_operation -> expression LDEQ expression .) ]
  ! DIVIDE          [ reduce using rule 37 (expression_operation -> expression LDEQ expression .) ]
  ! MODULO          [ reduce using rule 37 (expression_operation -> expression LDEQ expression .) ]
  ! PLUS            [ reduce using rule 37 (expression_operation -> expression LDEQ expression .) ]
  ! MINUS           [ reduce using rule 37 (expression_operation -> expression LDEQ expression .) ]
  ! LD              [ shift and go to state 38 ]
  ! LDEQ            [ shift and go to state 39 ]
  ! GD              [ shift and go to state 40 ]
  ! GDEQ            [ shift and go to state 41 ]
  ! EQUALEQUAL      [ shift and go to state 42 ]
  ! NOTEQ           [ shift and go to state 43 ]
  ! AND             [ shift and go to state 44 ]
  ! OR              [ shift and go to state 45 ]


state 74

    (38) expression_operation -> expression GD expression .
    (31) expression_operation -> expression . MULTIPLY expression
    (32) expression_operation -> expression . DIVIDE expression
    (33) expression_operation -> expression . MODULO expression
    (34) expression_operation -> expression . PLUS expression
    (35) expression_operation -> expression . MINUS expression
    (36) expression_operation -> expression . LD expression
    (37) expression_operation -> expression . LDEQ expression
    (38) expression_operation -> expression . GD expression
    (39) expression_operation -> expression . GDEQ expression
    (40) expression_operation -> expression . EQUALEQUAL expression
    (41) expression_operation -> expression . NOTEQ expression
    (42) expression_operation -> expression . AND expression
    (43) expression_operation -> expression . OR expression

    LD              reduce using rule 38 (expression_operation -> expression GD expression .)
    LDEQ            reduce using rule 38 (expression_operation -> expression GD expression .)
    GD              reduce using rule 38 (expression_operation -> expression GD expression .)
    GDEQ            reduce using rule 38 (expression_operation -> expression GD expression .)
    EQUALEQUAL      reduce using rule 38 (expression_operation -> expression GD expression .)
    NOTEQ           reduce using rule 38 (expression_operation -> expression GD expression .)
    AND             reduce using rule 38 (expression_operation -> expression GD expression .)
    OR              reduce using rule 38 (expression_operation -> expression GD expression .)
    NEWLINE         reduce using rule 38 (expression_operation -> expression GD expression .)
    $end            reduce using rule 38 (expression_operation -> expression GD expression .)
    RPAREN          reduce using rule 38 (expression_operation -> expression GD expression .)
    START           reduce using rule 38 (expression_operation -> expression GD expression .)
    STOP            reduce using rule 38 (expression_operation -> expression GD expression .)
    RETURN          reduce using rule 38 (expression_operation -> expression GD expression .)
    MULTIPLY        shift and go to state 33
    DIVIDE          shift and go to state 34
    MODULO          shift and go to state 35
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37

  ! MULTIPLY        [ reduce using rule 38 (expression_operation -> expression GD expression .) ]
  ! DIVIDE          [ reduce using rule 38 (expression_operation -> expression GD expression .) ]
  ! MODULO          [ reduce using rule 38 (expression_operation -> expression GD expression .) ]
  ! PLUS            [ reduce using rule 38 (expression_operation -> expression GD expression .) ]
  ! MINUS           [ reduce using rule 38 (expression_operation -> expression GD expression .) ]
  ! LD              [ shift and go to state 38 ]
  ! LDEQ            [ shift and go to state 39 ]
  ! GD              [ shift and go to state 40 ]
  ! GDEQ            [ shift and go to state 41 ]
  ! EQUALEQUAL      [ shift and go to state 42 ]
  ! NOTEQ           [ shift and go to state 43 ]
  ! AND             [ shift and go to state 44 ]
  ! OR              [ shift and go to state 45 ]


state 75

    (39) expression_operation -> expression GDEQ expression .
    (31) expression_operation -> expression . MULTIPLY expression
    (32) expression_operation -> expression . DIVIDE expression
    (33) expression_operation -> expression . MODULO expression
    (34) expression_operation -> expression . PLUS expression
    (35) expression_operation -> expression . MINUS expression
    (36) expression_operation -> expression . LD expression
    (37) expression_operation -> expression . LDEQ expression
    (38) expression_operation -> expression . GD expression
    (39) expression_operation -> expression . GDEQ expression
    (40) expression_operation -> expression . EQUALEQUAL expression
    (41) expression_operation -> expression . NOTEQ expression
    (42) expression_operation -> expression . AND expression
    (43) expression_operation -> expression . OR expression

    LD              reduce using rule 39 (expression_operation -> expression GDEQ expression .)
    LDEQ            reduce using rule 39 (expression_operation -> expression GDEQ expression .)
    GD              reduce using rule 39 (expression_operation -> expression GDEQ expression .)
    GDEQ            reduce using rule 39 (expression_operation -> expression GDEQ expression .)
    EQUALEQUAL      reduce using rule 39 (expression_operation -> expression GDEQ expression .)
    NOTEQ           reduce using rule 39 (expression_operation -> expression GDEQ expression .)
    AND             reduce using rule 39 (expression_operation -> expression GDEQ expression .)
    OR              reduce using rule 39 (expression_operation -> expression GDEQ expression .)
    NEWLINE         reduce using rule 39 (expression_operation -> expression GDEQ expression .)
    $end            reduce using rule 39 (expression_operation -> expression GDEQ expression .)
    RPAREN          reduce using rule 39 (expression_operation -> expression GDEQ expression .)
    START           reduce using rule 39 (expression_operation -> expression GDEQ expression .)
    STOP            reduce using rule 39 (expression_operation -> expression GDEQ expression .)
    RETURN          reduce using rule 39 (expression_operation -> expression GDEQ expression .)
    MULTIPLY        shift and go to state 33
    DIVIDE          shift and go to state 34
    MODULO          shift and go to state 35
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37

  ! MULTIPLY        [ reduce using rule 39 (expression_operation -> expression GDEQ expression .) ]
  ! DIVIDE          [ reduce using rule 39 (expression_operation -> expression GDEQ expression .) ]
  ! MODULO          [ reduce using rule 39 (expression_operation -> expression GDEQ expression .) ]
  ! PLUS            [ reduce using rule 39 (expression_operation -> expression GDEQ expression .) ]
  ! MINUS           [ reduce using rule 39 (expression_operation -> expression GDEQ expression .) ]
  ! LD              [ shift and go to state 38 ]
  ! LDEQ            [ shift and go to state 39 ]
  ! GD              [ shift and go to state 40 ]
  ! GDEQ            [ shift and go to state 41 ]
  ! EQUALEQUAL      [ shift and go to state 42 ]
  ! NOTEQ           [ shift and go to state 43 ]
  ! AND             [ shift and go to state 44 ]
  ! OR              [ shift and go to state 45 ]


state 76

    (40) expression_operation -> expression EQUALEQUAL expression .
    (31) expression_operation -> expression . MULTIPLY expression
    (32) expression_operation -> expression . DIVIDE expression
    (33) expression_operation -> expression . MODULO expression
    (34) expression_operation -> expression . PLUS expression
    (35) expression_operation -> expression . MINUS expression
    (36) expression_operation -> expression . LD expression
    (37) expression_operation -> expression . LDEQ expression
    (38) expression_operation -> expression . GD expression
    (39) expression_operation -> expression . GDEQ expression
    (40) expression_operation -> expression . EQUALEQUAL expression
    (41) expression_operation -> expression . NOTEQ expression
    (42) expression_operation -> expression . AND expression
    (43) expression_operation -> expression . OR expression

    EQUALEQUAL      reduce using rule 40 (expression_operation -> expression EQUALEQUAL expression .)
    NOTEQ           reduce using rule 40 (expression_operation -> expression EQUALEQUAL expression .)
    AND             reduce using rule 40 (expression_operation -> expression EQUALEQUAL expression .)
    OR              reduce using rule 40 (expression_operation -> expression EQUALEQUAL expression .)
    NEWLINE         reduce using rule 40 (expression_operation -> expression EQUALEQUAL expression .)
    $end            reduce using rule 40 (expression_operation -> expression EQUALEQUAL expression .)
    RPAREN          reduce using rule 40 (expression_operation -> expression EQUALEQUAL expression .)
    START           reduce using rule 40 (expression_operation -> expression EQUALEQUAL expression .)
    STOP            reduce using rule 40 (expression_operation -> expression EQUALEQUAL expression .)
    RETURN          reduce using rule 40 (expression_operation -> expression EQUALEQUAL expression .)
    MULTIPLY        shift and go to state 33
    DIVIDE          shift and go to state 34
    MODULO          shift and go to state 35
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    LD              shift and go to state 38
    LDEQ            shift and go to state 39
    GD              shift and go to state 40
    GDEQ            shift and go to state 41

  ! MULTIPLY        [ reduce using rule 40 (expression_operation -> expression EQUALEQUAL expression .) ]
  ! DIVIDE          [ reduce using rule 40 (expression_operation -> expression EQUALEQUAL expression .) ]
  ! MODULO          [ reduce using rule 40 (expression_operation -> expression EQUALEQUAL expression .) ]
  ! PLUS            [ reduce using rule 40 (expression_operation -> expression EQUALEQUAL expression .) ]
  ! MINUS           [ reduce using rule 40 (expression_operation -> expression EQUALEQUAL expression .) ]
  ! LD              [ reduce using rule 40 (expression_operation -> expression EQUALEQUAL expression .) ]
  ! LDEQ            [ reduce using rule 40 (expression_operation -> expression EQUALEQUAL expression .) ]
  ! GD              [ reduce using rule 40 (expression_operation -> expression EQUALEQUAL expression .) ]
  ! GDEQ            [ reduce using rule 40 (expression_operation -> expression EQUALEQUAL expression .) ]
  ! EQUALEQUAL      [ shift and go to state 42 ]
  ! NOTEQ           [ shift and go to state 43 ]
  ! AND             [ shift and go to state 44 ]
  ! OR              [ shift and go to state 45 ]


state 77

    (41) expression_operation -> expression NOTEQ expression .
    (31) expression_operation -> expression . MULTIPLY expression
    (32) expression_operation -> expression . DIVIDE expression
    (33) expression_operation -> expression . MODULO expression
    (34) expression_operation -> expression . PLUS expression
    (35) expression_operation -> expression . MINUS expression
    (36) expression_operation -> expression . LD expression
    (37) expression_operation -> expression . LDEQ expression
    (38) expression_operation -> expression . GD expression
    (39) expression_operation -> expression . GDEQ expression
    (40) expression_operation -> expression . EQUALEQUAL expression
    (41) expression_operation -> expression . NOTEQ expression
    (42) expression_operation -> expression . AND expression
    (43) expression_operation -> expression . OR expression

    EQUALEQUAL      reduce using rule 41 (expression_operation -> expression NOTEQ expression .)
    NOTEQ           reduce using rule 41 (expression_operation -> expression NOTEQ expression .)
    AND             reduce using rule 41 (expression_operation -> expression NOTEQ expression .)
    OR              reduce using rule 41 (expression_operation -> expression NOTEQ expression .)
    NEWLINE         reduce using rule 41 (expression_operation -> expression NOTEQ expression .)
    $end            reduce using rule 41 (expression_operation -> expression NOTEQ expression .)
    RPAREN          reduce using rule 41 (expression_operation -> expression NOTEQ expression .)
    START           reduce using rule 41 (expression_operation -> expression NOTEQ expression .)
    STOP            reduce using rule 41 (expression_operation -> expression NOTEQ expression .)
    RETURN          reduce using rule 41 (expression_operation -> expression NOTEQ expression .)
    MULTIPLY        shift and go to state 33
    DIVIDE          shift and go to state 34
    MODULO          shift and go to state 35
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    LD              shift and go to state 38
    LDEQ            shift and go to state 39
    GD              shift and go to state 40
    GDEQ            shift and go to state 41

  ! MULTIPLY        [ reduce using rule 41 (expression_operation -> expression NOTEQ expression .) ]
  ! DIVIDE          [ reduce using rule 41 (expression_operation -> expression NOTEQ expression .) ]
  ! MODULO          [ reduce using rule 41 (expression_operation -> expression NOTEQ expression .) ]
  ! PLUS            [ reduce using rule 41 (expression_operation -> expression NOTEQ expression .) ]
  ! MINUS           [ reduce using rule 41 (expression_operation -> expression NOTEQ expression .) ]
  ! LD              [ reduce using rule 41 (expression_operation -> expression NOTEQ expression .) ]
  ! LDEQ            [ reduce using rule 41 (expression_operation -> expression NOTEQ expression .) ]
  ! GD              [ reduce using rule 41 (expression_operation -> expression NOTEQ expression .) ]
  ! GDEQ            [ reduce using rule 41 (expression_operation -> expression NOTEQ expression .) ]
  ! EQUALEQUAL      [ shift and go to state 42 ]
  ! NOTEQ           [ shift and go to state 43 ]
  ! AND             [ shift and go to state 44 ]
  ! OR              [ shift and go to state 45 ]


state 78

    (42) expression_operation -> expression AND expression .
    (31) expression_operation -> expression . MULTIPLY expression
    (32) expression_operation -> expression . DIVIDE expression
    (33) expression_operation -> expression . MODULO expression
    (34) expression_operation -> expression . PLUS expression
    (35) expression_operation -> expression . MINUS expression
    (36) expression_operation -> expression . LD expression
    (37) expression_operation -> expression . LDEQ expression
    (38) expression_operation -> expression . GD expression
    (39) expression_operation -> expression . GDEQ expression
    (40) expression_operation -> expression . EQUALEQUAL expression
    (41) expression_operation -> expression . NOTEQ expression
    (42) expression_operation -> expression . AND expression
    (43) expression_operation -> expression . OR expression

    AND             reduce using rule 42 (expression_operation -> expression AND expression .)
    OR              reduce using rule 42 (expression_operation -> expression AND expression .)
    NEWLINE         reduce using rule 42 (expression_operation -> expression AND expression .)
    $end            reduce using rule 42 (expression_operation -> expression AND expression .)
    RPAREN          reduce using rule 42 (expression_operation -> expression AND expression .)
    START           reduce using rule 42 (expression_operation -> expression AND expression .)
    STOP            reduce using rule 42 (expression_operation -> expression AND expression .)
    RETURN          reduce using rule 42 (expression_operation -> expression AND expression .)
    MULTIPLY        shift and go to state 33
    DIVIDE          shift and go to state 34
    MODULO          shift and go to state 35
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    LD              shift and go to state 38
    LDEQ            shift and go to state 39
    GD              shift and go to state 40
    GDEQ            shift and go to state 41
    EQUALEQUAL      shift and go to state 42
    NOTEQ           shift and go to state 43

  ! MULTIPLY        [ reduce using rule 42 (expression_operation -> expression AND expression .) ]
  ! DIVIDE          [ reduce using rule 42 (expression_operation -> expression AND expression .) ]
  ! MODULO          [ reduce using rule 42 (expression_operation -> expression AND expression .) ]
  ! PLUS            [ reduce using rule 42 (expression_operation -> expression AND expression .) ]
  ! MINUS           [ reduce using rule 42 (expression_operation -> expression AND expression .) ]
  ! LD              [ reduce using rule 42 (expression_operation -> expression AND expression .) ]
  ! LDEQ            [ reduce using rule 42 (expression_operation -> expression AND expression .) ]
  ! GD              [ reduce using rule 42 (expression_operation -> expression AND expression .) ]
  ! GDEQ            [ reduce using rule 42 (expression_operation -> expression AND expression .) ]
  ! EQUALEQUAL      [ reduce using rule 42 (expression_operation -> expression AND expression .) ]
  ! NOTEQ           [ reduce using rule 42 (expression_operation -> expression AND expression .) ]
  ! AND             [ shift and go to state 44 ]
  ! OR              [ shift and go to state 45 ]


state 79

    (43) expression_operation -> expression OR expression .
    (31) expression_operation -> expression . MULTIPLY expression
    (32) expression_operation -> expression . DIVIDE expression
    (33) expression_operation -> expression . MODULO expression
    (34) expression_operation -> expression . PLUS expression
    (35) expression_operation -> expression . MINUS expression
    (36) expression_operation -> expression . LD expression
    (37) expression_operation -> expression . LDEQ expression
    (38) expression_operation -> expression . GD expression
    (39) expression_operation -> expression . GDEQ expression
    (40) expression_operation -> expression . EQUALEQUAL expression
    (41) expression_operation -> expression . NOTEQ expression
    (42) expression_operation -> expression . AND expression
    (43) expression_operation -> expression . OR expression

    AND             reduce using rule 43 (expression_operation -> expression OR expression .)
    OR              reduce using rule 43 (expression_operation -> expression OR expression .)
    NEWLINE         reduce using rule 43 (expression_operation -> expression OR expression .)
    $end            reduce using rule 43 (expression_operation -> expression OR expression .)
    RPAREN          reduce using rule 43 (expression_operation -> expression OR expression .)
    START           reduce using rule 43 (expression_operation -> expression OR expression .)
    STOP            reduce using rule 43 (expression_operation -> expression OR expression .)
    RETURN          reduce using rule 43 (expression_operation -> expression OR expression .)
    MULTIPLY        shift and go to state 33
    DIVIDE          shift and go to state 34
    MODULO          shift and go to state 35
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    LD              shift and go to state 38
    LDEQ            shift and go to state 39
    GD              shift and go to state 40
    GDEQ            shift and go to state 41
    EQUALEQUAL      shift and go to state 42
    NOTEQ           shift and go to state 43

  ! MULTIPLY        [ reduce using rule 43 (expression_operation -> expression OR expression .) ]
  ! DIVIDE          [ reduce using rule 43 (expression_operation -> expression OR expression .) ]
  ! MODULO          [ reduce using rule 43 (expression_operation -> expression OR expression .) ]
  ! PLUS            [ reduce using rule 43 (expression_operation -> expression OR expression .) ]
  ! MINUS           [ reduce using rule 43 (expression_operation -> expression OR expression .) ]
  ! LD              [ reduce using rule 43 (expression_operation -> expression OR expression .) ]
  ! LDEQ            [ reduce using rule 43 (expression_operation -> expression OR expression .) ]
  ! GD              [ reduce using rule 43 (expression_operation -> expression OR expression .) ]
  ! GDEQ            [ reduce using rule 43 (expression_operation -> expression OR expression .) ]
  ! EQUALEQUAL      [ reduce using rule 43 (expression_operation -> expression OR expression .) ]
  ! NOTEQ           [ reduce using rule 43 (expression_operation -> expression OR expression .) ]
  ! AND             [ shift and go to state 44 ]
  ! OR              [ shift and go to state 45 ]


state 80

    (29) var_assign -> NAME EQUALS expression .
    (31) expression_operation -> expression . MULTIPLY expression
    (32) expression_operation -> expression . DIVIDE expression
    (33) expression_operation -> expression . MODULO expression
    (34) expression_operation -> expression . PLUS expression
    (35) expression_operation -> expression . MINUS expression
    (36) expression_operation -> expression . LD expression
    (37) expression_operation -> expression . LDEQ expression
    (38) expression_operation -> expression . GD expression
    (39) expression_operation -> expression . GDEQ expression
    (40) expression_operation -> expression . EQUALEQUAL expression
    (41) expression_operation -> expression . NOTEQ expression
    (42) expression_operation -> expression . AND expression
    (43) expression_operation -> expression . OR expression

    NEWLINE         reduce using rule 29 (var_assign -> NAME EQUALS expression .)
    $end            reduce using rule 29 (var_assign -> NAME EQUALS expression .)
    STOP            reduce using rule 29 (var_assign -> NAME EQUALS expression .)
    RETURN          reduce using rule 29 (var_assign -> NAME EQUALS expression .)
    MULTIPLY        shift and go to state 33
    DIVIDE          shift and go to state 34
    MODULO          shift and go to state 35
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    LD              shift and go to state 38
    LDEQ            shift and go to state 39
    GD              shift and go to state 40
    GDEQ            shift and go to state 41
    EQUALEQUAL      shift and go to state 42
    NOTEQ           shift and go to state 43
    AND             shift and go to state 44
    OR              shift and go to state 45


state 81

    (50) expression -> LBRACE int_type_array RBRACE .

    MULTIPLY        reduce using rule 50 (expression -> LBRACE int_type_array RBRACE .)
    DIVIDE          reduce using rule 50 (expression -> LBRACE int_type_array RBRACE .)
    MODULO          reduce using rule 50 (expression -> LBRACE int_type_array RBRACE .)
    PLUS            reduce using rule 50 (expression -> LBRACE int_type_array RBRACE .)
    MINUS           reduce using rule 50 (expression -> LBRACE int_type_array RBRACE .)
    LD              reduce using rule 50 (expression -> LBRACE int_type_array RBRACE .)
    LDEQ            reduce using rule 50 (expression -> LBRACE int_type_array RBRACE .)
    GD              reduce using rule 50 (expression -> LBRACE int_type_array RBRACE .)
    GDEQ            reduce using rule 50 (expression -> LBRACE int_type_array RBRACE .)
    EQUALEQUAL      reduce using rule 50 (expression -> LBRACE int_type_array RBRACE .)
    NOTEQ           reduce using rule 50 (expression -> LBRACE int_type_array RBRACE .)
    AND             reduce using rule 50 (expression -> LBRACE int_type_array RBRACE .)
    OR              reduce using rule 50 (expression -> LBRACE int_type_array RBRACE .)
    NEWLINE         reduce using rule 50 (expression -> LBRACE int_type_array RBRACE .)
    $end            reduce using rule 50 (expression -> LBRACE int_type_array RBRACE .)
    RPAREN          reduce using rule 50 (expression -> LBRACE int_type_array RBRACE .)
    START           reduce using rule 50 (expression -> LBRACE int_type_array RBRACE .)
    STOP            reduce using rule 50 (expression -> LBRACE int_type_array RBRACE .)
    RETURN          reduce using rule 50 (expression -> LBRACE int_type_array RBRACE .)


state 82

    (51) expression -> LBRACE float_type_array RBRACE .

    MULTIPLY        reduce using rule 51 (expression -> LBRACE float_type_array RBRACE .)
    DIVIDE          reduce using rule 51 (expression -> LBRACE float_type_array RBRACE .)
    MODULO          reduce using rule 51 (expression -> LBRACE float_type_array RBRACE .)
    PLUS            reduce using rule 51 (expression -> LBRACE float_type_array RBRACE .)
    MINUS           reduce using rule 51 (expression -> LBRACE float_type_array RBRACE .)
    LD              reduce using rule 51 (expression -> LBRACE float_type_array RBRACE .)
    LDEQ            reduce using rule 51 (expression -> LBRACE float_type_array RBRACE .)
    GD              reduce using rule 51 (expression -> LBRACE float_type_array RBRACE .)
    GDEQ            reduce using rule 51 (expression -> LBRACE float_type_array RBRACE .)
    EQUALEQUAL      reduce using rule 51 (expression -> LBRACE float_type_array RBRACE .)
    NOTEQ           reduce using rule 51 (expression -> LBRACE float_type_array RBRACE .)
    AND             reduce using rule 51 (expression -> LBRACE float_type_array RBRACE .)
    OR              reduce using rule 51 (expression -> LBRACE float_type_array RBRACE .)
    NEWLINE         reduce using rule 51 (expression -> LBRACE float_type_array RBRACE .)
    $end            reduce using rule 51 (expression -> LBRACE float_type_array RBRACE .)
    RPAREN          reduce using rule 51 (expression -> LBRACE float_type_array RBRACE .)
    START           reduce using rule 51 (expression -> LBRACE float_type_array RBRACE .)
    STOP            reduce using rule 51 (expression -> LBRACE float_type_array RBRACE .)
    RETURN          reduce using rule 51 (expression -> LBRACE float_type_array RBRACE .)


state 83

    (52) expression -> LBRACE string_type_array RBRACE .

    MULTIPLY        reduce using rule 52 (expression -> LBRACE string_type_array RBRACE .)
    DIVIDE          reduce using rule 52 (expression -> LBRACE string_type_array RBRACE .)
    MODULO          reduce using rule 52 (expression -> LBRACE string_type_array RBRACE .)
    PLUS            reduce using rule 52 (expression -> LBRACE string_type_array RBRACE .)
    MINUS           reduce using rule 52 (expression -> LBRACE string_type_array RBRACE .)
    LD              reduce using rule 52 (expression -> LBRACE string_type_array RBRACE .)
    LDEQ            reduce using rule 52 (expression -> LBRACE string_type_array RBRACE .)
    GD              reduce using rule 52 (expression -> LBRACE string_type_array RBRACE .)
    GDEQ            reduce using rule 52 (expression -> LBRACE string_type_array RBRACE .)
    EQUALEQUAL      reduce using rule 52 (expression -> LBRACE string_type_array RBRACE .)
    NOTEQ           reduce using rule 52 (expression -> LBRACE string_type_array RBRACE .)
    AND             reduce using rule 52 (expression -> LBRACE string_type_array RBRACE .)
    OR              reduce using rule 52 (expression -> LBRACE string_type_array RBRACE .)
    NEWLINE         reduce using rule 52 (expression -> LBRACE string_type_array RBRACE .)
    $end            reduce using rule 52 (expression -> LBRACE string_type_array RBRACE .)
    RPAREN          reduce using rule 52 (expression -> LBRACE string_type_array RBRACE .)
    START           reduce using rule 52 (expression -> LBRACE string_type_array RBRACE .)
    STOP            reduce using rule 52 (expression -> LBRACE string_type_array RBRACE .)
    RETURN          reduce using rule 52 (expression -> LBRACE string_type_array RBRACE .)


state 84

    (53) expression -> LBRACE bool_type_array RBRACE .

    MULTIPLY        reduce using rule 53 (expression -> LBRACE bool_type_array RBRACE .)
    DIVIDE          reduce using rule 53 (expression -> LBRACE bool_type_array RBRACE .)
    MODULO          reduce using rule 53 (expression -> LBRACE bool_type_array RBRACE .)
    PLUS            reduce using rule 53 (expression -> LBRACE bool_type_array RBRACE .)
    MINUS           reduce using rule 53 (expression -> LBRACE bool_type_array RBRACE .)
    LD              reduce using rule 53 (expression -> LBRACE bool_type_array RBRACE .)
    LDEQ            reduce using rule 53 (expression -> LBRACE bool_type_array RBRACE .)
    GD              reduce using rule 53 (expression -> LBRACE bool_type_array RBRACE .)
    GDEQ            reduce using rule 53 (expression -> LBRACE bool_type_array RBRACE .)
    EQUALEQUAL      reduce using rule 53 (expression -> LBRACE bool_type_array RBRACE .)
    NOTEQ           reduce using rule 53 (expression -> LBRACE bool_type_array RBRACE .)
    AND             reduce using rule 53 (expression -> LBRACE bool_type_array RBRACE .)
    OR              reduce using rule 53 (expression -> LBRACE bool_type_array RBRACE .)
    NEWLINE         reduce using rule 53 (expression -> LBRACE bool_type_array RBRACE .)
    $end            reduce using rule 53 (expression -> LBRACE bool_type_array RBRACE .)
    RPAREN          reduce using rule 53 (expression -> LBRACE bool_type_array RBRACE .)
    START           reduce using rule 53 (expression -> LBRACE bool_type_array RBRACE .)
    STOP            reduce using rule 53 (expression -> LBRACE bool_type_array RBRACE .)
    RETURN          reduce using rule 53 (expression -> LBRACE bool_type_array RBRACE .)


state 85

    (55) int_type_array -> INT int_type_array .

    RBRACE          reduce using rule 55 (int_type_array -> INT int_type_array .)


state 86

    (54) int_type_array -> empty .

    RBRACE          reduce using rule 54 (int_type_array -> empty .)


state 87

    (57) float_type_array -> FLOAT float_type_array .

    RBRACE          reduce using rule 57 (float_type_array -> FLOAT float_type_array .)


state 88

    (56) float_type_array -> empty .

    RBRACE          reduce using rule 56 (float_type_array -> empty .)


state 89

    (59) string_type_array -> STRING string_type_array .

    RBRACE          reduce using rule 59 (string_type_array -> STRING string_type_array .)


state 90

    (58) string_type_array -> empty .

    RBRACE          reduce using rule 58 (string_type_array -> empty .)


state 91

    (61) bool_type_array -> TRUE bool_type_array .

    RBRACE          reduce using rule 61 (bool_type_array -> TRUE bool_type_array .)


state 92

    (60) bool_type_array -> empty .

    RBRACE          reduce using rule 60 (bool_type_array -> empty .)


state 93

    (62) bool_type_array -> FALSE bool_type_array .

    RBRACE          reduce using rule 62 (bool_type_array -> FALSE bool_type_array .)


state 94

    (63) expression -> LPAREN expression RPAREN .

    MULTIPLY        reduce using rule 63 (expression -> LPAREN expression RPAREN .)
    DIVIDE          reduce using rule 63 (expression -> LPAREN expression RPAREN .)
    MODULO          reduce using rule 63 (expression -> LPAREN expression RPAREN .)
    PLUS            reduce using rule 63 (expression -> LPAREN expression RPAREN .)
    MINUS           reduce using rule 63 (expression -> LPAREN expression RPAREN .)
    LD              reduce using rule 63 (expression -> LPAREN expression RPAREN .)
    LDEQ            reduce using rule 63 (expression -> LPAREN expression RPAREN .)
    GD              reduce using rule 63 (expression -> LPAREN expression RPAREN .)
    GDEQ            reduce using rule 63 (expression -> LPAREN expression RPAREN .)
    EQUALEQUAL      reduce using rule 63 (expression -> LPAREN expression RPAREN .)
    NOTEQ           reduce using rule 63 (expression -> LPAREN expression RPAREN .)
    AND             reduce using rule 63 (expression -> LPAREN expression RPAREN .)
    OR              reduce using rule 63 (expression -> LPAREN expression RPAREN .)
    NEWLINE         reduce using rule 63 (expression -> LPAREN expression RPAREN .)
    $end            reduce using rule 63 (expression -> LPAREN expression RPAREN .)
    RPAREN          reduce using rule 63 (expression -> LPAREN expression RPAREN .)
    START           reduce using rule 63 (expression -> LPAREN expression RPAREN .)
    STOP            reduce using rule 63 (expression -> LPAREN expression RPAREN .)
    RETURN          reduce using rule 63 (expression -> LPAREN expression RPAREN .)


state 95

    (13) func_assign -> datatype NAME LPAREN . parameters RPAREN START NEWLINE language return_stmt STOP
    (17) parameters -> . first_param
    (18) parameters -> . empty
    (19) first_param -> . datatype NAME COMMA first_param
    (20) first_param -> . datatype NAME
    (71) empty -> .
    (21) datatype -> . INT_TYPE
    (22) datatype -> . FLOAT_TYPE
    (23) datatype -> . STRING_TYPE
    (24) datatype -> . VOID_TYPE

    RPAREN          reduce using rule 71 (empty -> .)
    INT_TYPE        shift and go to state 27
    FLOAT_TYPE      shift and go to state 28
    STRING_TYPE     shift and go to state 29
    VOID_TYPE       shift and go to state 30

    datatype                       shift and go to state 100
    parameters                     shift and go to state 101
    first_param                    shift and go to state 102
    empty                          shift and go to state 103

state 96

    (70) iterative -> WHILE expression START . NEWLINE language STOP

    NEWLINE         shift and go to state 104


state 97

    (64) conditional -> IF expression START . NEWLINE language STOP else_if_blocks else_block

    NEWLINE         shift and go to state 105


state 98

    (25) input -> READ LPAREN NAME . RPAREN

    RPAREN          shift and go to state 106


state 99

    (27) output_print -> PRINT LPAREN expression . RPAREN
    (31) expression_operation -> expression . MULTIPLY expression
    (32) expression_operation -> expression . DIVIDE expression
    (33) expression_operation -> expression . MODULO expression
    (34) expression_operation -> expression . PLUS expression
    (35) expression_operation -> expression . MINUS expression
    (36) expression_operation -> expression . LD expression
    (37) expression_operation -> expression . LDEQ expression
    (38) expression_operation -> expression . GD expression
    (39) expression_operation -> expression . GDEQ expression
    (40) expression_operation -> expression . EQUALEQUAL expression
    (41) expression_operation -> expression . NOTEQ expression
    (42) expression_operation -> expression . AND expression
    (43) expression_operation -> expression . OR expression

    RPAREN          shift and go to state 107
    MULTIPLY        shift and go to state 33
    DIVIDE          shift and go to state 34
    MODULO          shift and go to state 35
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    LD              shift and go to state 38
    LDEQ            shift and go to state 39
    GD              shift and go to state 40
    GDEQ            shift and go to state 41
    EQUALEQUAL      shift and go to state 42
    NOTEQ           shift and go to state 43
    AND             shift and go to state 44
    OR              shift and go to state 45


state 100

    (19) first_param -> datatype . NAME COMMA first_param
    (20) first_param -> datatype . NAME

    NAME            shift and go to state 108


state 101

    (13) func_assign -> datatype NAME LPAREN parameters . RPAREN START NEWLINE language return_stmt STOP

    RPAREN          shift and go to state 109


state 102

    (17) parameters -> first_param .

    RPAREN          reduce using rule 17 (parameters -> first_param .)


state 103

    (18) parameters -> empty .

    RPAREN          reduce using rule 18 (parameters -> empty .)


state 104

    (70) iterative -> WHILE expression START NEWLINE . language STOP
    (3) language -> . language NEWLINE line
    (4) language -> . line
    (5) line -> . expression
    (6) line -> . var_assign
    (7) line -> . func_assign
    (8) line -> . iterative
    (9) line -> . conditional
    (10) line -> . output
    (11) line -> . input
    (12) line -> . empty
    (28) expression -> . NAME
    (30) expression -> . expression_operation
    (45) expression -> . INT
    (46) expression -> . FLOAT
    (47) expression -> . STRING
    (48) expression -> . TRUE
    (49) expression -> . FALSE
    (50) expression -> . LBRACE int_type_array RBRACE
    (51) expression -> . LBRACE float_type_array RBRACE
    (52) expression -> . LBRACE string_type_array RBRACE
    (53) expression -> . LBRACE bool_type_array RBRACE
    (63) expression -> . LPAREN expression RPAREN
    (29) var_assign -> . NAME EQUALS expression
    (13) func_assign -> . datatype NAME LPAREN parameters RPAREN START NEWLINE language return_stmt STOP
    (70) iterative -> . WHILE expression START NEWLINE language STOP
    (64) conditional -> . IF expression START NEWLINE language STOP else_if_blocks else_block
    (26) output -> . output_print
    (25) input -> . READ LPAREN NAME RPAREN
    (71) empty -> .
    (31) expression_operation -> . expression MULTIPLY expression
    (32) expression_operation -> . expression DIVIDE expression
    (33) expression_operation -> . expression MODULO expression
    (34) expression_operation -> . expression PLUS expression
    (35) expression_operation -> . expression MINUS expression
    (36) expression_operation -> . expression LD expression
    (37) expression_operation -> . expression LDEQ expression
    (38) expression_operation -> . expression GD expression
    (39) expression_operation -> . expression GDEQ expression
    (40) expression_operation -> . expression EQUALEQUAL expression
    (41) expression_operation -> . expression NOTEQ expression
    (42) expression_operation -> . expression AND expression
    (43) expression_operation -> . expression OR expression
    (44) expression_operation -> . NOT expression
    (21) datatype -> . INT_TYPE
    (22) datatype -> . FLOAT_TYPE
    (23) datatype -> . STRING_TYPE
    (24) datatype -> . VOID_TYPE
    (27) output_print -> . PRINT LPAREN expression RPAREN

    NAME            shift and go to state 12
    INT             shift and go to state 14
    FLOAT           shift and go to state 15
    STRING          shift and go to state 16
    TRUE            shift and go to state 17
    FALSE           shift and go to state 18
    LBRACE          shift and go to state 19
    LPAREN          shift and go to state 20
    WHILE           shift and go to state 22
    IF              shift and go to state 23
    READ            shift and go to state 25
    STOP            reduce using rule 71 (empty -> .)
    NEWLINE         reduce using rule 71 (empty -> .)
    NOT             shift and go to state 26
    INT_TYPE        shift and go to state 27
    FLOAT_TYPE      shift and go to state 28
    STRING_TYPE     shift and go to state 29
    VOID_TYPE       shift and go to state 30
    PRINT           shift and go to state 31

    expression                     shift and go to state 5
    language                       shift and go to state 110
    line                           shift and go to state 4
    var_assign                     shift and go to state 6
    func_assign                    shift and go to state 7
    iterative                      shift and go to state 8
    conditional                    shift and go to state 9
    output                         shift and go to state 10
    input                          shift and go to state 11
    empty                          shift and go to state 66
    expression_operation           shift and go to state 13
    datatype                       shift and go to state 21
    output_print                   shift and go to state 24

state 105

    (64) conditional -> IF expression START NEWLINE . language STOP else_if_blocks else_block
    (3) language -> . language NEWLINE line
    (4) language -> . line
    (5) line -> . expression
    (6) line -> . var_assign
    (7) line -> . func_assign
    (8) line -> . iterative
    (9) line -> . conditional
    (10) line -> . output
    (11) line -> . input
    (12) line -> . empty
    (28) expression -> . NAME
    (30) expression -> . expression_operation
    (45) expression -> . INT
    (46) expression -> . FLOAT
    (47) expression -> . STRING
    (48) expression -> . TRUE
    (49) expression -> . FALSE
    (50) expression -> . LBRACE int_type_array RBRACE
    (51) expression -> . LBRACE float_type_array RBRACE
    (52) expression -> . LBRACE string_type_array RBRACE
    (53) expression -> . LBRACE bool_type_array RBRACE
    (63) expression -> . LPAREN expression RPAREN
    (29) var_assign -> . NAME EQUALS expression
    (13) func_assign -> . datatype NAME LPAREN parameters RPAREN START NEWLINE language return_stmt STOP
    (70) iterative -> . WHILE expression START NEWLINE language STOP
    (64) conditional -> . IF expression START NEWLINE language STOP else_if_blocks else_block
    (26) output -> . output_print
    (25) input -> . READ LPAREN NAME RPAREN
    (71) empty -> .
    (31) expression_operation -> . expression MULTIPLY expression
    (32) expression_operation -> . expression DIVIDE expression
    (33) expression_operation -> . expression MODULO expression
    (34) expression_operation -> . expression PLUS expression
    (35) expression_operation -> . expression MINUS expression
    (36) expression_operation -> . expression LD expression
    (37) expression_operation -> . expression LDEQ expression
    (38) expression_operation -> . expression GD expression
    (39) expression_operation -> . expression GDEQ expression
    (40) expression_operation -> . expression EQUALEQUAL expression
    (41) expression_operation -> . expression NOTEQ expression
    (42) expression_operation -> . expression AND expression
    (43) expression_operation -> . expression OR expression
    (44) expression_operation -> . NOT expression
    (21) datatype -> . INT_TYPE
    (22) datatype -> . FLOAT_TYPE
    (23) datatype -> . STRING_TYPE
    (24) datatype -> . VOID_TYPE
    (27) output_print -> . PRINT LPAREN expression RPAREN

    NAME            shift and go to state 12
    INT             shift and go to state 14
    FLOAT           shift and go to state 15
    STRING          shift and go to state 16
    TRUE            shift and go to state 17
    FALSE           shift and go to state 18
    LBRACE          shift and go to state 19
    LPAREN          shift and go to state 20
    WHILE           shift and go to state 22
    IF              shift and go to state 23
    READ            shift and go to state 25
    STOP            reduce using rule 71 (empty -> .)
    NEWLINE         reduce using rule 71 (empty -> .)
    NOT             shift and go to state 26
    INT_TYPE        shift and go to state 27
    FLOAT_TYPE      shift and go to state 28
    STRING_TYPE     shift and go to state 29
    VOID_TYPE       shift and go to state 30
    PRINT           shift and go to state 31

    expression                     shift and go to state 5
    language                       shift and go to state 111
    line                           shift and go to state 4
    var_assign                     shift and go to state 6
    func_assign                    shift and go to state 7
    iterative                      shift and go to state 8
    conditional                    shift and go to state 9
    output                         shift and go to state 10
    input                          shift and go to state 11
    empty                          shift and go to state 66
    expression_operation           shift and go to state 13
    datatype                       shift and go to state 21
    output_print                   shift and go to state 24

state 106

    (25) input -> READ LPAREN NAME RPAREN .

    NEWLINE         reduce using rule 25 (input -> READ LPAREN NAME RPAREN .)
    $end            reduce using rule 25 (input -> READ LPAREN NAME RPAREN .)
    STOP            reduce using rule 25 (input -> READ LPAREN NAME RPAREN .)
    RETURN          reduce using rule 25 (input -> READ LPAREN NAME RPAREN .)


state 107

    (27) output_print -> PRINT LPAREN expression RPAREN .

    NEWLINE         reduce using rule 27 (output_print -> PRINT LPAREN expression RPAREN .)
    $end            reduce using rule 27 (output_print -> PRINT LPAREN expression RPAREN .)
    STOP            reduce using rule 27 (output_print -> PRINT LPAREN expression RPAREN .)
    RETURN          reduce using rule 27 (output_print -> PRINT LPAREN expression RPAREN .)


state 108

    (19) first_param -> datatype NAME . COMMA first_param
    (20) first_param -> datatype NAME .

    COMMA           shift and go to state 112
    RPAREN          reduce using rule 20 (first_param -> datatype NAME .)


state 109

    (13) func_assign -> datatype NAME LPAREN parameters RPAREN . START NEWLINE language return_stmt STOP

    START           shift and go to state 113


state 110

    (70) iterative -> WHILE expression START NEWLINE language . STOP
    (3) language -> language . NEWLINE line

    STOP            shift and go to state 114
    NEWLINE         shift and go to state 32


state 111

    (64) conditional -> IF expression START NEWLINE language . STOP else_if_blocks else_block
    (3) language -> language . NEWLINE line

    STOP            shift and go to state 115
    NEWLINE         shift and go to state 32


state 112

    (19) first_param -> datatype NAME COMMA . first_param
    (19) first_param -> . datatype NAME COMMA first_param
    (20) first_param -> . datatype NAME
    (21) datatype -> . INT_TYPE
    (22) datatype -> . FLOAT_TYPE
    (23) datatype -> . STRING_TYPE
    (24) datatype -> . VOID_TYPE

    INT_TYPE        shift and go to state 27
    FLOAT_TYPE      shift and go to state 28
    STRING_TYPE     shift and go to state 29
    VOID_TYPE       shift and go to state 30

    datatype                       shift and go to state 100
    first_param                    shift and go to state 116

state 113

    (13) func_assign -> datatype NAME LPAREN parameters RPAREN START . NEWLINE language return_stmt STOP

    NEWLINE         shift and go to state 117


state 114

    (70) iterative -> WHILE expression START NEWLINE language STOP .

    NEWLINE         reduce using rule 70 (iterative -> WHILE expression START NEWLINE language STOP .)
    $end            reduce using rule 70 (iterative -> WHILE expression START NEWLINE language STOP .)
    STOP            reduce using rule 70 (iterative -> WHILE expression START NEWLINE language STOP .)
    RETURN          reduce using rule 70 (iterative -> WHILE expression START NEWLINE language STOP .)


state 115

    (64) conditional -> IF expression START NEWLINE language STOP . else_if_blocks else_block
    (65) else_if_blocks -> . empty
    (66) else_if_blocks -> . else_if_blocks else_if_block
    (71) empty -> .

    ELSE            reduce using rule 71 (empty -> .)
    ELSE_IF         reduce using rule 71 (empty -> .)
    NEWLINE         reduce using rule 71 (empty -> .)
    $end            reduce using rule 71 (empty -> .)
    STOP            reduce using rule 71 (empty -> .)
    RETURN          reduce using rule 71 (empty -> .)

    else_if_blocks                 shift and go to state 118
    empty                          shift and go to state 119

state 116

    (19) first_param -> datatype NAME COMMA first_param .

    RPAREN          reduce using rule 19 (first_param -> datatype NAME COMMA first_param .)


state 117

    (13) func_assign -> datatype NAME LPAREN parameters RPAREN START NEWLINE . language return_stmt STOP
    (3) language -> . language NEWLINE line
    (4) language -> . line
    (5) line -> . expression
    (6) line -> . var_assign
    (7) line -> . func_assign
    (8) line -> . iterative
    (9) line -> . conditional
    (10) line -> . output
    (11) line -> . input
    (12) line -> . empty
    (28) expression -> . NAME
    (30) expression -> . expression_operation
    (45) expression -> . INT
    (46) expression -> . FLOAT
    (47) expression -> . STRING
    (48) expression -> . TRUE
    (49) expression -> . FALSE
    (50) expression -> . LBRACE int_type_array RBRACE
    (51) expression -> . LBRACE float_type_array RBRACE
    (52) expression -> . LBRACE string_type_array RBRACE
    (53) expression -> . LBRACE bool_type_array RBRACE
    (63) expression -> . LPAREN expression RPAREN
    (29) var_assign -> . NAME EQUALS expression
    (13) func_assign -> . datatype NAME LPAREN parameters RPAREN START NEWLINE language return_stmt STOP
    (70) iterative -> . WHILE expression START NEWLINE language STOP
    (64) conditional -> . IF expression START NEWLINE language STOP else_if_blocks else_block
    (26) output -> . output_print
    (25) input -> . READ LPAREN NAME RPAREN
    (71) empty -> .
    (31) expression_operation -> . expression MULTIPLY expression
    (32) expression_operation -> . expression DIVIDE expression
    (33) expression_operation -> . expression MODULO expression
    (34) expression_operation -> . expression PLUS expression
    (35) expression_operation -> . expression MINUS expression
    (36) expression_operation -> . expression LD expression
    (37) expression_operation -> . expression LDEQ expression
    (38) expression_operation -> . expression GD expression
    (39) expression_operation -> . expression GDEQ expression
    (40) expression_operation -> . expression EQUALEQUAL expression
    (41) expression_operation -> . expression NOTEQ expression
    (42) expression_operation -> . expression AND expression
    (43) expression_operation -> . expression OR expression
    (44) expression_operation -> . NOT expression
    (21) datatype -> . INT_TYPE
    (22) datatype -> . FLOAT_TYPE
    (23) datatype -> . STRING_TYPE
    (24) datatype -> . VOID_TYPE
    (27) output_print -> . PRINT LPAREN expression RPAREN

    NAME            shift and go to state 12
    INT             shift and go to state 14
    FLOAT           shift and go to state 15
    STRING          shift and go to state 16
    TRUE            shift and go to state 17
    FALSE           shift and go to state 18
    LBRACE          shift and go to state 19
    LPAREN          shift and go to state 20
    WHILE           shift and go to state 22
    IF              shift and go to state 23
    READ            shift and go to state 25
    NEWLINE         reduce using rule 71 (empty -> .)
    RETURN          reduce using rule 71 (empty -> .)
    STOP            reduce using rule 71 (empty -> .)
    NOT             shift and go to state 26
    INT_TYPE        shift and go to state 27
    FLOAT_TYPE      shift and go to state 28
    STRING_TYPE     shift and go to state 29
    VOID_TYPE       shift and go to state 30
    PRINT           shift and go to state 31

    datatype                       shift and go to state 21
    language                       shift and go to state 120
    line                           shift and go to state 4
    expression                     shift and go to state 5
    var_assign                     shift and go to state 6
    func_assign                    shift and go to state 7
    iterative                      shift and go to state 8
    conditional                    shift and go to state 9
    output                         shift and go to state 10
    input                          shift and go to state 11
    empty                          shift and go to state 66
    expression_operation           shift and go to state 13
    output_print                   shift and go to state 24

state 118

    (64) conditional -> IF expression START NEWLINE language STOP else_if_blocks . else_block
    (66) else_if_blocks -> else_if_blocks . else_if_block
    (68) else_block -> . ELSE START NEWLINE language STOP
    (69) else_block -> . empty
    (67) else_if_block -> . ELSE_IF expression START NEWLINE language STOP
    (71) empty -> .

    ELSE            shift and go to state 123
    ELSE_IF         shift and go to state 125
    NEWLINE         reduce using rule 71 (empty -> .)
    $end            reduce using rule 71 (empty -> .)
    STOP            reduce using rule 71 (empty -> .)
    RETURN          reduce using rule 71 (empty -> .)

    else_block                     shift and go to state 121
    else_if_block                  shift and go to state 122
    empty                          shift and go to state 124

state 119

    (65) else_if_blocks -> empty .

    ELSE            reduce using rule 65 (else_if_blocks -> empty .)
    ELSE_IF         reduce using rule 65 (else_if_blocks -> empty .)
    NEWLINE         reduce using rule 65 (else_if_blocks -> empty .)
    $end            reduce using rule 65 (else_if_blocks -> empty .)
    STOP            reduce using rule 65 (else_if_blocks -> empty .)
    RETURN          reduce using rule 65 (else_if_blocks -> empty .)


state 120

    (13) func_assign -> datatype NAME LPAREN parameters RPAREN START NEWLINE language . return_stmt STOP
    (3) language -> language . NEWLINE line
    (14) return_stmt -> . RETURN expression NEWLINE
    (15) return_stmt -> . RETURN NEWLINE
    (16) return_stmt -> . empty
    (71) empty -> .

    NEWLINE         shift and go to state 32
    RETURN          shift and go to state 127
    STOP            reduce using rule 71 (empty -> .)

    return_stmt                    shift and go to state 126
    empty                          shift and go to state 128

state 121

    (64) conditional -> IF expression START NEWLINE language STOP else_if_blocks else_block .

    NEWLINE         reduce using rule 64 (conditional -> IF expression START NEWLINE language STOP else_if_blocks else_block .)
    $end            reduce using rule 64 (conditional -> IF expression START NEWLINE language STOP else_if_blocks else_block .)
    STOP            reduce using rule 64 (conditional -> IF expression START NEWLINE language STOP else_if_blocks else_block .)
    RETURN          reduce using rule 64 (conditional -> IF expression START NEWLINE language STOP else_if_blocks else_block .)


state 122

    (66) else_if_blocks -> else_if_blocks else_if_block .

    ELSE            reduce using rule 66 (else_if_blocks -> else_if_blocks else_if_block .)
    ELSE_IF         reduce using rule 66 (else_if_blocks -> else_if_blocks else_if_block .)
    NEWLINE         reduce using rule 66 (else_if_blocks -> else_if_blocks else_if_block .)
    $end            reduce using rule 66 (else_if_blocks -> else_if_blocks else_if_block .)
    STOP            reduce using rule 66 (else_if_blocks -> else_if_blocks else_if_block .)
    RETURN          reduce using rule 66 (else_if_blocks -> else_if_blocks else_if_block .)


state 123

    (68) else_block -> ELSE . START NEWLINE language STOP

    START           shift and go to state 129


state 124

    (69) else_block -> empty .

    NEWLINE         reduce using rule 69 (else_block -> empty .)
    $end            reduce using rule 69 (else_block -> empty .)
    STOP            reduce using rule 69 (else_block -> empty .)
    RETURN          reduce using rule 69 (else_block -> empty .)


state 125

    (67) else_if_block -> ELSE_IF . expression START NEWLINE language STOP
    (28) expression -> . NAME
    (30) expression -> . expression_operation
    (45) expression -> . INT
    (46) expression -> . FLOAT
    (47) expression -> . STRING
    (48) expression -> . TRUE
    (49) expression -> . FALSE
    (50) expression -> . LBRACE int_type_array RBRACE
    (51) expression -> . LBRACE float_type_array RBRACE
    (52) expression -> . LBRACE string_type_array RBRACE
    (53) expression -> . LBRACE bool_type_array RBRACE
    (63) expression -> . LPAREN expression RPAREN
    (31) expression_operation -> . expression MULTIPLY expression
    (32) expression_operation -> . expression DIVIDE expression
    (33) expression_operation -> . expression MODULO expression
    (34) expression_operation -> . expression PLUS expression
    (35) expression_operation -> . expression MINUS expression
    (36) expression_operation -> . expression LD expression
    (37) expression_operation -> . expression LDEQ expression
    (38) expression_operation -> . expression GD expression
    (39) expression_operation -> . expression GDEQ expression
    (40) expression_operation -> . expression EQUALEQUAL expression
    (41) expression_operation -> . expression NOTEQ expression
    (42) expression_operation -> . expression AND expression
    (43) expression_operation -> . expression OR expression
    (44) expression_operation -> . NOT expression

    NAME            shift and go to state 58
    INT             shift and go to state 14
    FLOAT           shift and go to state 15
    STRING          shift and go to state 16
    TRUE            shift and go to state 17
    FALSE           shift and go to state 18
    LBRACE          shift and go to state 19
    LPAREN          shift and go to state 20
    NOT             shift and go to state 26

    expression                     shift and go to state 130
    expression_operation           shift and go to state 13

state 126

    (13) func_assign -> datatype NAME LPAREN parameters RPAREN START NEWLINE language return_stmt . STOP

    STOP            shift and go to state 131


state 127

    (14) return_stmt -> RETURN . expression NEWLINE
    (15) return_stmt -> RETURN . NEWLINE
    (28) expression -> . NAME
    (30) expression -> . expression_operation
    (45) expression -> . INT
    (46) expression -> . FLOAT
    (47) expression -> . STRING
    (48) expression -> . TRUE
    (49) expression -> . FALSE
    (50) expression -> . LBRACE int_type_array RBRACE
    (51) expression -> . LBRACE float_type_array RBRACE
    (52) expression -> . LBRACE string_type_array RBRACE
    (53) expression -> . LBRACE bool_type_array RBRACE
    (63) expression -> . LPAREN expression RPAREN
    (31) expression_operation -> . expression MULTIPLY expression
    (32) expression_operation -> . expression DIVIDE expression
    (33) expression_operation -> . expression MODULO expression
    (34) expression_operation -> . expression PLUS expression
    (35) expression_operation -> . expression MINUS expression
    (36) expression_operation -> . expression LD expression
    (37) expression_operation -> . expression LDEQ expression
    (38) expression_operation -> . expression GD expression
    (39) expression_operation -> . expression GDEQ expression
    (40) expression_operation -> . expression EQUALEQUAL expression
    (41) expression_operation -> . expression NOTEQ expression
    (42) expression_operation -> . expression AND expression
    (43) expression_operation -> . expression OR expression
    (44) expression_operation -> . NOT expression

    NEWLINE         shift and go to state 133
    NAME            shift and go to state 58
    INT             shift and go to state 14
    FLOAT           shift and go to state 15
    STRING          shift and go to state 16
    TRUE            shift and go to state 17
    FALSE           shift and go to state 18
    LBRACE          shift and go to state 19
    LPAREN          shift and go to state 20
    NOT             shift and go to state 26

    expression                     shift and go to state 132
    expression_operation           shift and go to state 13

state 128

    (16) return_stmt -> empty .

    STOP            reduce using rule 16 (return_stmt -> empty .)


state 129

    (68) else_block -> ELSE START . NEWLINE language STOP

    NEWLINE         shift and go to state 134


state 130

    (67) else_if_block -> ELSE_IF expression . START NEWLINE language STOP
    (31) expression_operation -> expression . MULTIPLY expression
    (32) expression_operation -> expression . DIVIDE expression
    (33) expression_operation -> expression . MODULO expression
    (34) expression_operation -> expression . PLUS expression
    (35) expression_operation -> expression . MINUS expression
    (36) expression_operation -> expression . LD expression
    (37) expression_operation -> expression . LDEQ expression
    (38) expression_operation -> expression . GD expression
    (39) expression_operation -> expression . GDEQ expression
    (40) expression_operation -> expression . EQUALEQUAL expression
    (41) expression_operation -> expression . NOTEQ expression
    (42) expression_operation -> expression . AND expression
    (43) expression_operation -> expression . OR expression

    START           shift and go to state 135
    MULTIPLY        shift and go to state 33
    DIVIDE          shift and go to state 34
    MODULO          shift and go to state 35
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    LD              shift and go to state 38
    LDEQ            shift and go to state 39
    GD              shift and go to state 40
    GDEQ            shift and go to state 41
    EQUALEQUAL      shift and go to state 42
    NOTEQ           shift and go to state 43
    AND             shift and go to state 44
    OR              shift and go to state 45


state 131

    (13) func_assign -> datatype NAME LPAREN parameters RPAREN START NEWLINE language return_stmt STOP .

    NEWLINE         reduce using rule 13 (func_assign -> datatype NAME LPAREN parameters RPAREN START NEWLINE language return_stmt STOP .)
    $end            reduce using rule 13 (func_assign -> datatype NAME LPAREN parameters RPAREN START NEWLINE language return_stmt STOP .)
    STOP            reduce using rule 13 (func_assign -> datatype NAME LPAREN parameters RPAREN START NEWLINE language return_stmt STOP .)
    RETURN          reduce using rule 13 (func_assign -> datatype NAME LPAREN parameters RPAREN START NEWLINE language return_stmt STOP .)


state 132

    (14) return_stmt -> RETURN expression . NEWLINE
    (31) expression_operation -> expression . MULTIPLY expression
    (32) expression_operation -> expression . DIVIDE expression
    (33) expression_operation -> expression . MODULO expression
    (34) expression_operation -> expression . PLUS expression
    (35) expression_operation -> expression . MINUS expression
    (36) expression_operation -> expression . LD expression
    (37) expression_operation -> expression . LDEQ expression
    (38) expression_operation -> expression . GD expression
    (39) expression_operation -> expression . GDEQ expression
    (40) expression_operation -> expression . EQUALEQUAL expression
    (41) expression_operation -> expression . NOTEQ expression
    (42) expression_operation -> expression . AND expression
    (43) expression_operation -> expression . OR expression

    NEWLINE         shift and go to state 136
    MULTIPLY        shift and go to state 33
    DIVIDE          shift and go to state 34
    MODULO          shift and go to state 35
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    LD              shift and go to state 38
    LDEQ            shift and go to state 39
    GD              shift and go to state 40
    GDEQ            shift and go to state 41
    EQUALEQUAL      shift and go to state 42
    NOTEQ           shift and go to state 43
    AND             shift and go to state 44
    OR              shift and go to state 45


state 133

    (15) return_stmt -> RETURN NEWLINE .

    STOP            reduce using rule 15 (return_stmt -> RETURN NEWLINE .)


state 134

    (68) else_block -> ELSE START NEWLINE . language STOP
    (3) language -> . language NEWLINE line
    (4) language -> . line
    (5) line -> . expression
    (6) line -> . var_assign
    (7) line -> . func_assign
    (8) line -> . iterative
    (9) line -> . conditional
    (10) line -> . output
    (11) line -> . input
    (12) line -> . empty
    (28) expression -> . NAME
    (30) expression -> . expression_operation
    (45) expression -> . INT
    (46) expression -> . FLOAT
    (47) expression -> . STRING
    (48) expression -> . TRUE
    (49) expression -> . FALSE
    (50) expression -> . LBRACE int_type_array RBRACE
    (51) expression -> . LBRACE float_type_array RBRACE
    (52) expression -> . LBRACE string_type_array RBRACE
    (53) expression -> . LBRACE bool_type_array RBRACE
    (63) expression -> . LPAREN expression RPAREN
    (29) var_assign -> . NAME EQUALS expression
    (13) func_assign -> . datatype NAME LPAREN parameters RPAREN START NEWLINE language return_stmt STOP
    (70) iterative -> . WHILE expression START NEWLINE language STOP
    (64) conditional -> . IF expression START NEWLINE language STOP else_if_blocks else_block
    (26) output -> . output_print
    (25) input -> . READ LPAREN NAME RPAREN
    (71) empty -> .
    (31) expression_operation -> . expression MULTIPLY expression
    (32) expression_operation -> . expression DIVIDE expression
    (33) expression_operation -> . expression MODULO expression
    (34) expression_operation -> . expression PLUS expression
    (35) expression_operation -> . expression MINUS expression
    (36) expression_operation -> . expression LD expression
    (37) expression_operation -> . expression LDEQ expression
    (38) expression_operation -> . expression GD expression
    (39) expression_operation -> . expression GDEQ expression
    (40) expression_operation -> . expression EQUALEQUAL expression
    (41) expression_operation -> . expression NOTEQ expression
    (42) expression_operation -> . expression AND expression
    (43) expression_operation -> . expression OR expression
    (44) expression_operation -> . NOT expression
    (21) datatype -> . INT_TYPE
    (22) datatype -> . FLOAT_TYPE
    (23) datatype -> . STRING_TYPE
    (24) datatype -> . VOID_TYPE
    (27) output_print -> . PRINT LPAREN expression RPAREN

    NAME            shift and go to state 12
    INT             shift and go to state 14
    FLOAT           shift and go to state 15
    STRING          shift and go to state 16
    TRUE            shift and go to state 17
    FALSE           shift and go to state 18
    LBRACE          shift and go to state 19
    LPAREN          shift and go to state 20
    WHILE           shift and go to state 22
    IF              shift and go to state 23
    READ            shift and go to state 25
    STOP            reduce using rule 71 (empty -> .)
    NEWLINE         reduce using rule 71 (empty -> .)
    NOT             shift and go to state 26
    INT_TYPE        shift and go to state 27
    FLOAT_TYPE      shift and go to state 28
    STRING_TYPE     shift and go to state 29
    VOID_TYPE       shift and go to state 30
    PRINT           shift and go to state 31

    language                       shift and go to state 137
    line                           shift and go to state 4
    expression                     shift and go to state 5
    var_assign                     shift and go to state 6
    func_assign                    shift and go to state 7
    iterative                      shift and go to state 8
    conditional                    shift and go to state 9
    output                         shift and go to state 10
    input                          shift and go to state 11
    empty                          shift and go to state 66
    expression_operation           shift and go to state 13
    datatype                       shift and go to state 21
    output_print                   shift and go to state 24

state 135

    (67) else_if_block -> ELSE_IF expression START . NEWLINE language STOP

    NEWLINE         shift and go to state 138


state 136

    (14) return_stmt -> RETURN expression NEWLINE .

    STOP            reduce using rule 14 (return_stmt -> RETURN expression NEWLINE .)


state 137

    (68) else_block -> ELSE START NEWLINE language . STOP
    (3) language -> language . NEWLINE line

    STOP            shift and go to state 139
    NEWLINE         shift and go to state 32


state 138

    (67) else_if_block -> ELSE_IF expression START NEWLINE . language STOP
    (3) language -> . language NEWLINE line
    (4) language -> . line
    (5) line -> . expression
    (6) line -> . var_assign
    (7) line -> . func_assign
    (8) line -> . iterative
    (9) line -> . conditional
    (10) line -> . output
    (11) line -> . input
    (12) line -> . empty
    (28) expression -> . NAME
    (30) expression -> . expression_operation
    (45) expression -> . INT
    (46) expression -> . FLOAT
    (47) expression -> . STRING
    (48) expression -> . TRUE
    (49) expression -> . FALSE
    (50) expression -> . LBRACE int_type_array RBRACE
    (51) expression -> . LBRACE float_type_array RBRACE
    (52) expression -> . LBRACE string_type_array RBRACE
    (53) expression -> . LBRACE bool_type_array RBRACE
    (63) expression -> . LPAREN expression RPAREN
    (29) var_assign -> . NAME EQUALS expression
    (13) func_assign -> . datatype NAME LPAREN parameters RPAREN START NEWLINE language return_stmt STOP
    (70) iterative -> . WHILE expression START NEWLINE language STOP
    (64) conditional -> . IF expression START NEWLINE language STOP else_if_blocks else_block
    (26) output -> . output_print
    (25) input -> . READ LPAREN NAME RPAREN
    (71) empty -> .
    (31) expression_operation -> . expression MULTIPLY expression
    (32) expression_operation -> . expression DIVIDE expression
    (33) expression_operation -> . expression MODULO expression
    (34) expression_operation -> . expression PLUS expression
    (35) expression_operation -> . expression MINUS expression
    (36) expression_operation -> . expression LD expression
    (37) expression_operation -> . expression LDEQ expression
    (38) expression_operation -> . expression GD expression
    (39) expression_operation -> . expression GDEQ expression
    (40) expression_operation -> . expression EQUALEQUAL expression
    (41) expression_operation -> . expression NOTEQ expression
    (42) expression_operation -> . expression AND expression
    (43) expression_operation -> . expression OR expression
    (44) expression_operation -> . NOT expression
    (21) datatype -> . INT_TYPE
    (22) datatype -> . FLOAT_TYPE
    (23) datatype -> . STRING_TYPE
    (24) datatype -> . VOID_TYPE
    (27) output_print -> . PRINT LPAREN expression RPAREN

    NAME            shift and go to state 12
    INT             shift and go to state 14
    FLOAT           shift and go to state 15
    STRING          shift and go to state 16
    TRUE            shift and go to state 17
    FALSE           shift and go to state 18
    LBRACE          shift and go to state 19
    LPAREN          shift and go to state 20
    WHILE           shift and go to state 22
    IF              shift and go to state 23
    READ            shift and go to state 25
    STOP            reduce using rule 71 (empty -> .)
    NEWLINE         reduce using rule 71 (empty -> .)
    NOT             shift and go to state 26
    INT_TYPE        shift and go to state 27
    FLOAT_TYPE      shift and go to state 28
    STRING_TYPE     shift and go to state 29
    VOID_TYPE       shift and go to state 30
    PRINT           shift and go to state 31

    expression                     shift and go to state 5
    language                       shift and go to state 140
    line                           shift and go to state 4
    var_assign                     shift and go to state 6
    func_assign                    shift and go to state 7
    iterative                      shift and go to state 8
    conditional                    shift and go to state 9
    output                         shift and go to state 10
    input                          shift and go to state 11
    empty                          shift and go to state 66
    expression_operation           shift and go to state 13
    datatype                       shift and go to state 21
    output_print                   shift and go to state 24

state 139

    (68) else_block -> ELSE START NEWLINE language STOP .

    NEWLINE         reduce using rule 68 (else_block -> ELSE START NEWLINE language STOP .)
    $end            reduce using rule 68 (else_block -> ELSE START NEWLINE language STOP .)
    STOP            reduce using rule 68 (else_block -> ELSE START NEWLINE language STOP .)
    RETURN          reduce using rule 68 (else_block -> ELSE START NEWLINE language STOP .)


state 140

    (67) else_if_block -> ELSE_IF expression START NEWLINE language . STOP
    (3) language -> language . NEWLINE line

    STOP            shift and go to state 141
    NEWLINE         shift and go to state 32


state 141

    (67) else_if_block -> ELSE_IF expression START NEWLINE language STOP .

    ELSE            reduce using rule 67 (else_if_block -> ELSE_IF expression START NEWLINE language STOP .)
    ELSE_IF         reduce using rule 67 (else_if_block -> ELSE_IF expression START NEWLINE language STOP .)
    NEWLINE         reduce using rule 67 (else_if_block -> ELSE_IF expression START NEWLINE language STOP .)
    $end            reduce using rule 67 (else_if_block -> ELSE_IF expression START NEWLINE language STOP .)
    STOP            reduce using rule 67 (else_if_block -> ELSE_IF expression START NEWLINE language STOP .)
    RETURN          reduce using rule 67 (else_if_block -> ELSE_IF expression START NEWLINE language STOP .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: reduce/reduce conflict in state 3 resolved using rule (start -> empty)
WARNING: rejected rule (line -> empty) in state 3
WARNING: reduce/reduce conflict in state 51 resolved using rule (int_type_array -> empty)
WARNING: rejected rule (float_type_array -> empty) in state 51
WARNING: reduce/reduce conflict in state 51 resolved using rule (int_type_array -> empty)
WARNING: rejected rule (string_type_array -> empty) in state 51
WARNING: reduce/reduce conflict in state 51 resolved using rule (int_type_array -> empty)
WARNING: rejected rule (bool_type_array -> empty) in state 51
