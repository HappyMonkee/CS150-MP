Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> start
Rule 1     start -> language
Rule 2     start -> empty
Rule 3     language -> language NEWLINE line
Rule 4     language -> line
Rule 5     line -> expression
Rule 6     line -> var_assign
Rule 7     line -> func_assign
Rule 8     line -> iterative
Rule 9     line -> conditional
Rule 10    line -> output
Rule 11    line -> input
Rule 12    line -> empty
Rule 13    func_assign -> datatype NAME LPAREN parameters RPAREN START NEWLINE language return_stmt STOP
Rule 14    return_stmt -> RETURN expression NEWLINE
Rule 15    return_stmt -> RETURN NEWLINE
Rule 16    return_stmt -> empty
Rule 17    parameters -> first_param
Rule 18    parameters -> empty
Rule 19    first_param -> datatype NAME COMMA first_param
Rule 20    first_param -> datatype NAME
Rule 21    datatype -> INT_TYPE
Rule 22    datatype -> FLOAT_TYPE
Rule 23    datatype -> STRING_TYPE
Rule 24    datatype -> VOID_TYPE
Rule 25    input -> READ LPAREN NAME RPAREN
Rule 26    output -> output_print
Rule 27    output_print -> PRINT LPAREN expression RPAREN
Rule 28    expression -> NAME
Rule 29    var_assign -> datatype NAME EQUALS expression
Rule 30    var_assign -> NAME EQUALS expression
Rule 31    expression -> math
Rule 32    expression -> str
Rule 33    math -> math MULTIPLY math
Rule 34    math -> math DIVIDE math
Rule 35    math -> math MODULO math
Rule 36    math -> math PLUS math
Rule 37    math -> math MINUS math
Rule 38    math -> math LD math
Rule 39    math -> math LDEQ math
Rule 40    math -> math GD math
Rule 41    math -> math GDEQ math
Rule 42    math -> math EQUALEQUAL math
Rule 43    math -> math NOTEQ math
Rule 44    math -> math AND math
Rule 45    math -> math OR math
Rule 46    math -> NOT math
Rule 47    math -> MINUS math
Rule 48    math -> INT
Rule 49    math -> FLOAT
Rule 50    math -> TRUE
Rule 51    math -> FALSE
Rule 52    str -> str PLUS str
Rule 53    str -> str LD str
Rule 54    str -> str LDEQ str
Rule 55    str -> str GD str
Rule 56    str -> str GDEQ str
Rule 57    str -> str EQUALEQUAL str
Rule 58    str -> str NOTEQ str
Rule 59    str -> STRING
Rule 60    math -> NAME
Rule 61    str -> NAME
Rule 62    expression -> LBRACE int_type_array RBRACE
Rule 63    expression -> LBRACE string_type_array RBRACE
Rule 64    int_type_array -> math
Rule 65    int_type_array -> math COMMA int_type_array
Rule 66    string_type_array -> str
Rule 67    string_type_array -> str COMMA string_type_array
Rule 68    math -> LPAREN math RPAREN
Rule 69    str -> LPAREN str RPAREN
Rule 70    conditional -> IF expression START NEWLINE language STOP else_if_blocks else_block
Rule 71    else_if_blocks -> empty
Rule 72    else_if_blocks -> else_if_block else_if_blocks
Rule 73    else_if_block -> ELSE_IF expression START NEWLINE language STOP
Rule 74    else_block -> ELSE START NEWLINE language STOP
Rule 75    else_block -> empty
Rule 76    iterative -> WHILE expression START NEWLINE language STOP
Rule 77    empty -> <empty>

Terminals, with rules where they appear

AND                  : 44
COMMA                : 19 65 67
DIVIDE               : 34
ELSE                 : 74
ELSE_IF              : 73
EQUALEQUAL           : 42 57
EQUALS               : 29 30
FALSE                : 51
FLOAT                : 49
FLOAT_TYPE           : 22
GD                   : 40 55
GDEQ                 : 41 56
IF                   : 70
INT                  : 48
INT_TYPE             : 21
LBRACE               : 62 63
LD                   : 38 53
LDEQ                 : 39 54
LPAREN               : 13 25 27 68 69
MINUS                : 37 47
MODULO               : 35
MULTIPLY             : 33
NAME                 : 13 19 20 25 28 29 30 60 61
NEWLINE              : 3 13 14 15 70 73 74 76
NOT                  : 46
NOTEQ                : 43 58
OR                   : 45
PLUS                 : 36 52
PRINT                : 27
RBRACE               : 62 63
READ                 : 25
RETURN               : 14 15
RPAREN               : 13 25 27 68 69
START                : 13 70 73 74 76
STOP                 : 13 70 73 74 76
STRING               : 59
STRING_TYPE          : 23
TRUE                 : 50
VOID_TYPE            : 24
WHILE                : 76
error                : 

Nonterminals, with rules where they appear

conditional          : 9
datatype             : 13 19 20 29
else_block           : 70
else_if_block        : 72
else_if_blocks       : 70 72
empty                : 2 12 16 18 71 75
expression           : 5 14 27 29 30 70 73 76
first_param          : 17 19
func_assign          : 7
input                : 11
int_type_array       : 62 65
iterative            : 8
language             : 1 3 13 70 73 74 76
line                 : 3 4
math                 : 31 33 33 34 34 35 35 36 36 37 37 38 38 39 39 40 40 41 41 42 42 43 43 44 44 45 45 46 47 64 65 68
output               : 10
output_print         : 26
parameters           : 13
return_stmt          : 13
start                : 0
str                  : 32 52 52 53 53 54 54 55 55 56 56 57 57 58 58 66 67 69
string_type_array    : 63 67
var_assign           : 6

Parsing method: LALR

state 0

    (0) S' -> . start
    (1) start -> . language
    (2) start -> . empty
    (3) language -> . language NEWLINE line
    (4) language -> . line
    (77) empty -> .
    (5) line -> . expression
    (6) line -> . var_assign
    (7) line -> . func_assign
    (8) line -> . iterative
    (9) line -> . conditional
    (10) line -> . output
    (11) line -> . input
    (12) line -> . empty
    (28) expression -> . NAME
    (31) expression -> . math
    (32) expression -> . str
    (62) expression -> . LBRACE int_type_array RBRACE
    (63) expression -> . LBRACE string_type_array RBRACE
    (29) var_assign -> . datatype NAME EQUALS expression
    (30) var_assign -> . NAME EQUALS expression
    (13) func_assign -> . datatype NAME LPAREN parameters RPAREN START NEWLINE language return_stmt STOP
    (76) iterative -> . WHILE expression START NEWLINE language STOP
    (70) conditional -> . IF expression START NEWLINE language STOP else_if_blocks else_block
    (26) output -> . output_print
    (25) input -> . READ LPAREN NAME RPAREN
    (33) math -> . math MULTIPLY math
    (34) math -> . math DIVIDE math
    (35) math -> . math MODULO math
    (36) math -> . math PLUS math
    (37) math -> . math MINUS math
    (38) math -> . math LD math
    (39) math -> . math LDEQ math
    (40) math -> . math GD math
    (41) math -> . math GDEQ math
    (42) math -> . math EQUALEQUAL math
    (43) math -> . math NOTEQ math
    (44) math -> . math AND math
    (45) math -> . math OR math
    (46) math -> . NOT math
    (47) math -> . MINUS math
    (48) math -> . INT
    (49) math -> . FLOAT
    (50) math -> . TRUE
    (51) math -> . FALSE
    (60) math -> . NAME
    (68) math -> . LPAREN math RPAREN
    (52) str -> . str PLUS str
    (53) str -> . str LD str
    (54) str -> . str LDEQ str
    (55) str -> . str GD str
    (56) str -> . str GDEQ str
    (57) str -> . str EQUALEQUAL str
    (58) str -> . str NOTEQ str
    (59) str -> . STRING
    (61) str -> . NAME
    (69) str -> . LPAREN str RPAREN
    (21) datatype -> . INT_TYPE
    (22) datatype -> . FLOAT_TYPE
    (23) datatype -> . STRING_TYPE
    (24) datatype -> . VOID_TYPE
    (27) output_print -> . PRINT LPAREN expression RPAREN

    $end            reduce using rule 77 (empty -> .)
    NEWLINE         reduce using rule 77 (empty -> .)
    NAME            shift and go to state 12
    LBRACE          shift and go to state 15
    WHILE           shift and go to state 18
    IF              shift and go to state 19
    READ            shift and go to state 21
    NOT             shift and go to state 23
    MINUS           shift and go to state 22
    INT             shift and go to state 24
    FLOAT           shift and go to state 25
    TRUE            shift and go to state 26
    FALSE           shift and go to state 27
    LPAREN          shift and go to state 17
    STRING          shift and go to state 28
    INT_TYPE        shift and go to state 29
    FLOAT_TYPE      shift and go to state 30
    STRING_TYPE     shift and go to state 31
    VOID_TYPE       shift and go to state 32
    PRINT           shift and go to state 33

    start                          shift and go to state 1
    language                       shift and go to state 2
    empty                          shift and go to state 3
    line                           shift and go to state 4
    expression                     shift and go to state 5
    var_assign                     shift and go to state 6
    func_assign                    shift and go to state 7
    iterative                      shift and go to state 8
    conditional                    shift and go to state 9
    output                         shift and go to state 10
    input                          shift and go to state 11
    math                           shift and go to state 13
    str                            shift and go to state 14
    datatype                       shift and go to state 16
    output_print                   shift and go to state 20

state 1

    (0) S' -> start .



state 2

    (1) start -> language .
    (3) language -> language . NEWLINE line

    $end            reduce using rule 1 (start -> language .)
    NEWLINE         shift and go to state 34


state 3

    (2) start -> empty .
    (12) line -> empty .

  ! reduce/reduce conflict for $end resolved using rule 2 (start -> empty .)
    $end            reduce using rule 2 (start -> empty .)
    NEWLINE         reduce using rule 12 (line -> empty .)

  ! $end            [ reduce using rule 12 (line -> empty .) ]


state 4

    (4) language -> line .

    NEWLINE         reduce using rule 4 (language -> line .)
    $end            reduce using rule 4 (language -> line .)
    STOP            reduce using rule 4 (language -> line .)
    RETURN          reduce using rule 4 (language -> line .)


state 5

    (5) line -> expression .

    NEWLINE         reduce using rule 5 (line -> expression .)
    $end            reduce using rule 5 (line -> expression .)
    STOP            reduce using rule 5 (line -> expression .)
    RETURN          reduce using rule 5 (line -> expression .)


state 6

    (6) line -> var_assign .

    NEWLINE         reduce using rule 6 (line -> var_assign .)
    $end            reduce using rule 6 (line -> var_assign .)
    STOP            reduce using rule 6 (line -> var_assign .)
    RETURN          reduce using rule 6 (line -> var_assign .)


state 7

    (7) line -> func_assign .

    NEWLINE         reduce using rule 7 (line -> func_assign .)
    $end            reduce using rule 7 (line -> func_assign .)
    STOP            reduce using rule 7 (line -> func_assign .)
    RETURN          reduce using rule 7 (line -> func_assign .)


state 8

    (8) line -> iterative .

    NEWLINE         reduce using rule 8 (line -> iterative .)
    $end            reduce using rule 8 (line -> iterative .)
    STOP            reduce using rule 8 (line -> iterative .)
    RETURN          reduce using rule 8 (line -> iterative .)


state 9

    (9) line -> conditional .

    NEWLINE         reduce using rule 9 (line -> conditional .)
    $end            reduce using rule 9 (line -> conditional .)
    STOP            reduce using rule 9 (line -> conditional .)
    RETURN          reduce using rule 9 (line -> conditional .)


state 10

    (10) line -> output .

    NEWLINE         reduce using rule 10 (line -> output .)
    $end            reduce using rule 10 (line -> output .)
    STOP            reduce using rule 10 (line -> output .)
    RETURN          reduce using rule 10 (line -> output .)


state 11

    (11) line -> input .

    NEWLINE         reduce using rule 11 (line -> input .)
    $end            reduce using rule 11 (line -> input .)
    STOP            reduce using rule 11 (line -> input .)
    RETURN          reduce using rule 11 (line -> input .)


state 12

    (28) expression -> NAME .
    (30) var_assign -> NAME . EQUALS expression
    (60) math -> NAME .
    (61) str -> NAME .

  ! reduce/reduce conflict for NEWLINE resolved using rule 28 (expression -> NAME .)
  ! reduce/reduce conflict for $end resolved using rule 28 (expression -> NAME .)
  ! reduce/reduce conflict for STOP resolved using rule 28 (expression -> NAME .)
  ! reduce/reduce conflict for RETURN resolved using rule 28 (expression -> NAME .)
  ! reduce/reduce conflict for PLUS resolved using rule 60 (math -> NAME .)
  ! reduce/reduce conflict for LD resolved using rule 60 (math -> NAME .)
  ! reduce/reduce conflict for LDEQ resolved using rule 60 (math -> NAME .)
  ! reduce/reduce conflict for GD resolved using rule 60 (math -> NAME .)
  ! reduce/reduce conflict for GDEQ resolved using rule 60 (math -> NAME .)
  ! reduce/reduce conflict for EQUALEQUAL resolved using rule 60 (math -> NAME .)
  ! reduce/reduce conflict for NOTEQ resolved using rule 60 (math -> NAME .)
  ! reduce/reduce conflict for NEWLINE resolved using rule 28 (expression -> NAME .)
  ! reduce/reduce conflict for $end resolved using rule 28 (expression -> NAME .)
  ! reduce/reduce conflict for STOP resolved using rule 28 (expression -> NAME .)
  ! reduce/reduce conflict for RETURN resolved using rule 28 (expression -> NAME .)
    NEWLINE         reduce using rule 28 (expression -> NAME .)
    $end            reduce using rule 28 (expression -> NAME .)
    STOP            reduce using rule 28 (expression -> NAME .)
    RETURN          reduce using rule 28 (expression -> NAME .)
    EQUALS          shift and go to state 35
    MULTIPLY        reduce using rule 60 (math -> NAME .)
    DIVIDE          reduce using rule 60 (math -> NAME .)
    MODULO          reduce using rule 60 (math -> NAME .)
    PLUS            reduce using rule 60 (math -> NAME .)
    MINUS           reduce using rule 60 (math -> NAME .)
    LD              reduce using rule 60 (math -> NAME .)
    LDEQ            reduce using rule 60 (math -> NAME .)
    GD              reduce using rule 60 (math -> NAME .)
    GDEQ            reduce using rule 60 (math -> NAME .)
    EQUALEQUAL      reduce using rule 60 (math -> NAME .)
    NOTEQ           reduce using rule 60 (math -> NAME .)
    AND             reduce using rule 60 (math -> NAME .)
    OR              reduce using rule 60 (math -> NAME .)

  ! NEWLINE         [ reduce using rule 60 (math -> NAME .) ]
  ! $end            [ reduce using rule 60 (math -> NAME .) ]
  ! STOP            [ reduce using rule 60 (math -> NAME .) ]
  ! RETURN          [ reduce using rule 60 (math -> NAME .) ]
  ! PLUS            [ reduce using rule 61 (str -> NAME .) ]
  ! LD              [ reduce using rule 61 (str -> NAME .) ]
  ! LDEQ            [ reduce using rule 61 (str -> NAME .) ]
  ! GD              [ reduce using rule 61 (str -> NAME .) ]
  ! GDEQ            [ reduce using rule 61 (str -> NAME .) ]
  ! EQUALEQUAL      [ reduce using rule 61 (str -> NAME .) ]
  ! NOTEQ           [ reduce using rule 61 (str -> NAME .) ]
  ! NEWLINE         [ reduce using rule 61 (str -> NAME .) ]
  ! $end            [ reduce using rule 61 (str -> NAME .) ]
  ! STOP            [ reduce using rule 61 (str -> NAME .) ]
  ! RETURN          [ reduce using rule 61 (str -> NAME .) ]


state 13

    (31) expression -> math .
    (33) math -> math . MULTIPLY math
    (34) math -> math . DIVIDE math
    (35) math -> math . MODULO math
    (36) math -> math . PLUS math
    (37) math -> math . MINUS math
    (38) math -> math . LD math
    (39) math -> math . LDEQ math
    (40) math -> math . GD math
    (41) math -> math . GDEQ math
    (42) math -> math . EQUALEQUAL math
    (43) math -> math . NOTEQ math
    (44) math -> math . AND math
    (45) math -> math . OR math

    NEWLINE         reduce using rule 31 (expression -> math .)
    $end            reduce using rule 31 (expression -> math .)
    START           reduce using rule 31 (expression -> math .)
    STOP            reduce using rule 31 (expression -> math .)
    RETURN          reduce using rule 31 (expression -> math .)
    RPAREN          reduce using rule 31 (expression -> math .)
    MULTIPLY        shift and go to state 36
    DIVIDE          shift and go to state 37
    MODULO          shift and go to state 38
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    LD              shift and go to state 41
    LDEQ            shift and go to state 42
    GD              shift and go to state 43
    GDEQ            shift and go to state 44
    EQUALEQUAL      shift and go to state 45
    NOTEQ           shift and go to state 46
    AND             shift and go to state 47
    OR              shift and go to state 48


state 14

    (32) expression -> str .
    (52) str -> str . PLUS str
    (53) str -> str . LD str
    (54) str -> str . LDEQ str
    (55) str -> str . GD str
    (56) str -> str . GDEQ str
    (57) str -> str . EQUALEQUAL str
    (58) str -> str . NOTEQ str

    NEWLINE         reduce using rule 32 (expression -> str .)
    $end            reduce using rule 32 (expression -> str .)
    START           reduce using rule 32 (expression -> str .)
    STOP            reduce using rule 32 (expression -> str .)
    RETURN          reduce using rule 32 (expression -> str .)
    RPAREN          reduce using rule 32 (expression -> str .)
    PLUS            shift and go to state 49
    LD              shift and go to state 50
    LDEQ            shift and go to state 51
    GD              shift and go to state 52
    GDEQ            shift and go to state 53
    EQUALEQUAL      shift and go to state 54
    NOTEQ           shift and go to state 55


state 15

    (62) expression -> LBRACE . int_type_array RBRACE
    (63) expression -> LBRACE . string_type_array RBRACE
    (64) int_type_array -> . math
    (65) int_type_array -> . math COMMA int_type_array
    (66) string_type_array -> . str
    (67) string_type_array -> . str COMMA string_type_array
    (33) math -> . math MULTIPLY math
    (34) math -> . math DIVIDE math
    (35) math -> . math MODULO math
    (36) math -> . math PLUS math
    (37) math -> . math MINUS math
    (38) math -> . math LD math
    (39) math -> . math LDEQ math
    (40) math -> . math GD math
    (41) math -> . math GDEQ math
    (42) math -> . math EQUALEQUAL math
    (43) math -> . math NOTEQ math
    (44) math -> . math AND math
    (45) math -> . math OR math
    (46) math -> . NOT math
    (47) math -> . MINUS math
    (48) math -> . INT
    (49) math -> . FLOAT
    (50) math -> . TRUE
    (51) math -> . FALSE
    (60) math -> . NAME
    (68) math -> . LPAREN math RPAREN
    (52) str -> . str PLUS str
    (53) str -> . str LD str
    (54) str -> . str LDEQ str
    (55) str -> . str GD str
    (56) str -> . str GDEQ str
    (57) str -> . str EQUALEQUAL str
    (58) str -> . str NOTEQ str
    (59) str -> . STRING
    (61) str -> . NAME
    (69) str -> . LPAREN str RPAREN

    NOT             shift and go to state 23
    MINUS           shift and go to state 22
    INT             shift and go to state 24
    FLOAT           shift and go to state 25
    TRUE            shift and go to state 26
    FALSE           shift and go to state 27
    NAME            shift and go to state 60
    LPAREN          shift and go to state 17
    STRING          shift and go to state 28

    int_type_array                 shift and go to state 56
    string_type_array              shift and go to state 57
    math                           shift and go to state 58
    str                            shift and go to state 59

state 16

    (29) var_assign -> datatype . NAME EQUALS expression
    (13) func_assign -> datatype . NAME LPAREN parameters RPAREN START NEWLINE language return_stmt STOP

    NAME            shift and go to state 61


state 17

    (68) math -> LPAREN . math RPAREN
    (69) str -> LPAREN . str RPAREN
    (33) math -> . math MULTIPLY math
    (34) math -> . math DIVIDE math
    (35) math -> . math MODULO math
    (36) math -> . math PLUS math
    (37) math -> . math MINUS math
    (38) math -> . math LD math
    (39) math -> . math LDEQ math
    (40) math -> . math GD math
    (41) math -> . math GDEQ math
    (42) math -> . math EQUALEQUAL math
    (43) math -> . math NOTEQ math
    (44) math -> . math AND math
    (45) math -> . math OR math
    (46) math -> . NOT math
    (47) math -> . MINUS math
    (48) math -> . INT
    (49) math -> . FLOAT
    (50) math -> . TRUE
    (51) math -> . FALSE
    (60) math -> . NAME
    (68) math -> . LPAREN math RPAREN
    (52) str -> . str PLUS str
    (53) str -> . str LD str
    (54) str -> . str LDEQ str
    (55) str -> . str GD str
    (56) str -> . str GDEQ str
    (57) str -> . str EQUALEQUAL str
    (58) str -> . str NOTEQ str
    (59) str -> . STRING
    (61) str -> . NAME
    (69) str -> . LPAREN str RPAREN

    NOT             shift and go to state 23
    MINUS           shift and go to state 22
    INT             shift and go to state 24
    FLOAT           shift and go to state 25
    TRUE            shift and go to state 26
    FALSE           shift and go to state 27
    NAME            shift and go to state 60
    LPAREN          shift and go to state 17
    STRING          shift and go to state 28

    math                           shift and go to state 62
    str                            shift and go to state 63

state 18

    (76) iterative -> WHILE . expression START NEWLINE language STOP
    (28) expression -> . NAME
    (31) expression -> . math
    (32) expression -> . str
    (62) expression -> . LBRACE int_type_array RBRACE
    (63) expression -> . LBRACE string_type_array RBRACE
    (33) math -> . math MULTIPLY math
    (34) math -> . math DIVIDE math
    (35) math -> . math MODULO math
    (36) math -> . math PLUS math
    (37) math -> . math MINUS math
    (38) math -> . math LD math
    (39) math -> . math LDEQ math
    (40) math -> . math GD math
    (41) math -> . math GDEQ math
    (42) math -> . math EQUALEQUAL math
    (43) math -> . math NOTEQ math
    (44) math -> . math AND math
    (45) math -> . math OR math
    (46) math -> . NOT math
    (47) math -> . MINUS math
    (48) math -> . INT
    (49) math -> . FLOAT
    (50) math -> . TRUE
    (51) math -> . FALSE
    (60) math -> . NAME
    (68) math -> . LPAREN math RPAREN
    (52) str -> . str PLUS str
    (53) str -> . str LD str
    (54) str -> . str LDEQ str
    (55) str -> . str GD str
    (56) str -> . str GDEQ str
    (57) str -> . str EQUALEQUAL str
    (58) str -> . str NOTEQ str
    (59) str -> . STRING
    (61) str -> . NAME
    (69) str -> . LPAREN str RPAREN

    NAME            shift and go to state 65
    LBRACE          shift and go to state 15
    NOT             shift and go to state 23
    MINUS           shift and go to state 22
    INT             shift and go to state 24
    FLOAT           shift and go to state 25
    TRUE            shift and go to state 26
    FALSE           shift and go to state 27
    LPAREN          shift and go to state 17
    STRING          shift and go to state 28

    expression                     shift and go to state 64
    math                           shift and go to state 13
    str                            shift and go to state 14

state 19

    (70) conditional -> IF . expression START NEWLINE language STOP else_if_blocks else_block
    (28) expression -> . NAME
    (31) expression -> . math
    (32) expression -> . str
    (62) expression -> . LBRACE int_type_array RBRACE
    (63) expression -> . LBRACE string_type_array RBRACE
    (33) math -> . math MULTIPLY math
    (34) math -> . math DIVIDE math
    (35) math -> . math MODULO math
    (36) math -> . math PLUS math
    (37) math -> . math MINUS math
    (38) math -> . math LD math
    (39) math -> . math LDEQ math
    (40) math -> . math GD math
    (41) math -> . math GDEQ math
    (42) math -> . math EQUALEQUAL math
    (43) math -> . math NOTEQ math
    (44) math -> . math AND math
    (45) math -> . math OR math
    (46) math -> . NOT math
    (47) math -> . MINUS math
    (48) math -> . INT
    (49) math -> . FLOAT
    (50) math -> . TRUE
    (51) math -> . FALSE
    (60) math -> . NAME
    (68) math -> . LPAREN math RPAREN
    (52) str -> . str PLUS str
    (53) str -> . str LD str
    (54) str -> . str LDEQ str
    (55) str -> . str GD str
    (56) str -> . str GDEQ str
    (57) str -> . str EQUALEQUAL str
    (58) str -> . str NOTEQ str
    (59) str -> . STRING
    (61) str -> . NAME
    (69) str -> . LPAREN str RPAREN

    NAME            shift and go to state 65
    LBRACE          shift and go to state 15
    NOT             shift and go to state 23
    MINUS           shift and go to state 22
    INT             shift and go to state 24
    FLOAT           shift and go to state 25
    TRUE            shift and go to state 26
    FALSE           shift and go to state 27
    LPAREN          shift and go to state 17
    STRING          shift and go to state 28

    expression                     shift and go to state 66
    math                           shift and go to state 13
    str                            shift and go to state 14

state 20

    (26) output -> output_print .

    NEWLINE         reduce using rule 26 (output -> output_print .)
    $end            reduce using rule 26 (output -> output_print .)
    STOP            reduce using rule 26 (output -> output_print .)
    RETURN          reduce using rule 26 (output -> output_print .)


state 21

    (25) input -> READ . LPAREN NAME RPAREN

    LPAREN          shift and go to state 67


state 22

    (47) math -> MINUS . math
    (33) math -> . math MULTIPLY math
    (34) math -> . math DIVIDE math
    (35) math -> . math MODULO math
    (36) math -> . math PLUS math
    (37) math -> . math MINUS math
    (38) math -> . math LD math
    (39) math -> . math LDEQ math
    (40) math -> . math GD math
    (41) math -> . math GDEQ math
    (42) math -> . math EQUALEQUAL math
    (43) math -> . math NOTEQ math
    (44) math -> . math AND math
    (45) math -> . math OR math
    (46) math -> . NOT math
    (47) math -> . MINUS math
    (48) math -> . INT
    (49) math -> . FLOAT
    (50) math -> . TRUE
    (51) math -> . FALSE
    (60) math -> . NAME
    (68) math -> . LPAREN math RPAREN

    NOT             shift and go to state 23
    MINUS           shift and go to state 22
    INT             shift and go to state 24
    FLOAT           shift and go to state 25
    TRUE            shift and go to state 26
    FALSE           shift and go to state 27
    NAME            shift and go to state 69
    LPAREN          shift and go to state 70

    math                           shift and go to state 68

state 23

    (46) math -> NOT . math
    (33) math -> . math MULTIPLY math
    (34) math -> . math DIVIDE math
    (35) math -> . math MODULO math
    (36) math -> . math PLUS math
    (37) math -> . math MINUS math
    (38) math -> . math LD math
    (39) math -> . math LDEQ math
    (40) math -> . math GD math
    (41) math -> . math GDEQ math
    (42) math -> . math EQUALEQUAL math
    (43) math -> . math NOTEQ math
    (44) math -> . math AND math
    (45) math -> . math OR math
    (46) math -> . NOT math
    (47) math -> . MINUS math
    (48) math -> . INT
    (49) math -> . FLOAT
    (50) math -> . TRUE
    (51) math -> . FALSE
    (60) math -> . NAME
    (68) math -> . LPAREN math RPAREN

    NOT             shift and go to state 23
    MINUS           shift and go to state 22
    INT             shift and go to state 24
    FLOAT           shift and go to state 25
    TRUE            shift and go to state 26
    FALSE           shift and go to state 27
    NAME            shift and go to state 69
    LPAREN          shift and go to state 70

    math                           shift and go to state 71

state 24

    (48) math -> INT .

    MULTIPLY        reduce using rule 48 (math -> INT .)
    DIVIDE          reduce using rule 48 (math -> INT .)
    MODULO          reduce using rule 48 (math -> INT .)
    PLUS            reduce using rule 48 (math -> INT .)
    MINUS           reduce using rule 48 (math -> INT .)
    LD              reduce using rule 48 (math -> INT .)
    LDEQ            reduce using rule 48 (math -> INT .)
    GD              reduce using rule 48 (math -> INT .)
    GDEQ            reduce using rule 48 (math -> INT .)
    EQUALEQUAL      reduce using rule 48 (math -> INT .)
    NOTEQ           reduce using rule 48 (math -> INT .)
    AND             reduce using rule 48 (math -> INT .)
    OR              reduce using rule 48 (math -> INT .)
    NEWLINE         reduce using rule 48 (math -> INT .)
    $end            reduce using rule 48 (math -> INT .)
    COMMA           reduce using rule 48 (math -> INT .)
    RBRACE          reduce using rule 48 (math -> INT .)
    RPAREN          reduce using rule 48 (math -> INT .)
    START           reduce using rule 48 (math -> INT .)
    STOP            reduce using rule 48 (math -> INT .)
    RETURN          reduce using rule 48 (math -> INT .)


state 25

    (49) math -> FLOAT .

    MULTIPLY        reduce using rule 49 (math -> FLOAT .)
    DIVIDE          reduce using rule 49 (math -> FLOAT .)
    MODULO          reduce using rule 49 (math -> FLOAT .)
    PLUS            reduce using rule 49 (math -> FLOAT .)
    MINUS           reduce using rule 49 (math -> FLOAT .)
    LD              reduce using rule 49 (math -> FLOAT .)
    LDEQ            reduce using rule 49 (math -> FLOAT .)
    GD              reduce using rule 49 (math -> FLOAT .)
    GDEQ            reduce using rule 49 (math -> FLOAT .)
    EQUALEQUAL      reduce using rule 49 (math -> FLOAT .)
    NOTEQ           reduce using rule 49 (math -> FLOAT .)
    AND             reduce using rule 49 (math -> FLOAT .)
    OR              reduce using rule 49 (math -> FLOAT .)
    NEWLINE         reduce using rule 49 (math -> FLOAT .)
    $end            reduce using rule 49 (math -> FLOAT .)
    COMMA           reduce using rule 49 (math -> FLOAT .)
    RBRACE          reduce using rule 49 (math -> FLOAT .)
    RPAREN          reduce using rule 49 (math -> FLOAT .)
    START           reduce using rule 49 (math -> FLOAT .)
    STOP            reduce using rule 49 (math -> FLOAT .)
    RETURN          reduce using rule 49 (math -> FLOAT .)


state 26

    (50) math -> TRUE .

    MULTIPLY        reduce using rule 50 (math -> TRUE .)
    DIVIDE          reduce using rule 50 (math -> TRUE .)
    MODULO          reduce using rule 50 (math -> TRUE .)
    PLUS            reduce using rule 50 (math -> TRUE .)
    MINUS           reduce using rule 50 (math -> TRUE .)
    LD              reduce using rule 50 (math -> TRUE .)
    LDEQ            reduce using rule 50 (math -> TRUE .)
    GD              reduce using rule 50 (math -> TRUE .)
    GDEQ            reduce using rule 50 (math -> TRUE .)
    EQUALEQUAL      reduce using rule 50 (math -> TRUE .)
    NOTEQ           reduce using rule 50 (math -> TRUE .)
    AND             reduce using rule 50 (math -> TRUE .)
    OR              reduce using rule 50 (math -> TRUE .)
    NEWLINE         reduce using rule 50 (math -> TRUE .)
    $end            reduce using rule 50 (math -> TRUE .)
    COMMA           reduce using rule 50 (math -> TRUE .)
    RBRACE          reduce using rule 50 (math -> TRUE .)
    RPAREN          reduce using rule 50 (math -> TRUE .)
    START           reduce using rule 50 (math -> TRUE .)
    STOP            reduce using rule 50 (math -> TRUE .)
    RETURN          reduce using rule 50 (math -> TRUE .)


state 27

    (51) math -> FALSE .

    MULTIPLY        reduce using rule 51 (math -> FALSE .)
    DIVIDE          reduce using rule 51 (math -> FALSE .)
    MODULO          reduce using rule 51 (math -> FALSE .)
    PLUS            reduce using rule 51 (math -> FALSE .)
    MINUS           reduce using rule 51 (math -> FALSE .)
    LD              reduce using rule 51 (math -> FALSE .)
    LDEQ            reduce using rule 51 (math -> FALSE .)
    GD              reduce using rule 51 (math -> FALSE .)
    GDEQ            reduce using rule 51 (math -> FALSE .)
    EQUALEQUAL      reduce using rule 51 (math -> FALSE .)
    NOTEQ           reduce using rule 51 (math -> FALSE .)
    AND             reduce using rule 51 (math -> FALSE .)
    OR              reduce using rule 51 (math -> FALSE .)
    NEWLINE         reduce using rule 51 (math -> FALSE .)
    $end            reduce using rule 51 (math -> FALSE .)
    COMMA           reduce using rule 51 (math -> FALSE .)
    RBRACE          reduce using rule 51 (math -> FALSE .)
    RPAREN          reduce using rule 51 (math -> FALSE .)
    START           reduce using rule 51 (math -> FALSE .)
    STOP            reduce using rule 51 (math -> FALSE .)
    RETURN          reduce using rule 51 (math -> FALSE .)


state 28

    (59) str -> STRING .

    PLUS            reduce using rule 59 (str -> STRING .)
    LD              reduce using rule 59 (str -> STRING .)
    LDEQ            reduce using rule 59 (str -> STRING .)
    GD              reduce using rule 59 (str -> STRING .)
    GDEQ            reduce using rule 59 (str -> STRING .)
    EQUALEQUAL      reduce using rule 59 (str -> STRING .)
    NOTEQ           reduce using rule 59 (str -> STRING .)
    NEWLINE         reduce using rule 59 (str -> STRING .)
    $end            reduce using rule 59 (str -> STRING .)
    COMMA           reduce using rule 59 (str -> STRING .)
    RBRACE          reduce using rule 59 (str -> STRING .)
    RPAREN          reduce using rule 59 (str -> STRING .)
    START           reduce using rule 59 (str -> STRING .)
    STOP            reduce using rule 59 (str -> STRING .)
    RETURN          reduce using rule 59 (str -> STRING .)


state 29

    (21) datatype -> INT_TYPE .

    NAME            reduce using rule 21 (datatype -> INT_TYPE .)


state 30

    (22) datatype -> FLOAT_TYPE .

    NAME            reduce using rule 22 (datatype -> FLOAT_TYPE .)


state 31

    (23) datatype -> STRING_TYPE .

    NAME            reduce using rule 23 (datatype -> STRING_TYPE .)


state 32

    (24) datatype -> VOID_TYPE .

    NAME            reduce using rule 24 (datatype -> VOID_TYPE .)


state 33

    (27) output_print -> PRINT . LPAREN expression RPAREN

    LPAREN          shift and go to state 72


state 34

    (3) language -> language NEWLINE . line
    (5) line -> . expression
    (6) line -> . var_assign
    (7) line -> . func_assign
    (8) line -> . iterative
    (9) line -> . conditional
    (10) line -> . output
    (11) line -> . input
    (12) line -> . empty
    (28) expression -> . NAME
    (31) expression -> . math
    (32) expression -> . str
    (62) expression -> . LBRACE int_type_array RBRACE
    (63) expression -> . LBRACE string_type_array RBRACE
    (29) var_assign -> . datatype NAME EQUALS expression
    (30) var_assign -> . NAME EQUALS expression
    (13) func_assign -> . datatype NAME LPAREN parameters RPAREN START NEWLINE language return_stmt STOP
    (76) iterative -> . WHILE expression START NEWLINE language STOP
    (70) conditional -> . IF expression START NEWLINE language STOP else_if_blocks else_block
    (26) output -> . output_print
    (25) input -> . READ LPAREN NAME RPAREN
    (77) empty -> .
    (33) math -> . math MULTIPLY math
    (34) math -> . math DIVIDE math
    (35) math -> . math MODULO math
    (36) math -> . math PLUS math
    (37) math -> . math MINUS math
    (38) math -> . math LD math
    (39) math -> . math LDEQ math
    (40) math -> . math GD math
    (41) math -> . math GDEQ math
    (42) math -> . math EQUALEQUAL math
    (43) math -> . math NOTEQ math
    (44) math -> . math AND math
    (45) math -> . math OR math
    (46) math -> . NOT math
    (47) math -> . MINUS math
    (48) math -> . INT
    (49) math -> . FLOAT
    (50) math -> . TRUE
    (51) math -> . FALSE
    (60) math -> . NAME
    (68) math -> . LPAREN math RPAREN
    (52) str -> . str PLUS str
    (53) str -> . str LD str
    (54) str -> . str LDEQ str
    (55) str -> . str GD str
    (56) str -> . str GDEQ str
    (57) str -> . str EQUALEQUAL str
    (58) str -> . str NOTEQ str
    (59) str -> . STRING
    (61) str -> . NAME
    (69) str -> . LPAREN str RPAREN
    (21) datatype -> . INT_TYPE
    (22) datatype -> . FLOAT_TYPE
    (23) datatype -> . STRING_TYPE
    (24) datatype -> . VOID_TYPE
    (27) output_print -> . PRINT LPAREN expression RPAREN

    NAME            shift and go to state 12
    LBRACE          shift and go to state 15
    WHILE           shift and go to state 18
    IF              shift and go to state 19
    READ            shift and go to state 21
    NEWLINE         reduce using rule 77 (empty -> .)
    $end            reduce using rule 77 (empty -> .)
    STOP            reduce using rule 77 (empty -> .)
    RETURN          reduce using rule 77 (empty -> .)
    NOT             shift and go to state 23
    MINUS           shift and go to state 22
    INT             shift and go to state 24
    FLOAT           shift and go to state 25
    TRUE            shift and go to state 26
    FALSE           shift and go to state 27
    LPAREN          shift and go to state 17
    STRING          shift and go to state 28
    INT_TYPE        shift and go to state 29
    FLOAT_TYPE      shift and go to state 30
    STRING_TYPE     shift and go to state 31
    VOID_TYPE       shift and go to state 32
    PRINT           shift and go to state 33

    line                           shift and go to state 73
    expression                     shift and go to state 5
    var_assign                     shift and go to state 6
    func_assign                    shift and go to state 7
    iterative                      shift and go to state 8
    conditional                    shift and go to state 9
    output                         shift and go to state 10
    input                          shift and go to state 11
    empty                          shift and go to state 74
    math                           shift and go to state 13
    str                            shift and go to state 14
    datatype                       shift and go to state 16
    output_print                   shift and go to state 20

state 35

    (30) var_assign -> NAME EQUALS . expression
    (28) expression -> . NAME
    (31) expression -> . math
    (32) expression -> . str
    (62) expression -> . LBRACE int_type_array RBRACE
    (63) expression -> . LBRACE string_type_array RBRACE
    (33) math -> . math MULTIPLY math
    (34) math -> . math DIVIDE math
    (35) math -> . math MODULO math
    (36) math -> . math PLUS math
    (37) math -> . math MINUS math
    (38) math -> . math LD math
    (39) math -> . math LDEQ math
    (40) math -> . math GD math
    (41) math -> . math GDEQ math
    (42) math -> . math EQUALEQUAL math
    (43) math -> . math NOTEQ math
    (44) math -> . math AND math
    (45) math -> . math OR math
    (46) math -> . NOT math
    (47) math -> . MINUS math
    (48) math -> . INT
    (49) math -> . FLOAT
    (50) math -> . TRUE
    (51) math -> . FALSE
    (60) math -> . NAME
    (68) math -> . LPAREN math RPAREN
    (52) str -> . str PLUS str
    (53) str -> . str LD str
    (54) str -> . str LDEQ str
    (55) str -> . str GD str
    (56) str -> . str GDEQ str
    (57) str -> . str EQUALEQUAL str
    (58) str -> . str NOTEQ str
    (59) str -> . STRING
    (61) str -> . NAME
    (69) str -> . LPAREN str RPAREN

    NAME            shift and go to state 65
    LBRACE          shift and go to state 15
    NOT             shift and go to state 23
    MINUS           shift and go to state 22
    INT             shift and go to state 24
    FLOAT           shift and go to state 25
    TRUE            shift and go to state 26
    FALSE           shift and go to state 27
    LPAREN          shift and go to state 17
    STRING          shift and go to state 28

    expression                     shift and go to state 75
    math                           shift and go to state 13
    str                            shift and go to state 14

state 36

    (33) math -> math MULTIPLY . math
    (33) math -> . math MULTIPLY math
    (34) math -> . math DIVIDE math
    (35) math -> . math MODULO math
    (36) math -> . math PLUS math
    (37) math -> . math MINUS math
    (38) math -> . math LD math
    (39) math -> . math LDEQ math
    (40) math -> . math GD math
    (41) math -> . math GDEQ math
    (42) math -> . math EQUALEQUAL math
    (43) math -> . math NOTEQ math
    (44) math -> . math AND math
    (45) math -> . math OR math
    (46) math -> . NOT math
    (47) math -> . MINUS math
    (48) math -> . INT
    (49) math -> . FLOAT
    (50) math -> . TRUE
    (51) math -> . FALSE
    (60) math -> . NAME
    (68) math -> . LPAREN math RPAREN

    NOT             shift and go to state 23
    MINUS           shift and go to state 22
    INT             shift and go to state 24
    FLOAT           shift and go to state 25
    TRUE            shift and go to state 26
    FALSE           shift and go to state 27
    NAME            shift and go to state 69
    LPAREN          shift and go to state 70

    math                           shift and go to state 76

state 37

    (34) math -> math DIVIDE . math
    (33) math -> . math MULTIPLY math
    (34) math -> . math DIVIDE math
    (35) math -> . math MODULO math
    (36) math -> . math PLUS math
    (37) math -> . math MINUS math
    (38) math -> . math LD math
    (39) math -> . math LDEQ math
    (40) math -> . math GD math
    (41) math -> . math GDEQ math
    (42) math -> . math EQUALEQUAL math
    (43) math -> . math NOTEQ math
    (44) math -> . math AND math
    (45) math -> . math OR math
    (46) math -> . NOT math
    (47) math -> . MINUS math
    (48) math -> . INT
    (49) math -> . FLOAT
    (50) math -> . TRUE
    (51) math -> . FALSE
    (60) math -> . NAME
    (68) math -> . LPAREN math RPAREN

    NOT             shift and go to state 23
    MINUS           shift and go to state 22
    INT             shift and go to state 24
    FLOAT           shift and go to state 25
    TRUE            shift and go to state 26
    FALSE           shift and go to state 27
    NAME            shift and go to state 69
    LPAREN          shift and go to state 70

    math                           shift and go to state 77

state 38

    (35) math -> math MODULO . math
    (33) math -> . math MULTIPLY math
    (34) math -> . math DIVIDE math
    (35) math -> . math MODULO math
    (36) math -> . math PLUS math
    (37) math -> . math MINUS math
    (38) math -> . math LD math
    (39) math -> . math LDEQ math
    (40) math -> . math GD math
    (41) math -> . math GDEQ math
    (42) math -> . math EQUALEQUAL math
    (43) math -> . math NOTEQ math
    (44) math -> . math AND math
    (45) math -> . math OR math
    (46) math -> . NOT math
    (47) math -> . MINUS math
    (48) math -> . INT
    (49) math -> . FLOAT
    (50) math -> . TRUE
    (51) math -> . FALSE
    (60) math -> . NAME
    (68) math -> . LPAREN math RPAREN

    NOT             shift and go to state 23
    MINUS           shift and go to state 22
    INT             shift and go to state 24
    FLOAT           shift and go to state 25
    TRUE            shift and go to state 26
    FALSE           shift and go to state 27
    NAME            shift and go to state 69
    LPAREN          shift and go to state 70

    math                           shift and go to state 78

state 39

    (36) math -> math PLUS . math
    (33) math -> . math MULTIPLY math
    (34) math -> . math DIVIDE math
    (35) math -> . math MODULO math
    (36) math -> . math PLUS math
    (37) math -> . math MINUS math
    (38) math -> . math LD math
    (39) math -> . math LDEQ math
    (40) math -> . math GD math
    (41) math -> . math GDEQ math
    (42) math -> . math EQUALEQUAL math
    (43) math -> . math NOTEQ math
    (44) math -> . math AND math
    (45) math -> . math OR math
    (46) math -> . NOT math
    (47) math -> . MINUS math
    (48) math -> . INT
    (49) math -> . FLOAT
    (50) math -> . TRUE
    (51) math -> . FALSE
    (60) math -> . NAME
    (68) math -> . LPAREN math RPAREN

    NOT             shift and go to state 23
    MINUS           shift and go to state 22
    INT             shift and go to state 24
    FLOAT           shift and go to state 25
    TRUE            shift and go to state 26
    FALSE           shift and go to state 27
    NAME            shift and go to state 69
    LPAREN          shift and go to state 70

    math                           shift and go to state 79

state 40

    (37) math -> math MINUS . math
    (33) math -> . math MULTIPLY math
    (34) math -> . math DIVIDE math
    (35) math -> . math MODULO math
    (36) math -> . math PLUS math
    (37) math -> . math MINUS math
    (38) math -> . math LD math
    (39) math -> . math LDEQ math
    (40) math -> . math GD math
    (41) math -> . math GDEQ math
    (42) math -> . math EQUALEQUAL math
    (43) math -> . math NOTEQ math
    (44) math -> . math AND math
    (45) math -> . math OR math
    (46) math -> . NOT math
    (47) math -> . MINUS math
    (48) math -> . INT
    (49) math -> . FLOAT
    (50) math -> . TRUE
    (51) math -> . FALSE
    (60) math -> . NAME
    (68) math -> . LPAREN math RPAREN

    NOT             shift and go to state 23
    MINUS           shift and go to state 22
    INT             shift and go to state 24
    FLOAT           shift and go to state 25
    TRUE            shift and go to state 26
    FALSE           shift and go to state 27
    NAME            shift and go to state 69
    LPAREN          shift and go to state 70

    math                           shift and go to state 80

state 41

    (38) math -> math LD . math
    (33) math -> . math MULTIPLY math
    (34) math -> . math DIVIDE math
    (35) math -> . math MODULO math
    (36) math -> . math PLUS math
    (37) math -> . math MINUS math
    (38) math -> . math LD math
    (39) math -> . math LDEQ math
    (40) math -> . math GD math
    (41) math -> . math GDEQ math
    (42) math -> . math EQUALEQUAL math
    (43) math -> . math NOTEQ math
    (44) math -> . math AND math
    (45) math -> . math OR math
    (46) math -> . NOT math
    (47) math -> . MINUS math
    (48) math -> . INT
    (49) math -> . FLOAT
    (50) math -> . TRUE
    (51) math -> . FALSE
    (60) math -> . NAME
    (68) math -> . LPAREN math RPAREN

    NOT             shift and go to state 23
    MINUS           shift and go to state 22
    INT             shift and go to state 24
    FLOAT           shift and go to state 25
    TRUE            shift and go to state 26
    FALSE           shift and go to state 27
    NAME            shift and go to state 69
    LPAREN          shift and go to state 70

    math                           shift and go to state 81

state 42

    (39) math -> math LDEQ . math
    (33) math -> . math MULTIPLY math
    (34) math -> . math DIVIDE math
    (35) math -> . math MODULO math
    (36) math -> . math PLUS math
    (37) math -> . math MINUS math
    (38) math -> . math LD math
    (39) math -> . math LDEQ math
    (40) math -> . math GD math
    (41) math -> . math GDEQ math
    (42) math -> . math EQUALEQUAL math
    (43) math -> . math NOTEQ math
    (44) math -> . math AND math
    (45) math -> . math OR math
    (46) math -> . NOT math
    (47) math -> . MINUS math
    (48) math -> . INT
    (49) math -> . FLOAT
    (50) math -> . TRUE
    (51) math -> . FALSE
    (60) math -> . NAME
    (68) math -> . LPAREN math RPAREN

    NOT             shift and go to state 23
    MINUS           shift and go to state 22
    INT             shift and go to state 24
    FLOAT           shift and go to state 25
    TRUE            shift and go to state 26
    FALSE           shift and go to state 27
    NAME            shift and go to state 69
    LPAREN          shift and go to state 70

    math                           shift and go to state 82

state 43

    (40) math -> math GD . math
    (33) math -> . math MULTIPLY math
    (34) math -> . math DIVIDE math
    (35) math -> . math MODULO math
    (36) math -> . math PLUS math
    (37) math -> . math MINUS math
    (38) math -> . math LD math
    (39) math -> . math LDEQ math
    (40) math -> . math GD math
    (41) math -> . math GDEQ math
    (42) math -> . math EQUALEQUAL math
    (43) math -> . math NOTEQ math
    (44) math -> . math AND math
    (45) math -> . math OR math
    (46) math -> . NOT math
    (47) math -> . MINUS math
    (48) math -> . INT
    (49) math -> . FLOAT
    (50) math -> . TRUE
    (51) math -> . FALSE
    (60) math -> . NAME
    (68) math -> . LPAREN math RPAREN

    NOT             shift and go to state 23
    MINUS           shift and go to state 22
    INT             shift and go to state 24
    FLOAT           shift and go to state 25
    TRUE            shift and go to state 26
    FALSE           shift and go to state 27
    NAME            shift and go to state 69
    LPAREN          shift and go to state 70

    math                           shift and go to state 83

state 44

    (41) math -> math GDEQ . math
    (33) math -> . math MULTIPLY math
    (34) math -> . math DIVIDE math
    (35) math -> . math MODULO math
    (36) math -> . math PLUS math
    (37) math -> . math MINUS math
    (38) math -> . math LD math
    (39) math -> . math LDEQ math
    (40) math -> . math GD math
    (41) math -> . math GDEQ math
    (42) math -> . math EQUALEQUAL math
    (43) math -> . math NOTEQ math
    (44) math -> . math AND math
    (45) math -> . math OR math
    (46) math -> . NOT math
    (47) math -> . MINUS math
    (48) math -> . INT
    (49) math -> . FLOAT
    (50) math -> . TRUE
    (51) math -> . FALSE
    (60) math -> . NAME
    (68) math -> . LPAREN math RPAREN

    NOT             shift and go to state 23
    MINUS           shift and go to state 22
    INT             shift and go to state 24
    FLOAT           shift and go to state 25
    TRUE            shift and go to state 26
    FALSE           shift and go to state 27
    NAME            shift and go to state 69
    LPAREN          shift and go to state 70

    math                           shift and go to state 84

state 45

    (42) math -> math EQUALEQUAL . math
    (33) math -> . math MULTIPLY math
    (34) math -> . math DIVIDE math
    (35) math -> . math MODULO math
    (36) math -> . math PLUS math
    (37) math -> . math MINUS math
    (38) math -> . math LD math
    (39) math -> . math LDEQ math
    (40) math -> . math GD math
    (41) math -> . math GDEQ math
    (42) math -> . math EQUALEQUAL math
    (43) math -> . math NOTEQ math
    (44) math -> . math AND math
    (45) math -> . math OR math
    (46) math -> . NOT math
    (47) math -> . MINUS math
    (48) math -> . INT
    (49) math -> . FLOAT
    (50) math -> . TRUE
    (51) math -> . FALSE
    (60) math -> . NAME
    (68) math -> . LPAREN math RPAREN

    NOT             shift and go to state 23
    MINUS           shift and go to state 22
    INT             shift and go to state 24
    FLOAT           shift and go to state 25
    TRUE            shift and go to state 26
    FALSE           shift and go to state 27
    NAME            shift and go to state 69
    LPAREN          shift and go to state 70

    math                           shift and go to state 85

state 46

    (43) math -> math NOTEQ . math
    (33) math -> . math MULTIPLY math
    (34) math -> . math DIVIDE math
    (35) math -> . math MODULO math
    (36) math -> . math PLUS math
    (37) math -> . math MINUS math
    (38) math -> . math LD math
    (39) math -> . math LDEQ math
    (40) math -> . math GD math
    (41) math -> . math GDEQ math
    (42) math -> . math EQUALEQUAL math
    (43) math -> . math NOTEQ math
    (44) math -> . math AND math
    (45) math -> . math OR math
    (46) math -> . NOT math
    (47) math -> . MINUS math
    (48) math -> . INT
    (49) math -> . FLOAT
    (50) math -> . TRUE
    (51) math -> . FALSE
    (60) math -> . NAME
    (68) math -> . LPAREN math RPAREN

    NOT             shift and go to state 23
    MINUS           shift and go to state 22
    INT             shift and go to state 24
    FLOAT           shift and go to state 25
    TRUE            shift and go to state 26
    FALSE           shift and go to state 27
    NAME            shift and go to state 69
    LPAREN          shift and go to state 70

    math                           shift and go to state 86

state 47

    (44) math -> math AND . math
    (33) math -> . math MULTIPLY math
    (34) math -> . math DIVIDE math
    (35) math -> . math MODULO math
    (36) math -> . math PLUS math
    (37) math -> . math MINUS math
    (38) math -> . math LD math
    (39) math -> . math LDEQ math
    (40) math -> . math GD math
    (41) math -> . math GDEQ math
    (42) math -> . math EQUALEQUAL math
    (43) math -> . math NOTEQ math
    (44) math -> . math AND math
    (45) math -> . math OR math
    (46) math -> . NOT math
    (47) math -> . MINUS math
    (48) math -> . INT
    (49) math -> . FLOAT
    (50) math -> . TRUE
    (51) math -> . FALSE
    (60) math -> . NAME
    (68) math -> . LPAREN math RPAREN

    NOT             shift and go to state 23
    MINUS           shift and go to state 22
    INT             shift and go to state 24
    FLOAT           shift and go to state 25
    TRUE            shift and go to state 26
    FALSE           shift and go to state 27
    NAME            shift and go to state 69
    LPAREN          shift and go to state 70

    math                           shift and go to state 87

state 48

    (45) math -> math OR . math
    (33) math -> . math MULTIPLY math
    (34) math -> . math DIVIDE math
    (35) math -> . math MODULO math
    (36) math -> . math PLUS math
    (37) math -> . math MINUS math
    (38) math -> . math LD math
    (39) math -> . math LDEQ math
    (40) math -> . math GD math
    (41) math -> . math GDEQ math
    (42) math -> . math EQUALEQUAL math
    (43) math -> . math NOTEQ math
    (44) math -> . math AND math
    (45) math -> . math OR math
    (46) math -> . NOT math
    (47) math -> . MINUS math
    (48) math -> . INT
    (49) math -> . FLOAT
    (50) math -> . TRUE
    (51) math -> . FALSE
    (60) math -> . NAME
    (68) math -> . LPAREN math RPAREN

    NOT             shift and go to state 23
    MINUS           shift and go to state 22
    INT             shift and go to state 24
    FLOAT           shift and go to state 25
    TRUE            shift and go to state 26
    FALSE           shift and go to state 27
    NAME            shift and go to state 69
    LPAREN          shift and go to state 70

    math                           shift and go to state 88

state 49

    (52) str -> str PLUS . str
    (52) str -> . str PLUS str
    (53) str -> . str LD str
    (54) str -> . str LDEQ str
    (55) str -> . str GD str
    (56) str -> . str GDEQ str
    (57) str -> . str EQUALEQUAL str
    (58) str -> . str NOTEQ str
    (59) str -> . STRING
    (61) str -> . NAME
    (69) str -> . LPAREN str RPAREN

    STRING          shift and go to state 28
    NAME            shift and go to state 90
    LPAREN          shift and go to state 91

    str                            shift and go to state 89

state 50

    (53) str -> str LD . str
    (52) str -> . str PLUS str
    (53) str -> . str LD str
    (54) str -> . str LDEQ str
    (55) str -> . str GD str
    (56) str -> . str GDEQ str
    (57) str -> . str EQUALEQUAL str
    (58) str -> . str NOTEQ str
    (59) str -> . STRING
    (61) str -> . NAME
    (69) str -> . LPAREN str RPAREN

    STRING          shift and go to state 28
    NAME            shift and go to state 90
    LPAREN          shift and go to state 91

    str                            shift and go to state 92

state 51

    (54) str -> str LDEQ . str
    (52) str -> . str PLUS str
    (53) str -> . str LD str
    (54) str -> . str LDEQ str
    (55) str -> . str GD str
    (56) str -> . str GDEQ str
    (57) str -> . str EQUALEQUAL str
    (58) str -> . str NOTEQ str
    (59) str -> . STRING
    (61) str -> . NAME
    (69) str -> . LPAREN str RPAREN

    STRING          shift and go to state 28
    NAME            shift and go to state 90
    LPAREN          shift and go to state 91

    str                            shift and go to state 93

state 52

    (55) str -> str GD . str
    (52) str -> . str PLUS str
    (53) str -> . str LD str
    (54) str -> . str LDEQ str
    (55) str -> . str GD str
    (56) str -> . str GDEQ str
    (57) str -> . str EQUALEQUAL str
    (58) str -> . str NOTEQ str
    (59) str -> . STRING
    (61) str -> . NAME
    (69) str -> . LPAREN str RPAREN

    STRING          shift and go to state 28
    NAME            shift and go to state 90
    LPAREN          shift and go to state 91

    str                            shift and go to state 94

state 53

    (56) str -> str GDEQ . str
    (52) str -> . str PLUS str
    (53) str -> . str LD str
    (54) str -> . str LDEQ str
    (55) str -> . str GD str
    (56) str -> . str GDEQ str
    (57) str -> . str EQUALEQUAL str
    (58) str -> . str NOTEQ str
    (59) str -> . STRING
    (61) str -> . NAME
    (69) str -> . LPAREN str RPAREN

    STRING          shift and go to state 28
    NAME            shift and go to state 90
    LPAREN          shift and go to state 91

    str                            shift and go to state 95

state 54

    (57) str -> str EQUALEQUAL . str
    (52) str -> . str PLUS str
    (53) str -> . str LD str
    (54) str -> . str LDEQ str
    (55) str -> . str GD str
    (56) str -> . str GDEQ str
    (57) str -> . str EQUALEQUAL str
    (58) str -> . str NOTEQ str
    (59) str -> . STRING
    (61) str -> . NAME
    (69) str -> . LPAREN str RPAREN

    STRING          shift and go to state 28
    NAME            shift and go to state 90
    LPAREN          shift and go to state 91

    str                            shift and go to state 96

state 55

    (58) str -> str NOTEQ . str
    (52) str -> . str PLUS str
    (53) str -> . str LD str
    (54) str -> . str LDEQ str
    (55) str -> . str GD str
    (56) str -> . str GDEQ str
    (57) str -> . str EQUALEQUAL str
    (58) str -> . str NOTEQ str
    (59) str -> . STRING
    (61) str -> . NAME
    (69) str -> . LPAREN str RPAREN

    STRING          shift and go to state 28
    NAME            shift and go to state 90
    LPAREN          shift and go to state 91

    str                            shift and go to state 97

state 56

    (62) expression -> LBRACE int_type_array . RBRACE

    RBRACE          shift and go to state 98


state 57

    (63) expression -> LBRACE string_type_array . RBRACE

    RBRACE          shift and go to state 99


state 58

    (64) int_type_array -> math .
    (65) int_type_array -> math . COMMA int_type_array
    (33) math -> math . MULTIPLY math
    (34) math -> math . DIVIDE math
    (35) math -> math . MODULO math
    (36) math -> math . PLUS math
    (37) math -> math . MINUS math
    (38) math -> math . LD math
    (39) math -> math . LDEQ math
    (40) math -> math . GD math
    (41) math -> math . GDEQ math
    (42) math -> math . EQUALEQUAL math
    (43) math -> math . NOTEQ math
    (44) math -> math . AND math
    (45) math -> math . OR math

    RBRACE          reduce using rule 64 (int_type_array -> math .)
    COMMA           shift and go to state 100
    MULTIPLY        shift and go to state 36
    DIVIDE          shift and go to state 37
    MODULO          shift and go to state 38
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    LD              shift and go to state 41
    LDEQ            shift and go to state 42
    GD              shift and go to state 43
    GDEQ            shift and go to state 44
    EQUALEQUAL      shift and go to state 45
    NOTEQ           shift and go to state 46
    AND             shift and go to state 47
    OR              shift and go to state 48


state 59

    (66) string_type_array -> str .
    (67) string_type_array -> str . COMMA string_type_array
    (52) str -> str . PLUS str
    (53) str -> str . LD str
    (54) str -> str . LDEQ str
    (55) str -> str . GD str
    (56) str -> str . GDEQ str
    (57) str -> str . EQUALEQUAL str
    (58) str -> str . NOTEQ str

    RBRACE          reduce using rule 66 (string_type_array -> str .)
    COMMA           shift and go to state 101
    PLUS            shift and go to state 49
    LD              shift and go to state 50
    LDEQ            shift and go to state 51
    GD              shift and go to state 52
    GDEQ            shift and go to state 53
    EQUALEQUAL      shift and go to state 54
    NOTEQ           shift and go to state 55


state 60

    (60) math -> NAME .
    (61) str -> NAME .

  ! reduce/reduce conflict for COMMA resolved using rule 60 (math -> NAME .)
  ! reduce/reduce conflict for PLUS resolved using rule 60 (math -> NAME .)
  ! reduce/reduce conflict for LD resolved using rule 60 (math -> NAME .)
  ! reduce/reduce conflict for LDEQ resolved using rule 60 (math -> NAME .)
  ! reduce/reduce conflict for GD resolved using rule 60 (math -> NAME .)
  ! reduce/reduce conflict for GDEQ resolved using rule 60 (math -> NAME .)
  ! reduce/reduce conflict for EQUALEQUAL resolved using rule 60 (math -> NAME .)
  ! reduce/reduce conflict for NOTEQ resolved using rule 60 (math -> NAME .)
  ! reduce/reduce conflict for RBRACE resolved using rule 60 (math -> NAME .)
  ! reduce/reduce conflict for RPAREN resolved using rule 60 (math -> NAME .)
    COMMA           reduce using rule 60 (math -> NAME .)
    MULTIPLY        reduce using rule 60 (math -> NAME .)
    DIVIDE          reduce using rule 60 (math -> NAME .)
    MODULO          reduce using rule 60 (math -> NAME .)
    PLUS            reduce using rule 60 (math -> NAME .)
    MINUS           reduce using rule 60 (math -> NAME .)
    LD              reduce using rule 60 (math -> NAME .)
    LDEQ            reduce using rule 60 (math -> NAME .)
    GD              reduce using rule 60 (math -> NAME .)
    GDEQ            reduce using rule 60 (math -> NAME .)
    EQUALEQUAL      reduce using rule 60 (math -> NAME .)
    NOTEQ           reduce using rule 60 (math -> NAME .)
    AND             reduce using rule 60 (math -> NAME .)
    OR              reduce using rule 60 (math -> NAME .)
    RBRACE          reduce using rule 60 (math -> NAME .)
    RPAREN          reduce using rule 60 (math -> NAME .)

  ! COMMA           [ reduce using rule 61 (str -> NAME .) ]
  ! PLUS            [ reduce using rule 61 (str -> NAME .) ]
  ! LD              [ reduce using rule 61 (str -> NAME .) ]
  ! LDEQ            [ reduce using rule 61 (str -> NAME .) ]
  ! GD              [ reduce using rule 61 (str -> NAME .) ]
  ! GDEQ            [ reduce using rule 61 (str -> NAME .) ]
  ! EQUALEQUAL      [ reduce using rule 61 (str -> NAME .) ]
  ! NOTEQ           [ reduce using rule 61 (str -> NAME .) ]
  ! RBRACE          [ reduce using rule 61 (str -> NAME .) ]
  ! RPAREN          [ reduce using rule 61 (str -> NAME .) ]


state 61

    (29) var_assign -> datatype NAME . EQUALS expression
    (13) func_assign -> datatype NAME . LPAREN parameters RPAREN START NEWLINE language return_stmt STOP

    EQUALS          shift and go to state 102
    LPAREN          shift and go to state 103


state 62

    (68) math -> LPAREN math . RPAREN
    (33) math -> math . MULTIPLY math
    (34) math -> math . DIVIDE math
    (35) math -> math . MODULO math
    (36) math -> math . PLUS math
    (37) math -> math . MINUS math
    (38) math -> math . LD math
    (39) math -> math . LDEQ math
    (40) math -> math . GD math
    (41) math -> math . GDEQ math
    (42) math -> math . EQUALEQUAL math
    (43) math -> math . NOTEQ math
    (44) math -> math . AND math
    (45) math -> math . OR math

    RPAREN          shift and go to state 104
    MULTIPLY        shift and go to state 36
    DIVIDE          shift and go to state 37
    MODULO          shift and go to state 38
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    LD              shift and go to state 41
    LDEQ            shift and go to state 42
    GD              shift and go to state 43
    GDEQ            shift and go to state 44
    EQUALEQUAL      shift and go to state 45
    NOTEQ           shift and go to state 46
    AND             shift and go to state 47
    OR              shift and go to state 48


state 63

    (69) str -> LPAREN str . RPAREN
    (52) str -> str . PLUS str
    (53) str -> str . LD str
    (54) str -> str . LDEQ str
    (55) str -> str . GD str
    (56) str -> str . GDEQ str
    (57) str -> str . EQUALEQUAL str
    (58) str -> str . NOTEQ str

    RPAREN          shift and go to state 105
    PLUS            shift and go to state 49
    LD              shift and go to state 50
    LDEQ            shift and go to state 51
    GD              shift and go to state 52
    GDEQ            shift and go to state 53
    EQUALEQUAL      shift and go to state 54
    NOTEQ           shift and go to state 55


state 64

    (76) iterative -> WHILE expression . START NEWLINE language STOP

    START           shift and go to state 106


state 65

    (28) expression -> NAME .
    (60) math -> NAME .
    (61) str -> NAME .

  ! reduce/reduce conflict for START resolved using rule 28 (expression -> NAME .)
  ! reduce/reduce conflict for NEWLINE resolved using rule 28 (expression -> NAME .)
  ! reduce/reduce conflict for $end resolved using rule 28 (expression -> NAME .)
  ! reduce/reduce conflict for STOP resolved using rule 28 (expression -> NAME .)
  ! reduce/reduce conflict for RETURN resolved using rule 28 (expression -> NAME .)
  ! reduce/reduce conflict for RPAREN resolved using rule 28 (expression -> NAME .)
  ! reduce/reduce conflict for PLUS resolved using rule 60 (math -> NAME .)
  ! reduce/reduce conflict for LD resolved using rule 60 (math -> NAME .)
  ! reduce/reduce conflict for LDEQ resolved using rule 60 (math -> NAME .)
  ! reduce/reduce conflict for GD resolved using rule 60 (math -> NAME .)
  ! reduce/reduce conflict for GDEQ resolved using rule 60 (math -> NAME .)
  ! reduce/reduce conflict for EQUALEQUAL resolved using rule 60 (math -> NAME .)
  ! reduce/reduce conflict for NOTEQ resolved using rule 60 (math -> NAME .)
  ! reduce/reduce conflict for START resolved using rule 28 (expression -> NAME .)
  ! reduce/reduce conflict for NEWLINE resolved using rule 28 (expression -> NAME .)
  ! reduce/reduce conflict for $end resolved using rule 28 (expression -> NAME .)
  ! reduce/reduce conflict for STOP resolved using rule 28 (expression -> NAME .)
  ! reduce/reduce conflict for RETURN resolved using rule 28 (expression -> NAME .)
  ! reduce/reduce conflict for RPAREN resolved using rule 28 (expression -> NAME .)
    START           reduce using rule 28 (expression -> NAME .)
    NEWLINE         reduce using rule 28 (expression -> NAME .)
    $end            reduce using rule 28 (expression -> NAME .)
    STOP            reduce using rule 28 (expression -> NAME .)
    RETURN          reduce using rule 28 (expression -> NAME .)
    RPAREN          reduce using rule 28 (expression -> NAME .)
    MULTIPLY        reduce using rule 60 (math -> NAME .)
    DIVIDE          reduce using rule 60 (math -> NAME .)
    MODULO          reduce using rule 60 (math -> NAME .)
    PLUS            reduce using rule 60 (math -> NAME .)
    MINUS           reduce using rule 60 (math -> NAME .)
    LD              reduce using rule 60 (math -> NAME .)
    LDEQ            reduce using rule 60 (math -> NAME .)
    GD              reduce using rule 60 (math -> NAME .)
    GDEQ            reduce using rule 60 (math -> NAME .)
    EQUALEQUAL      reduce using rule 60 (math -> NAME .)
    NOTEQ           reduce using rule 60 (math -> NAME .)
    AND             reduce using rule 60 (math -> NAME .)
    OR              reduce using rule 60 (math -> NAME .)

  ! START           [ reduce using rule 60 (math -> NAME .) ]
  ! NEWLINE         [ reduce using rule 60 (math -> NAME .) ]
  ! $end            [ reduce using rule 60 (math -> NAME .) ]
  ! STOP            [ reduce using rule 60 (math -> NAME .) ]
  ! RETURN          [ reduce using rule 60 (math -> NAME .) ]
  ! RPAREN          [ reduce using rule 60 (math -> NAME .) ]
  ! PLUS            [ reduce using rule 61 (str -> NAME .) ]
  ! LD              [ reduce using rule 61 (str -> NAME .) ]
  ! LDEQ            [ reduce using rule 61 (str -> NAME .) ]
  ! GD              [ reduce using rule 61 (str -> NAME .) ]
  ! GDEQ            [ reduce using rule 61 (str -> NAME .) ]
  ! EQUALEQUAL      [ reduce using rule 61 (str -> NAME .) ]
  ! NOTEQ           [ reduce using rule 61 (str -> NAME .) ]
  ! START           [ reduce using rule 61 (str -> NAME .) ]
  ! NEWLINE         [ reduce using rule 61 (str -> NAME .) ]
  ! $end            [ reduce using rule 61 (str -> NAME .) ]
  ! STOP            [ reduce using rule 61 (str -> NAME .) ]
  ! RETURN          [ reduce using rule 61 (str -> NAME .) ]
  ! RPAREN          [ reduce using rule 61 (str -> NAME .) ]


state 66

    (70) conditional -> IF expression . START NEWLINE language STOP else_if_blocks else_block

    START           shift and go to state 107


state 67

    (25) input -> READ LPAREN . NAME RPAREN

    NAME            shift and go to state 108


state 68

    (47) math -> MINUS math .
    (33) math -> math . MULTIPLY math
    (34) math -> math . DIVIDE math
    (35) math -> math . MODULO math
    (36) math -> math . PLUS math
    (37) math -> math . MINUS math
    (38) math -> math . LD math
    (39) math -> math . LDEQ math
    (40) math -> math . GD math
    (41) math -> math . GDEQ math
    (42) math -> math . EQUALEQUAL math
    (43) math -> math . NOTEQ math
    (44) math -> math . AND math
    (45) math -> math . OR math

    PLUS            reduce using rule 47 (math -> MINUS math .)
    MINUS           reduce using rule 47 (math -> MINUS math .)
    LD              reduce using rule 47 (math -> MINUS math .)
    LDEQ            reduce using rule 47 (math -> MINUS math .)
    GD              reduce using rule 47 (math -> MINUS math .)
    GDEQ            reduce using rule 47 (math -> MINUS math .)
    EQUALEQUAL      reduce using rule 47 (math -> MINUS math .)
    NOTEQ           reduce using rule 47 (math -> MINUS math .)
    AND             reduce using rule 47 (math -> MINUS math .)
    OR              reduce using rule 47 (math -> MINUS math .)
    NEWLINE         reduce using rule 47 (math -> MINUS math .)
    $end            reduce using rule 47 (math -> MINUS math .)
    COMMA           reduce using rule 47 (math -> MINUS math .)
    RBRACE          reduce using rule 47 (math -> MINUS math .)
    RPAREN          reduce using rule 47 (math -> MINUS math .)
    START           reduce using rule 47 (math -> MINUS math .)
    STOP            reduce using rule 47 (math -> MINUS math .)
    RETURN          reduce using rule 47 (math -> MINUS math .)
    MULTIPLY        shift and go to state 36
    DIVIDE          shift and go to state 37
    MODULO          shift and go to state 38

  ! MULTIPLY        [ reduce using rule 47 (math -> MINUS math .) ]
  ! DIVIDE          [ reduce using rule 47 (math -> MINUS math .) ]
  ! MODULO          [ reduce using rule 47 (math -> MINUS math .) ]
  ! PLUS            [ shift and go to state 39 ]
  ! MINUS           [ shift and go to state 40 ]
  ! LD              [ shift and go to state 41 ]
  ! LDEQ            [ shift and go to state 42 ]
  ! GD              [ shift and go to state 43 ]
  ! GDEQ            [ shift and go to state 44 ]
  ! EQUALEQUAL      [ shift and go to state 45 ]
  ! NOTEQ           [ shift and go to state 46 ]
  ! AND             [ shift and go to state 47 ]
  ! OR              [ shift and go to state 48 ]


state 69

    (60) math -> NAME .

    MULTIPLY        reduce using rule 60 (math -> NAME .)
    DIVIDE          reduce using rule 60 (math -> NAME .)
    MODULO          reduce using rule 60 (math -> NAME .)
    PLUS            reduce using rule 60 (math -> NAME .)
    MINUS           reduce using rule 60 (math -> NAME .)
    LD              reduce using rule 60 (math -> NAME .)
    LDEQ            reduce using rule 60 (math -> NAME .)
    GD              reduce using rule 60 (math -> NAME .)
    GDEQ            reduce using rule 60 (math -> NAME .)
    EQUALEQUAL      reduce using rule 60 (math -> NAME .)
    NOTEQ           reduce using rule 60 (math -> NAME .)
    AND             reduce using rule 60 (math -> NAME .)
    OR              reduce using rule 60 (math -> NAME .)
    NEWLINE         reduce using rule 60 (math -> NAME .)
    $end            reduce using rule 60 (math -> NAME .)
    COMMA           reduce using rule 60 (math -> NAME .)
    RBRACE          reduce using rule 60 (math -> NAME .)
    RPAREN          reduce using rule 60 (math -> NAME .)
    START           reduce using rule 60 (math -> NAME .)
    STOP            reduce using rule 60 (math -> NAME .)
    RETURN          reduce using rule 60 (math -> NAME .)


state 70

    (68) math -> LPAREN . math RPAREN
    (33) math -> . math MULTIPLY math
    (34) math -> . math DIVIDE math
    (35) math -> . math MODULO math
    (36) math -> . math PLUS math
    (37) math -> . math MINUS math
    (38) math -> . math LD math
    (39) math -> . math LDEQ math
    (40) math -> . math GD math
    (41) math -> . math GDEQ math
    (42) math -> . math EQUALEQUAL math
    (43) math -> . math NOTEQ math
    (44) math -> . math AND math
    (45) math -> . math OR math
    (46) math -> . NOT math
    (47) math -> . MINUS math
    (48) math -> . INT
    (49) math -> . FLOAT
    (50) math -> . TRUE
    (51) math -> . FALSE
    (60) math -> . NAME
    (68) math -> . LPAREN math RPAREN

    NOT             shift and go to state 23
    MINUS           shift and go to state 22
    INT             shift and go to state 24
    FLOAT           shift and go to state 25
    TRUE            shift and go to state 26
    FALSE           shift and go to state 27
    NAME            shift and go to state 69
    LPAREN          shift and go to state 70

    math                           shift and go to state 62

state 71

    (46) math -> NOT math .
    (33) math -> math . MULTIPLY math
    (34) math -> math . DIVIDE math
    (35) math -> math . MODULO math
    (36) math -> math . PLUS math
    (37) math -> math . MINUS math
    (38) math -> math . LD math
    (39) math -> math . LDEQ math
    (40) math -> math . GD math
    (41) math -> math . GDEQ math
    (42) math -> math . EQUALEQUAL math
    (43) math -> math . NOTEQ math
    (44) math -> math . AND math
    (45) math -> math . OR math

    MULTIPLY        reduce using rule 46 (math -> NOT math .)
    DIVIDE          reduce using rule 46 (math -> NOT math .)
    MODULO          reduce using rule 46 (math -> NOT math .)
    PLUS            reduce using rule 46 (math -> NOT math .)
    MINUS           reduce using rule 46 (math -> NOT math .)
    LD              reduce using rule 46 (math -> NOT math .)
    LDEQ            reduce using rule 46 (math -> NOT math .)
    GD              reduce using rule 46 (math -> NOT math .)
    GDEQ            reduce using rule 46 (math -> NOT math .)
    EQUALEQUAL      reduce using rule 46 (math -> NOT math .)
    NOTEQ           reduce using rule 46 (math -> NOT math .)
    AND             reduce using rule 46 (math -> NOT math .)
    OR              reduce using rule 46 (math -> NOT math .)
    NEWLINE         reduce using rule 46 (math -> NOT math .)
    $end            reduce using rule 46 (math -> NOT math .)
    COMMA           reduce using rule 46 (math -> NOT math .)
    RBRACE          reduce using rule 46 (math -> NOT math .)
    RPAREN          reduce using rule 46 (math -> NOT math .)
    START           reduce using rule 46 (math -> NOT math .)
    STOP            reduce using rule 46 (math -> NOT math .)
    RETURN          reduce using rule 46 (math -> NOT math .)

  ! MULTIPLY        [ shift and go to state 36 ]
  ! DIVIDE          [ shift and go to state 37 ]
  ! MODULO          [ shift and go to state 38 ]
  ! PLUS            [ shift and go to state 39 ]
  ! MINUS           [ shift and go to state 40 ]
  ! LD              [ shift and go to state 41 ]
  ! LDEQ            [ shift and go to state 42 ]
  ! GD              [ shift and go to state 43 ]
  ! GDEQ            [ shift and go to state 44 ]
  ! EQUALEQUAL      [ shift and go to state 45 ]
  ! NOTEQ           [ shift and go to state 46 ]
  ! AND             [ shift and go to state 47 ]
  ! OR              [ shift and go to state 48 ]


state 72

    (27) output_print -> PRINT LPAREN . expression RPAREN
    (28) expression -> . NAME
    (31) expression -> . math
    (32) expression -> . str
    (62) expression -> . LBRACE int_type_array RBRACE
    (63) expression -> . LBRACE string_type_array RBRACE
    (33) math -> . math MULTIPLY math
    (34) math -> . math DIVIDE math
    (35) math -> . math MODULO math
    (36) math -> . math PLUS math
    (37) math -> . math MINUS math
    (38) math -> . math LD math
    (39) math -> . math LDEQ math
    (40) math -> . math GD math
    (41) math -> . math GDEQ math
    (42) math -> . math EQUALEQUAL math
    (43) math -> . math NOTEQ math
    (44) math -> . math AND math
    (45) math -> . math OR math
    (46) math -> . NOT math
    (47) math -> . MINUS math
    (48) math -> . INT
    (49) math -> . FLOAT
    (50) math -> . TRUE
    (51) math -> . FALSE
    (60) math -> . NAME
    (68) math -> . LPAREN math RPAREN
    (52) str -> . str PLUS str
    (53) str -> . str LD str
    (54) str -> . str LDEQ str
    (55) str -> . str GD str
    (56) str -> . str GDEQ str
    (57) str -> . str EQUALEQUAL str
    (58) str -> . str NOTEQ str
    (59) str -> . STRING
    (61) str -> . NAME
    (69) str -> . LPAREN str RPAREN

    NAME            shift and go to state 65
    LBRACE          shift and go to state 15
    NOT             shift and go to state 23
    MINUS           shift and go to state 22
    INT             shift and go to state 24
    FLOAT           shift and go to state 25
    TRUE            shift and go to state 26
    FALSE           shift and go to state 27
    LPAREN          shift and go to state 17
    STRING          shift and go to state 28

    expression                     shift and go to state 109
    math                           shift and go to state 13
    str                            shift and go to state 14

state 73

    (3) language -> language NEWLINE line .

    NEWLINE         reduce using rule 3 (language -> language NEWLINE line .)
    $end            reduce using rule 3 (language -> language NEWLINE line .)
    STOP            reduce using rule 3 (language -> language NEWLINE line .)
    RETURN          reduce using rule 3 (language -> language NEWLINE line .)


state 74

    (12) line -> empty .

    NEWLINE         reduce using rule 12 (line -> empty .)
    $end            reduce using rule 12 (line -> empty .)
    STOP            reduce using rule 12 (line -> empty .)
    RETURN          reduce using rule 12 (line -> empty .)


state 75

    (30) var_assign -> NAME EQUALS expression .

    NEWLINE         reduce using rule 30 (var_assign -> NAME EQUALS expression .)
    $end            reduce using rule 30 (var_assign -> NAME EQUALS expression .)
    STOP            reduce using rule 30 (var_assign -> NAME EQUALS expression .)
    RETURN          reduce using rule 30 (var_assign -> NAME EQUALS expression .)


state 76

    (33) math -> math MULTIPLY math .
    (33) math -> math . MULTIPLY math
    (34) math -> math . DIVIDE math
    (35) math -> math . MODULO math
    (36) math -> math . PLUS math
    (37) math -> math . MINUS math
    (38) math -> math . LD math
    (39) math -> math . LDEQ math
    (40) math -> math . GD math
    (41) math -> math . GDEQ math
    (42) math -> math . EQUALEQUAL math
    (43) math -> math . NOTEQ math
    (44) math -> math . AND math
    (45) math -> math . OR math

    MULTIPLY        reduce using rule 33 (math -> math MULTIPLY math .)
    DIVIDE          reduce using rule 33 (math -> math MULTIPLY math .)
    MODULO          reduce using rule 33 (math -> math MULTIPLY math .)
    PLUS            reduce using rule 33 (math -> math MULTIPLY math .)
    MINUS           reduce using rule 33 (math -> math MULTIPLY math .)
    LD              reduce using rule 33 (math -> math MULTIPLY math .)
    LDEQ            reduce using rule 33 (math -> math MULTIPLY math .)
    GD              reduce using rule 33 (math -> math MULTIPLY math .)
    GDEQ            reduce using rule 33 (math -> math MULTIPLY math .)
    EQUALEQUAL      reduce using rule 33 (math -> math MULTIPLY math .)
    NOTEQ           reduce using rule 33 (math -> math MULTIPLY math .)
    AND             reduce using rule 33 (math -> math MULTIPLY math .)
    OR              reduce using rule 33 (math -> math MULTIPLY math .)
    NEWLINE         reduce using rule 33 (math -> math MULTIPLY math .)
    $end            reduce using rule 33 (math -> math MULTIPLY math .)
    COMMA           reduce using rule 33 (math -> math MULTIPLY math .)
    RBRACE          reduce using rule 33 (math -> math MULTIPLY math .)
    RPAREN          reduce using rule 33 (math -> math MULTIPLY math .)
    START           reduce using rule 33 (math -> math MULTIPLY math .)
    STOP            reduce using rule 33 (math -> math MULTIPLY math .)
    RETURN          reduce using rule 33 (math -> math MULTIPLY math .)

  ! MULTIPLY        [ shift and go to state 36 ]
  ! DIVIDE          [ shift and go to state 37 ]
  ! MODULO          [ shift and go to state 38 ]
  ! PLUS            [ shift and go to state 39 ]
  ! MINUS           [ shift and go to state 40 ]
  ! LD              [ shift and go to state 41 ]
  ! LDEQ            [ shift and go to state 42 ]
  ! GD              [ shift and go to state 43 ]
  ! GDEQ            [ shift and go to state 44 ]
  ! EQUALEQUAL      [ shift and go to state 45 ]
  ! NOTEQ           [ shift and go to state 46 ]
  ! AND             [ shift and go to state 47 ]
  ! OR              [ shift and go to state 48 ]


state 77

    (34) math -> math DIVIDE math .
    (33) math -> math . MULTIPLY math
    (34) math -> math . DIVIDE math
    (35) math -> math . MODULO math
    (36) math -> math . PLUS math
    (37) math -> math . MINUS math
    (38) math -> math . LD math
    (39) math -> math . LDEQ math
    (40) math -> math . GD math
    (41) math -> math . GDEQ math
    (42) math -> math . EQUALEQUAL math
    (43) math -> math . NOTEQ math
    (44) math -> math . AND math
    (45) math -> math . OR math

    MULTIPLY        reduce using rule 34 (math -> math DIVIDE math .)
    DIVIDE          reduce using rule 34 (math -> math DIVIDE math .)
    MODULO          reduce using rule 34 (math -> math DIVIDE math .)
    PLUS            reduce using rule 34 (math -> math DIVIDE math .)
    MINUS           reduce using rule 34 (math -> math DIVIDE math .)
    LD              reduce using rule 34 (math -> math DIVIDE math .)
    LDEQ            reduce using rule 34 (math -> math DIVIDE math .)
    GD              reduce using rule 34 (math -> math DIVIDE math .)
    GDEQ            reduce using rule 34 (math -> math DIVIDE math .)
    EQUALEQUAL      reduce using rule 34 (math -> math DIVIDE math .)
    NOTEQ           reduce using rule 34 (math -> math DIVIDE math .)
    AND             reduce using rule 34 (math -> math DIVIDE math .)
    OR              reduce using rule 34 (math -> math DIVIDE math .)
    NEWLINE         reduce using rule 34 (math -> math DIVIDE math .)
    $end            reduce using rule 34 (math -> math DIVIDE math .)
    COMMA           reduce using rule 34 (math -> math DIVIDE math .)
    RBRACE          reduce using rule 34 (math -> math DIVIDE math .)
    RPAREN          reduce using rule 34 (math -> math DIVIDE math .)
    START           reduce using rule 34 (math -> math DIVIDE math .)
    STOP            reduce using rule 34 (math -> math DIVIDE math .)
    RETURN          reduce using rule 34 (math -> math DIVIDE math .)

  ! MULTIPLY        [ shift and go to state 36 ]
  ! DIVIDE          [ shift and go to state 37 ]
  ! MODULO          [ shift and go to state 38 ]
  ! PLUS            [ shift and go to state 39 ]
  ! MINUS           [ shift and go to state 40 ]
  ! LD              [ shift and go to state 41 ]
  ! LDEQ            [ shift and go to state 42 ]
  ! GD              [ shift and go to state 43 ]
  ! GDEQ            [ shift and go to state 44 ]
  ! EQUALEQUAL      [ shift and go to state 45 ]
  ! NOTEQ           [ shift and go to state 46 ]
  ! AND             [ shift and go to state 47 ]
  ! OR              [ shift and go to state 48 ]


state 78

    (35) math -> math MODULO math .
    (33) math -> math . MULTIPLY math
    (34) math -> math . DIVIDE math
    (35) math -> math . MODULO math
    (36) math -> math . PLUS math
    (37) math -> math . MINUS math
    (38) math -> math . LD math
    (39) math -> math . LDEQ math
    (40) math -> math . GD math
    (41) math -> math . GDEQ math
    (42) math -> math . EQUALEQUAL math
    (43) math -> math . NOTEQ math
    (44) math -> math . AND math
    (45) math -> math . OR math

    MULTIPLY        reduce using rule 35 (math -> math MODULO math .)
    DIVIDE          reduce using rule 35 (math -> math MODULO math .)
    MODULO          reduce using rule 35 (math -> math MODULO math .)
    PLUS            reduce using rule 35 (math -> math MODULO math .)
    MINUS           reduce using rule 35 (math -> math MODULO math .)
    LD              reduce using rule 35 (math -> math MODULO math .)
    LDEQ            reduce using rule 35 (math -> math MODULO math .)
    GD              reduce using rule 35 (math -> math MODULO math .)
    GDEQ            reduce using rule 35 (math -> math MODULO math .)
    EQUALEQUAL      reduce using rule 35 (math -> math MODULO math .)
    NOTEQ           reduce using rule 35 (math -> math MODULO math .)
    AND             reduce using rule 35 (math -> math MODULO math .)
    OR              reduce using rule 35 (math -> math MODULO math .)
    NEWLINE         reduce using rule 35 (math -> math MODULO math .)
    $end            reduce using rule 35 (math -> math MODULO math .)
    COMMA           reduce using rule 35 (math -> math MODULO math .)
    RBRACE          reduce using rule 35 (math -> math MODULO math .)
    RPAREN          reduce using rule 35 (math -> math MODULO math .)
    START           reduce using rule 35 (math -> math MODULO math .)
    STOP            reduce using rule 35 (math -> math MODULO math .)
    RETURN          reduce using rule 35 (math -> math MODULO math .)

  ! MULTIPLY        [ shift and go to state 36 ]
  ! DIVIDE          [ shift and go to state 37 ]
  ! MODULO          [ shift and go to state 38 ]
  ! PLUS            [ shift and go to state 39 ]
  ! MINUS           [ shift and go to state 40 ]
  ! LD              [ shift and go to state 41 ]
  ! LDEQ            [ shift and go to state 42 ]
  ! GD              [ shift and go to state 43 ]
  ! GDEQ            [ shift and go to state 44 ]
  ! EQUALEQUAL      [ shift and go to state 45 ]
  ! NOTEQ           [ shift and go to state 46 ]
  ! AND             [ shift and go to state 47 ]
  ! OR              [ shift and go to state 48 ]


state 79

    (36) math -> math PLUS math .
    (33) math -> math . MULTIPLY math
    (34) math -> math . DIVIDE math
    (35) math -> math . MODULO math
    (36) math -> math . PLUS math
    (37) math -> math . MINUS math
    (38) math -> math . LD math
    (39) math -> math . LDEQ math
    (40) math -> math . GD math
    (41) math -> math . GDEQ math
    (42) math -> math . EQUALEQUAL math
    (43) math -> math . NOTEQ math
    (44) math -> math . AND math
    (45) math -> math . OR math

    PLUS            reduce using rule 36 (math -> math PLUS math .)
    MINUS           reduce using rule 36 (math -> math PLUS math .)
    LD              reduce using rule 36 (math -> math PLUS math .)
    LDEQ            reduce using rule 36 (math -> math PLUS math .)
    GD              reduce using rule 36 (math -> math PLUS math .)
    GDEQ            reduce using rule 36 (math -> math PLUS math .)
    EQUALEQUAL      reduce using rule 36 (math -> math PLUS math .)
    NOTEQ           reduce using rule 36 (math -> math PLUS math .)
    AND             reduce using rule 36 (math -> math PLUS math .)
    OR              reduce using rule 36 (math -> math PLUS math .)
    NEWLINE         reduce using rule 36 (math -> math PLUS math .)
    $end            reduce using rule 36 (math -> math PLUS math .)
    COMMA           reduce using rule 36 (math -> math PLUS math .)
    RBRACE          reduce using rule 36 (math -> math PLUS math .)
    RPAREN          reduce using rule 36 (math -> math PLUS math .)
    START           reduce using rule 36 (math -> math PLUS math .)
    STOP            reduce using rule 36 (math -> math PLUS math .)
    RETURN          reduce using rule 36 (math -> math PLUS math .)
    MULTIPLY        shift and go to state 36
    DIVIDE          shift and go to state 37
    MODULO          shift and go to state 38

  ! MULTIPLY        [ reduce using rule 36 (math -> math PLUS math .) ]
  ! DIVIDE          [ reduce using rule 36 (math -> math PLUS math .) ]
  ! MODULO          [ reduce using rule 36 (math -> math PLUS math .) ]
  ! PLUS            [ shift and go to state 39 ]
  ! MINUS           [ shift and go to state 40 ]
  ! LD              [ shift and go to state 41 ]
  ! LDEQ            [ shift and go to state 42 ]
  ! GD              [ shift and go to state 43 ]
  ! GDEQ            [ shift and go to state 44 ]
  ! EQUALEQUAL      [ shift and go to state 45 ]
  ! NOTEQ           [ shift and go to state 46 ]
  ! AND             [ shift and go to state 47 ]
  ! OR              [ shift and go to state 48 ]


state 80

    (37) math -> math MINUS math .
    (33) math -> math . MULTIPLY math
    (34) math -> math . DIVIDE math
    (35) math -> math . MODULO math
    (36) math -> math . PLUS math
    (37) math -> math . MINUS math
    (38) math -> math . LD math
    (39) math -> math . LDEQ math
    (40) math -> math . GD math
    (41) math -> math . GDEQ math
    (42) math -> math . EQUALEQUAL math
    (43) math -> math . NOTEQ math
    (44) math -> math . AND math
    (45) math -> math . OR math

    PLUS            reduce using rule 37 (math -> math MINUS math .)
    MINUS           reduce using rule 37 (math -> math MINUS math .)
    LD              reduce using rule 37 (math -> math MINUS math .)
    LDEQ            reduce using rule 37 (math -> math MINUS math .)
    GD              reduce using rule 37 (math -> math MINUS math .)
    GDEQ            reduce using rule 37 (math -> math MINUS math .)
    EQUALEQUAL      reduce using rule 37 (math -> math MINUS math .)
    NOTEQ           reduce using rule 37 (math -> math MINUS math .)
    AND             reduce using rule 37 (math -> math MINUS math .)
    OR              reduce using rule 37 (math -> math MINUS math .)
    NEWLINE         reduce using rule 37 (math -> math MINUS math .)
    $end            reduce using rule 37 (math -> math MINUS math .)
    COMMA           reduce using rule 37 (math -> math MINUS math .)
    RBRACE          reduce using rule 37 (math -> math MINUS math .)
    RPAREN          reduce using rule 37 (math -> math MINUS math .)
    START           reduce using rule 37 (math -> math MINUS math .)
    STOP            reduce using rule 37 (math -> math MINUS math .)
    RETURN          reduce using rule 37 (math -> math MINUS math .)
    MULTIPLY        shift and go to state 36
    DIVIDE          shift and go to state 37
    MODULO          shift and go to state 38

  ! MULTIPLY        [ reduce using rule 37 (math -> math MINUS math .) ]
  ! DIVIDE          [ reduce using rule 37 (math -> math MINUS math .) ]
  ! MODULO          [ reduce using rule 37 (math -> math MINUS math .) ]
  ! PLUS            [ shift and go to state 39 ]
  ! MINUS           [ shift and go to state 40 ]
  ! LD              [ shift and go to state 41 ]
  ! LDEQ            [ shift and go to state 42 ]
  ! GD              [ shift and go to state 43 ]
  ! GDEQ            [ shift and go to state 44 ]
  ! EQUALEQUAL      [ shift and go to state 45 ]
  ! NOTEQ           [ shift and go to state 46 ]
  ! AND             [ shift and go to state 47 ]
  ! OR              [ shift and go to state 48 ]


state 81

    (38) math -> math LD math .
    (33) math -> math . MULTIPLY math
    (34) math -> math . DIVIDE math
    (35) math -> math . MODULO math
    (36) math -> math . PLUS math
    (37) math -> math . MINUS math
    (38) math -> math . LD math
    (39) math -> math . LDEQ math
    (40) math -> math . GD math
    (41) math -> math . GDEQ math
    (42) math -> math . EQUALEQUAL math
    (43) math -> math . NOTEQ math
    (44) math -> math . AND math
    (45) math -> math . OR math

    LD              reduce using rule 38 (math -> math LD math .)
    LDEQ            reduce using rule 38 (math -> math LD math .)
    GD              reduce using rule 38 (math -> math LD math .)
    GDEQ            reduce using rule 38 (math -> math LD math .)
    EQUALEQUAL      reduce using rule 38 (math -> math LD math .)
    NOTEQ           reduce using rule 38 (math -> math LD math .)
    AND             reduce using rule 38 (math -> math LD math .)
    OR              reduce using rule 38 (math -> math LD math .)
    NEWLINE         reduce using rule 38 (math -> math LD math .)
    $end            reduce using rule 38 (math -> math LD math .)
    COMMA           reduce using rule 38 (math -> math LD math .)
    RBRACE          reduce using rule 38 (math -> math LD math .)
    RPAREN          reduce using rule 38 (math -> math LD math .)
    START           reduce using rule 38 (math -> math LD math .)
    STOP            reduce using rule 38 (math -> math LD math .)
    RETURN          reduce using rule 38 (math -> math LD math .)
    MULTIPLY        shift and go to state 36
    DIVIDE          shift and go to state 37
    MODULO          shift and go to state 38
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40

  ! MULTIPLY        [ reduce using rule 38 (math -> math LD math .) ]
  ! DIVIDE          [ reduce using rule 38 (math -> math LD math .) ]
  ! MODULO          [ reduce using rule 38 (math -> math LD math .) ]
  ! PLUS            [ reduce using rule 38 (math -> math LD math .) ]
  ! MINUS           [ reduce using rule 38 (math -> math LD math .) ]
  ! LD              [ shift and go to state 41 ]
  ! LDEQ            [ shift and go to state 42 ]
  ! GD              [ shift and go to state 43 ]
  ! GDEQ            [ shift and go to state 44 ]
  ! EQUALEQUAL      [ shift and go to state 45 ]
  ! NOTEQ           [ shift and go to state 46 ]
  ! AND             [ shift and go to state 47 ]
  ! OR              [ shift and go to state 48 ]


state 82

    (39) math -> math LDEQ math .
    (33) math -> math . MULTIPLY math
    (34) math -> math . DIVIDE math
    (35) math -> math . MODULO math
    (36) math -> math . PLUS math
    (37) math -> math . MINUS math
    (38) math -> math . LD math
    (39) math -> math . LDEQ math
    (40) math -> math . GD math
    (41) math -> math . GDEQ math
    (42) math -> math . EQUALEQUAL math
    (43) math -> math . NOTEQ math
    (44) math -> math . AND math
    (45) math -> math . OR math

    LD              reduce using rule 39 (math -> math LDEQ math .)
    LDEQ            reduce using rule 39 (math -> math LDEQ math .)
    GD              reduce using rule 39 (math -> math LDEQ math .)
    GDEQ            reduce using rule 39 (math -> math LDEQ math .)
    EQUALEQUAL      reduce using rule 39 (math -> math LDEQ math .)
    NOTEQ           reduce using rule 39 (math -> math LDEQ math .)
    AND             reduce using rule 39 (math -> math LDEQ math .)
    OR              reduce using rule 39 (math -> math LDEQ math .)
    NEWLINE         reduce using rule 39 (math -> math LDEQ math .)
    $end            reduce using rule 39 (math -> math LDEQ math .)
    COMMA           reduce using rule 39 (math -> math LDEQ math .)
    RBRACE          reduce using rule 39 (math -> math LDEQ math .)
    RPAREN          reduce using rule 39 (math -> math LDEQ math .)
    START           reduce using rule 39 (math -> math LDEQ math .)
    STOP            reduce using rule 39 (math -> math LDEQ math .)
    RETURN          reduce using rule 39 (math -> math LDEQ math .)
    MULTIPLY        shift and go to state 36
    DIVIDE          shift and go to state 37
    MODULO          shift and go to state 38
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40

  ! MULTIPLY        [ reduce using rule 39 (math -> math LDEQ math .) ]
  ! DIVIDE          [ reduce using rule 39 (math -> math LDEQ math .) ]
  ! MODULO          [ reduce using rule 39 (math -> math LDEQ math .) ]
  ! PLUS            [ reduce using rule 39 (math -> math LDEQ math .) ]
  ! MINUS           [ reduce using rule 39 (math -> math LDEQ math .) ]
  ! LD              [ shift and go to state 41 ]
  ! LDEQ            [ shift and go to state 42 ]
  ! GD              [ shift and go to state 43 ]
  ! GDEQ            [ shift and go to state 44 ]
  ! EQUALEQUAL      [ shift and go to state 45 ]
  ! NOTEQ           [ shift and go to state 46 ]
  ! AND             [ shift and go to state 47 ]
  ! OR              [ shift and go to state 48 ]


state 83

    (40) math -> math GD math .
    (33) math -> math . MULTIPLY math
    (34) math -> math . DIVIDE math
    (35) math -> math . MODULO math
    (36) math -> math . PLUS math
    (37) math -> math . MINUS math
    (38) math -> math . LD math
    (39) math -> math . LDEQ math
    (40) math -> math . GD math
    (41) math -> math . GDEQ math
    (42) math -> math . EQUALEQUAL math
    (43) math -> math . NOTEQ math
    (44) math -> math . AND math
    (45) math -> math . OR math

    LD              reduce using rule 40 (math -> math GD math .)
    LDEQ            reduce using rule 40 (math -> math GD math .)
    GD              reduce using rule 40 (math -> math GD math .)
    GDEQ            reduce using rule 40 (math -> math GD math .)
    EQUALEQUAL      reduce using rule 40 (math -> math GD math .)
    NOTEQ           reduce using rule 40 (math -> math GD math .)
    AND             reduce using rule 40 (math -> math GD math .)
    OR              reduce using rule 40 (math -> math GD math .)
    NEWLINE         reduce using rule 40 (math -> math GD math .)
    $end            reduce using rule 40 (math -> math GD math .)
    COMMA           reduce using rule 40 (math -> math GD math .)
    RBRACE          reduce using rule 40 (math -> math GD math .)
    RPAREN          reduce using rule 40 (math -> math GD math .)
    START           reduce using rule 40 (math -> math GD math .)
    STOP            reduce using rule 40 (math -> math GD math .)
    RETURN          reduce using rule 40 (math -> math GD math .)
    MULTIPLY        shift and go to state 36
    DIVIDE          shift and go to state 37
    MODULO          shift and go to state 38
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40

  ! MULTIPLY        [ reduce using rule 40 (math -> math GD math .) ]
  ! DIVIDE          [ reduce using rule 40 (math -> math GD math .) ]
  ! MODULO          [ reduce using rule 40 (math -> math GD math .) ]
  ! PLUS            [ reduce using rule 40 (math -> math GD math .) ]
  ! MINUS           [ reduce using rule 40 (math -> math GD math .) ]
  ! LD              [ shift and go to state 41 ]
  ! LDEQ            [ shift and go to state 42 ]
  ! GD              [ shift and go to state 43 ]
  ! GDEQ            [ shift and go to state 44 ]
  ! EQUALEQUAL      [ shift and go to state 45 ]
  ! NOTEQ           [ shift and go to state 46 ]
  ! AND             [ shift and go to state 47 ]
  ! OR              [ shift and go to state 48 ]


state 84

    (41) math -> math GDEQ math .
    (33) math -> math . MULTIPLY math
    (34) math -> math . DIVIDE math
    (35) math -> math . MODULO math
    (36) math -> math . PLUS math
    (37) math -> math . MINUS math
    (38) math -> math . LD math
    (39) math -> math . LDEQ math
    (40) math -> math . GD math
    (41) math -> math . GDEQ math
    (42) math -> math . EQUALEQUAL math
    (43) math -> math . NOTEQ math
    (44) math -> math . AND math
    (45) math -> math . OR math

    LD              reduce using rule 41 (math -> math GDEQ math .)
    LDEQ            reduce using rule 41 (math -> math GDEQ math .)
    GD              reduce using rule 41 (math -> math GDEQ math .)
    GDEQ            reduce using rule 41 (math -> math GDEQ math .)
    EQUALEQUAL      reduce using rule 41 (math -> math GDEQ math .)
    NOTEQ           reduce using rule 41 (math -> math GDEQ math .)
    AND             reduce using rule 41 (math -> math GDEQ math .)
    OR              reduce using rule 41 (math -> math GDEQ math .)
    NEWLINE         reduce using rule 41 (math -> math GDEQ math .)
    $end            reduce using rule 41 (math -> math GDEQ math .)
    COMMA           reduce using rule 41 (math -> math GDEQ math .)
    RBRACE          reduce using rule 41 (math -> math GDEQ math .)
    RPAREN          reduce using rule 41 (math -> math GDEQ math .)
    START           reduce using rule 41 (math -> math GDEQ math .)
    STOP            reduce using rule 41 (math -> math GDEQ math .)
    RETURN          reduce using rule 41 (math -> math GDEQ math .)
    MULTIPLY        shift and go to state 36
    DIVIDE          shift and go to state 37
    MODULO          shift and go to state 38
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40

  ! MULTIPLY        [ reduce using rule 41 (math -> math GDEQ math .) ]
  ! DIVIDE          [ reduce using rule 41 (math -> math GDEQ math .) ]
  ! MODULO          [ reduce using rule 41 (math -> math GDEQ math .) ]
  ! PLUS            [ reduce using rule 41 (math -> math GDEQ math .) ]
  ! MINUS           [ reduce using rule 41 (math -> math GDEQ math .) ]
  ! LD              [ shift and go to state 41 ]
  ! LDEQ            [ shift and go to state 42 ]
  ! GD              [ shift and go to state 43 ]
  ! GDEQ            [ shift and go to state 44 ]
  ! EQUALEQUAL      [ shift and go to state 45 ]
  ! NOTEQ           [ shift and go to state 46 ]
  ! AND             [ shift and go to state 47 ]
  ! OR              [ shift and go to state 48 ]


state 85

    (42) math -> math EQUALEQUAL math .
    (33) math -> math . MULTIPLY math
    (34) math -> math . DIVIDE math
    (35) math -> math . MODULO math
    (36) math -> math . PLUS math
    (37) math -> math . MINUS math
    (38) math -> math . LD math
    (39) math -> math . LDEQ math
    (40) math -> math . GD math
    (41) math -> math . GDEQ math
    (42) math -> math . EQUALEQUAL math
    (43) math -> math . NOTEQ math
    (44) math -> math . AND math
    (45) math -> math . OR math

    EQUALEQUAL      reduce using rule 42 (math -> math EQUALEQUAL math .)
    NOTEQ           reduce using rule 42 (math -> math EQUALEQUAL math .)
    AND             reduce using rule 42 (math -> math EQUALEQUAL math .)
    OR              reduce using rule 42 (math -> math EQUALEQUAL math .)
    NEWLINE         reduce using rule 42 (math -> math EQUALEQUAL math .)
    $end            reduce using rule 42 (math -> math EQUALEQUAL math .)
    COMMA           reduce using rule 42 (math -> math EQUALEQUAL math .)
    RBRACE          reduce using rule 42 (math -> math EQUALEQUAL math .)
    RPAREN          reduce using rule 42 (math -> math EQUALEQUAL math .)
    START           reduce using rule 42 (math -> math EQUALEQUAL math .)
    STOP            reduce using rule 42 (math -> math EQUALEQUAL math .)
    RETURN          reduce using rule 42 (math -> math EQUALEQUAL math .)
    MULTIPLY        shift and go to state 36
    DIVIDE          shift and go to state 37
    MODULO          shift and go to state 38
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    LD              shift and go to state 41
    LDEQ            shift and go to state 42
    GD              shift and go to state 43
    GDEQ            shift and go to state 44

  ! MULTIPLY        [ reduce using rule 42 (math -> math EQUALEQUAL math .) ]
  ! DIVIDE          [ reduce using rule 42 (math -> math EQUALEQUAL math .) ]
  ! MODULO          [ reduce using rule 42 (math -> math EQUALEQUAL math .) ]
  ! PLUS            [ reduce using rule 42 (math -> math EQUALEQUAL math .) ]
  ! MINUS           [ reduce using rule 42 (math -> math EQUALEQUAL math .) ]
  ! LD              [ reduce using rule 42 (math -> math EQUALEQUAL math .) ]
  ! LDEQ            [ reduce using rule 42 (math -> math EQUALEQUAL math .) ]
  ! GD              [ reduce using rule 42 (math -> math EQUALEQUAL math .) ]
  ! GDEQ            [ reduce using rule 42 (math -> math EQUALEQUAL math .) ]
  ! EQUALEQUAL      [ shift and go to state 45 ]
  ! NOTEQ           [ shift and go to state 46 ]
  ! AND             [ shift and go to state 47 ]
  ! OR              [ shift and go to state 48 ]


state 86

    (43) math -> math NOTEQ math .
    (33) math -> math . MULTIPLY math
    (34) math -> math . DIVIDE math
    (35) math -> math . MODULO math
    (36) math -> math . PLUS math
    (37) math -> math . MINUS math
    (38) math -> math . LD math
    (39) math -> math . LDEQ math
    (40) math -> math . GD math
    (41) math -> math . GDEQ math
    (42) math -> math . EQUALEQUAL math
    (43) math -> math . NOTEQ math
    (44) math -> math . AND math
    (45) math -> math . OR math

    EQUALEQUAL      reduce using rule 43 (math -> math NOTEQ math .)
    NOTEQ           reduce using rule 43 (math -> math NOTEQ math .)
    AND             reduce using rule 43 (math -> math NOTEQ math .)
    OR              reduce using rule 43 (math -> math NOTEQ math .)
    NEWLINE         reduce using rule 43 (math -> math NOTEQ math .)
    $end            reduce using rule 43 (math -> math NOTEQ math .)
    COMMA           reduce using rule 43 (math -> math NOTEQ math .)
    RBRACE          reduce using rule 43 (math -> math NOTEQ math .)
    RPAREN          reduce using rule 43 (math -> math NOTEQ math .)
    START           reduce using rule 43 (math -> math NOTEQ math .)
    STOP            reduce using rule 43 (math -> math NOTEQ math .)
    RETURN          reduce using rule 43 (math -> math NOTEQ math .)
    MULTIPLY        shift and go to state 36
    DIVIDE          shift and go to state 37
    MODULO          shift and go to state 38
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    LD              shift and go to state 41
    LDEQ            shift and go to state 42
    GD              shift and go to state 43
    GDEQ            shift and go to state 44

  ! MULTIPLY        [ reduce using rule 43 (math -> math NOTEQ math .) ]
  ! DIVIDE          [ reduce using rule 43 (math -> math NOTEQ math .) ]
  ! MODULO          [ reduce using rule 43 (math -> math NOTEQ math .) ]
  ! PLUS            [ reduce using rule 43 (math -> math NOTEQ math .) ]
  ! MINUS           [ reduce using rule 43 (math -> math NOTEQ math .) ]
  ! LD              [ reduce using rule 43 (math -> math NOTEQ math .) ]
  ! LDEQ            [ reduce using rule 43 (math -> math NOTEQ math .) ]
  ! GD              [ reduce using rule 43 (math -> math NOTEQ math .) ]
  ! GDEQ            [ reduce using rule 43 (math -> math NOTEQ math .) ]
  ! EQUALEQUAL      [ shift and go to state 45 ]
  ! NOTEQ           [ shift and go to state 46 ]
  ! AND             [ shift and go to state 47 ]
  ! OR              [ shift and go to state 48 ]


state 87

    (44) math -> math AND math .
    (33) math -> math . MULTIPLY math
    (34) math -> math . DIVIDE math
    (35) math -> math . MODULO math
    (36) math -> math . PLUS math
    (37) math -> math . MINUS math
    (38) math -> math . LD math
    (39) math -> math . LDEQ math
    (40) math -> math . GD math
    (41) math -> math . GDEQ math
    (42) math -> math . EQUALEQUAL math
    (43) math -> math . NOTEQ math
    (44) math -> math . AND math
    (45) math -> math . OR math

    AND             reduce using rule 44 (math -> math AND math .)
    OR              reduce using rule 44 (math -> math AND math .)
    NEWLINE         reduce using rule 44 (math -> math AND math .)
    $end            reduce using rule 44 (math -> math AND math .)
    COMMA           reduce using rule 44 (math -> math AND math .)
    RBRACE          reduce using rule 44 (math -> math AND math .)
    RPAREN          reduce using rule 44 (math -> math AND math .)
    START           reduce using rule 44 (math -> math AND math .)
    STOP            reduce using rule 44 (math -> math AND math .)
    RETURN          reduce using rule 44 (math -> math AND math .)
    MULTIPLY        shift and go to state 36
    DIVIDE          shift and go to state 37
    MODULO          shift and go to state 38
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    LD              shift and go to state 41
    LDEQ            shift and go to state 42
    GD              shift and go to state 43
    GDEQ            shift and go to state 44
    EQUALEQUAL      shift and go to state 45
    NOTEQ           shift and go to state 46

  ! MULTIPLY        [ reduce using rule 44 (math -> math AND math .) ]
  ! DIVIDE          [ reduce using rule 44 (math -> math AND math .) ]
  ! MODULO          [ reduce using rule 44 (math -> math AND math .) ]
  ! PLUS            [ reduce using rule 44 (math -> math AND math .) ]
  ! MINUS           [ reduce using rule 44 (math -> math AND math .) ]
  ! LD              [ reduce using rule 44 (math -> math AND math .) ]
  ! LDEQ            [ reduce using rule 44 (math -> math AND math .) ]
  ! GD              [ reduce using rule 44 (math -> math AND math .) ]
  ! GDEQ            [ reduce using rule 44 (math -> math AND math .) ]
  ! EQUALEQUAL      [ reduce using rule 44 (math -> math AND math .) ]
  ! NOTEQ           [ reduce using rule 44 (math -> math AND math .) ]
  ! AND             [ shift and go to state 47 ]
  ! OR              [ shift and go to state 48 ]


state 88

    (45) math -> math OR math .
    (33) math -> math . MULTIPLY math
    (34) math -> math . DIVIDE math
    (35) math -> math . MODULO math
    (36) math -> math . PLUS math
    (37) math -> math . MINUS math
    (38) math -> math . LD math
    (39) math -> math . LDEQ math
    (40) math -> math . GD math
    (41) math -> math . GDEQ math
    (42) math -> math . EQUALEQUAL math
    (43) math -> math . NOTEQ math
    (44) math -> math . AND math
    (45) math -> math . OR math

    AND             reduce using rule 45 (math -> math OR math .)
    OR              reduce using rule 45 (math -> math OR math .)
    NEWLINE         reduce using rule 45 (math -> math OR math .)
    $end            reduce using rule 45 (math -> math OR math .)
    COMMA           reduce using rule 45 (math -> math OR math .)
    RBRACE          reduce using rule 45 (math -> math OR math .)
    RPAREN          reduce using rule 45 (math -> math OR math .)
    START           reduce using rule 45 (math -> math OR math .)
    STOP            reduce using rule 45 (math -> math OR math .)
    RETURN          reduce using rule 45 (math -> math OR math .)
    MULTIPLY        shift and go to state 36
    DIVIDE          shift and go to state 37
    MODULO          shift and go to state 38
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    LD              shift and go to state 41
    LDEQ            shift and go to state 42
    GD              shift and go to state 43
    GDEQ            shift and go to state 44
    EQUALEQUAL      shift and go to state 45
    NOTEQ           shift and go to state 46

  ! MULTIPLY        [ reduce using rule 45 (math -> math OR math .) ]
  ! DIVIDE          [ reduce using rule 45 (math -> math OR math .) ]
  ! MODULO          [ reduce using rule 45 (math -> math OR math .) ]
  ! PLUS            [ reduce using rule 45 (math -> math OR math .) ]
  ! MINUS           [ reduce using rule 45 (math -> math OR math .) ]
  ! LD              [ reduce using rule 45 (math -> math OR math .) ]
  ! LDEQ            [ reduce using rule 45 (math -> math OR math .) ]
  ! GD              [ reduce using rule 45 (math -> math OR math .) ]
  ! GDEQ            [ reduce using rule 45 (math -> math OR math .) ]
  ! EQUALEQUAL      [ reduce using rule 45 (math -> math OR math .) ]
  ! NOTEQ           [ reduce using rule 45 (math -> math OR math .) ]
  ! AND             [ shift and go to state 47 ]
  ! OR              [ shift and go to state 48 ]


state 89

    (52) str -> str PLUS str .
    (52) str -> str . PLUS str
    (53) str -> str . LD str
    (54) str -> str . LDEQ str
    (55) str -> str . GD str
    (56) str -> str . GDEQ str
    (57) str -> str . EQUALEQUAL str
    (58) str -> str . NOTEQ str

    PLUS            reduce using rule 52 (str -> str PLUS str .)
    LD              reduce using rule 52 (str -> str PLUS str .)
    LDEQ            reduce using rule 52 (str -> str PLUS str .)
    GD              reduce using rule 52 (str -> str PLUS str .)
    GDEQ            reduce using rule 52 (str -> str PLUS str .)
    EQUALEQUAL      reduce using rule 52 (str -> str PLUS str .)
    NOTEQ           reduce using rule 52 (str -> str PLUS str .)
    NEWLINE         reduce using rule 52 (str -> str PLUS str .)
    $end            reduce using rule 52 (str -> str PLUS str .)
    COMMA           reduce using rule 52 (str -> str PLUS str .)
    RBRACE          reduce using rule 52 (str -> str PLUS str .)
    RPAREN          reduce using rule 52 (str -> str PLUS str .)
    START           reduce using rule 52 (str -> str PLUS str .)
    STOP            reduce using rule 52 (str -> str PLUS str .)
    RETURN          reduce using rule 52 (str -> str PLUS str .)

  ! PLUS            [ shift and go to state 49 ]
  ! LD              [ shift and go to state 50 ]
  ! LDEQ            [ shift and go to state 51 ]
  ! GD              [ shift and go to state 52 ]
  ! GDEQ            [ shift and go to state 53 ]
  ! EQUALEQUAL      [ shift and go to state 54 ]
  ! NOTEQ           [ shift and go to state 55 ]


state 90

    (61) str -> NAME .

    PLUS            reduce using rule 61 (str -> NAME .)
    LD              reduce using rule 61 (str -> NAME .)
    LDEQ            reduce using rule 61 (str -> NAME .)
    GD              reduce using rule 61 (str -> NAME .)
    GDEQ            reduce using rule 61 (str -> NAME .)
    EQUALEQUAL      reduce using rule 61 (str -> NAME .)
    NOTEQ           reduce using rule 61 (str -> NAME .)
    NEWLINE         reduce using rule 61 (str -> NAME .)
    $end            reduce using rule 61 (str -> NAME .)
    COMMA           reduce using rule 61 (str -> NAME .)
    RBRACE          reduce using rule 61 (str -> NAME .)
    RPAREN          reduce using rule 61 (str -> NAME .)
    START           reduce using rule 61 (str -> NAME .)
    STOP            reduce using rule 61 (str -> NAME .)
    RETURN          reduce using rule 61 (str -> NAME .)


state 91

    (69) str -> LPAREN . str RPAREN
    (52) str -> . str PLUS str
    (53) str -> . str LD str
    (54) str -> . str LDEQ str
    (55) str -> . str GD str
    (56) str -> . str GDEQ str
    (57) str -> . str EQUALEQUAL str
    (58) str -> . str NOTEQ str
    (59) str -> . STRING
    (61) str -> . NAME
    (69) str -> . LPAREN str RPAREN

    STRING          shift and go to state 28
    NAME            shift and go to state 90
    LPAREN          shift and go to state 91

    str                            shift and go to state 63

state 92

    (53) str -> str LD str .
    (52) str -> str . PLUS str
    (53) str -> str . LD str
    (54) str -> str . LDEQ str
    (55) str -> str . GD str
    (56) str -> str . GDEQ str
    (57) str -> str . EQUALEQUAL str
    (58) str -> str . NOTEQ str

    LD              reduce using rule 53 (str -> str LD str .)
    LDEQ            reduce using rule 53 (str -> str LD str .)
    GD              reduce using rule 53 (str -> str LD str .)
    GDEQ            reduce using rule 53 (str -> str LD str .)
    EQUALEQUAL      reduce using rule 53 (str -> str LD str .)
    NOTEQ           reduce using rule 53 (str -> str LD str .)
    NEWLINE         reduce using rule 53 (str -> str LD str .)
    $end            reduce using rule 53 (str -> str LD str .)
    COMMA           reduce using rule 53 (str -> str LD str .)
    RBRACE          reduce using rule 53 (str -> str LD str .)
    RPAREN          reduce using rule 53 (str -> str LD str .)
    START           reduce using rule 53 (str -> str LD str .)
    STOP            reduce using rule 53 (str -> str LD str .)
    RETURN          reduce using rule 53 (str -> str LD str .)
    PLUS            shift and go to state 49

  ! PLUS            [ reduce using rule 53 (str -> str LD str .) ]
  ! LD              [ shift and go to state 50 ]
  ! LDEQ            [ shift and go to state 51 ]
  ! GD              [ shift and go to state 52 ]
  ! GDEQ            [ shift and go to state 53 ]
  ! EQUALEQUAL      [ shift and go to state 54 ]
  ! NOTEQ           [ shift and go to state 55 ]


state 93

    (54) str -> str LDEQ str .
    (52) str -> str . PLUS str
    (53) str -> str . LD str
    (54) str -> str . LDEQ str
    (55) str -> str . GD str
    (56) str -> str . GDEQ str
    (57) str -> str . EQUALEQUAL str
    (58) str -> str . NOTEQ str

    LD              reduce using rule 54 (str -> str LDEQ str .)
    LDEQ            reduce using rule 54 (str -> str LDEQ str .)
    GD              reduce using rule 54 (str -> str LDEQ str .)
    GDEQ            reduce using rule 54 (str -> str LDEQ str .)
    EQUALEQUAL      reduce using rule 54 (str -> str LDEQ str .)
    NOTEQ           reduce using rule 54 (str -> str LDEQ str .)
    NEWLINE         reduce using rule 54 (str -> str LDEQ str .)
    $end            reduce using rule 54 (str -> str LDEQ str .)
    COMMA           reduce using rule 54 (str -> str LDEQ str .)
    RBRACE          reduce using rule 54 (str -> str LDEQ str .)
    RPAREN          reduce using rule 54 (str -> str LDEQ str .)
    START           reduce using rule 54 (str -> str LDEQ str .)
    STOP            reduce using rule 54 (str -> str LDEQ str .)
    RETURN          reduce using rule 54 (str -> str LDEQ str .)
    PLUS            shift and go to state 49

  ! PLUS            [ reduce using rule 54 (str -> str LDEQ str .) ]
  ! LD              [ shift and go to state 50 ]
  ! LDEQ            [ shift and go to state 51 ]
  ! GD              [ shift and go to state 52 ]
  ! GDEQ            [ shift and go to state 53 ]
  ! EQUALEQUAL      [ shift and go to state 54 ]
  ! NOTEQ           [ shift and go to state 55 ]


state 94

    (55) str -> str GD str .
    (52) str -> str . PLUS str
    (53) str -> str . LD str
    (54) str -> str . LDEQ str
    (55) str -> str . GD str
    (56) str -> str . GDEQ str
    (57) str -> str . EQUALEQUAL str
    (58) str -> str . NOTEQ str

    LD              reduce using rule 55 (str -> str GD str .)
    LDEQ            reduce using rule 55 (str -> str GD str .)
    GD              reduce using rule 55 (str -> str GD str .)
    GDEQ            reduce using rule 55 (str -> str GD str .)
    EQUALEQUAL      reduce using rule 55 (str -> str GD str .)
    NOTEQ           reduce using rule 55 (str -> str GD str .)
    NEWLINE         reduce using rule 55 (str -> str GD str .)
    $end            reduce using rule 55 (str -> str GD str .)
    COMMA           reduce using rule 55 (str -> str GD str .)
    RBRACE          reduce using rule 55 (str -> str GD str .)
    RPAREN          reduce using rule 55 (str -> str GD str .)
    START           reduce using rule 55 (str -> str GD str .)
    STOP            reduce using rule 55 (str -> str GD str .)
    RETURN          reduce using rule 55 (str -> str GD str .)
    PLUS            shift and go to state 49

  ! PLUS            [ reduce using rule 55 (str -> str GD str .) ]
  ! LD              [ shift and go to state 50 ]
  ! LDEQ            [ shift and go to state 51 ]
  ! GD              [ shift and go to state 52 ]
  ! GDEQ            [ shift and go to state 53 ]
  ! EQUALEQUAL      [ shift and go to state 54 ]
  ! NOTEQ           [ shift and go to state 55 ]


state 95

    (56) str -> str GDEQ str .
    (52) str -> str . PLUS str
    (53) str -> str . LD str
    (54) str -> str . LDEQ str
    (55) str -> str . GD str
    (56) str -> str . GDEQ str
    (57) str -> str . EQUALEQUAL str
    (58) str -> str . NOTEQ str

    LD              reduce using rule 56 (str -> str GDEQ str .)
    LDEQ            reduce using rule 56 (str -> str GDEQ str .)
    GD              reduce using rule 56 (str -> str GDEQ str .)
    GDEQ            reduce using rule 56 (str -> str GDEQ str .)
    EQUALEQUAL      reduce using rule 56 (str -> str GDEQ str .)
    NOTEQ           reduce using rule 56 (str -> str GDEQ str .)
    NEWLINE         reduce using rule 56 (str -> str GDEQ str .)
    $end            reduce using rule 56 (str -> str GDEQ str .)
    COMMA           reduce using rule 56 (str -> str GDEQ str .)
    RBRACE          reduce using rule 56 (str -> str GDEQ str .)
    RPAREN          reduce using rule 56 (str -> str GDEQ str .)
    START           reduce using rule 56 (str -> str GDEQ str .)
    STOP            reduce using rule 56 (str -> str GDEQ str .)
    RETURN          reduce using rule 56 (str -> str GDEQ str .)
    PLUS            shift and go to state 49

  ! PLUS            [ reduce using rule 56 (str -> str GDEQ str .) ]
  ! LD              [ shift and go to state 50 ]
  ! LDEQ            [ shift and go to state 51 ]
  ! GD              [ shift and go to state 52 ]
  ! GDEQ            [ shift and go to state 53 ]
  ! EQUALEQUAL      [ shift and go to state 54 ]
  ! NOTEQ           [ shift and go to state 55 ]


state 96

    (57) str -> str EQUALEQUAL str .
    (52) str -> str . PLUS str
    (53) str -> str . LD str
    (54) str -> str . LDEQ str
    (55) str -> str . GD str
    (56) str -> str . GDEQ str
    (57) str -> str . EQUALEQUAL str
    (58) str -> str . NOTEQ str

    EQUALEQUAL      reduce using rule 57 (str -> str EQUALEQUAL str .)
    NOTEQ           reduce using rule 57 (str -> str EQUALEQUAL str .)
    NEWLINE         reduce using rule 57 (str -> str EQUALEQUAL str .)
    $end            reduce using rule 57 (str -> str EQUALEQUAL str .)
    COMMA           reduce using rule 57 (str -> str EQUALEQUAL str .)
    RBRACE          reduce using rule 57 (str -> str EQUALEQUAL str .)
    RPAREN          reduce using rule 57 (str -> str EQUALEQUAL str .)
    START           reduce using rule 57 (str -> str EQUALEQUAL str .)
    STOP            reduce using rule 57 (str -> str EQUALEQUAL str .)
    RETURN          reduce using rule 57 (str -> str EQUALEQUAL str .)
    PLUS            shift and go to state 49
    LD              shift and go to state 50
    LDEQ            shift and go to state 51
    GD              shift and go to state 52
    GDEQ            shift and go to state 53

  ! PLUS            [ reduce using rule 57 (str -> str EQUALEQUAL str .) ]
  ! LD              [ reduce using rule 57 (str -> str EQUALEQUAL str .) ]
  ! LDEQ            [ reduce using rule 57 (str -> str EQUALEQUAL str .) ]
  ! GD              [ reduce using rule 57 (str -> str EQUALEQUAL str .) ]
  ! GDEQ            [ reduce using rule 57 (str -> str EQUALEQUAL str .) ]
  ! EQUALEQUAL      [ shift and go to state 54 ]
  ! NOTEQ           [ shift and go to state 55 ]


state 97

    (58) str -> str NOTEQ str .
    (52) str -> str . PLUS str
    (53) str -> str . LD str
    (54) str -> str . LDEQ str
    (55) str -> str . GD str
    (56) str -> str . GDEQ str
    (57) str -> str . EQUALEQUAL str
    (58) str -> str . NOTEQ str

    EQUALEQUAL      reduce using rule 58 (str -> str NOTEQ str .)
    NOTEQ           reduce using rule 58 (str -> str NOTEQ str .)
    NEWLINE         reduce using rule 58 (str -> str NOTEQ str .)
    $end            reduce using rule 58 (str -> str NOTEQ str .)
    COMMA           reduce using rule 58 (str -> str NOTEQ str .)
    RBRACE          reduce using rule 58 (str -> str NOTEQ str .)
    RPAREN          reduce using rule 58 (str -> str NOTEQ str .)
    START           reduce using rule 58 (str -> str NOTEQ str .)
    STOP            reduce using rule 58 (str -> str NOTEQ str .)
    RETURN          reduce using rule 58 (str -> str NOTEQ str .)
    PLUS            shift and go to state 49
    LD              shift and go to state 50
    LDEQ            shift and go to state 51
    GD              shift and go to state 52
    GDEQ            shift and go to state 53

  ! PLUS            [ reduce using rule 58 (str -> str NOTEQ str .) ]
  ! LD              [ reduce using rule 58 (str -> str NOTEQ str .) ]
  ! LDEQ            [ reduce using rule 58 (str -> str NOTEQ str .) ]
  ! GD              [ reduce using rule 58 (str -> str NOTEQ str .) ]
  ! GDEQ            [ reduce using rule 58 (str -> str NOTEQ str .) ]
  ! EQUALEQUAL      [ shift and go to state 54 ]
  ! NOTEQ           [ shift and go to state 55 ]


state 98

    (62) expression -> LBRACE int_type_array RBRACE .

    NEWLINE         reduce using rule 62 (expression -> LBRACE int_type_array RBRACE .)
    $end            reduce using rule 62 (expression -> LBRACE int_type_array RBRACE .)
    START           reduce using rule 62 (expression -> LBRACE int_type_array RBRACE .)
    STOP            reduce using rule 62 (expression -> LBRACE int_type_array RBRACE .)
    RETURN          reduce using rule 62 (expression -> LBRACE int_type_array RBRACE .)
    RPAREN          reduce using rule 62 (expression -> LBRACE int_type_array RBRACE .)


state 99

    (63) expression -> LBRACE string_type_array RBRACE .

    NEWLINE         reduce using rule 63 (expression -> LBRACE string_type_array RBRACE .)
    $end            reduce using rule 63 (expression -> LBRACE string_type_array RBRACE .)
    START           reduce using rule 63 (expression -> LBRACE string_type_array RBRACE .)
    STOP            reduce using rule 63 (expression -> LBRACE string_type_array RBRACE .)
    RETURN          reduce using rule 63 (expression -> LBRACE string_type_array RBRACE .)
    RPAREN          reduce using rule 63 (expression -> LBRACE string_type_array RBRACE .)


state 100

    (65) int_type_array -> math COMMA . int_type_array
    (64) int_type_array -> . math
    (65) int_type_array -> . math COMMA int_type_array
    (33) math -> . math MULTIPLY math
    (34) math -> . math DIVIDE math
    (35) math -> . math MODULO math
    (36) math -> . math PLUS math
    (37) math -> . math MINUS math
    (38) math -> . math LD math
    (39) math -> . math LDEQ math
    (40) math -> . math GD math
    (41) math -> . math GDEQ math
    (42) math -> . math EQUALEQUAL math
    (43) math -> . math NOTEQ math
    (44) math -> . math AND math
    (45) math -> . math OR math
    (46) math -> . NOT math
    (47) math -> . MINUS math
    (48) math -> . INT
    (49) math -> . FLOAT
    (50) math -> . TRUE
    (51) math -> . FALSE
    (60) math -> . NAME
    (68) math -> . LPAREN math RPAREN

    NOT             shift and go to state 23
    MINUS           shift and go to state 22
    INT             shift and go to state 24
    FLOAT           shift and go to state 25
    TRUE            shift and go to state 26
    FALSE           shift and go to state 27
    NAME            shift and go to state 69
    LPAREN          shift and go to state 70

    math                           shift and go to state 58
    int_type_array                 shift and go to state 110

state 101

    (67) string_type_array -> str COMMA . string_type_array
    (66) string_type_array -> . str
    (67) string_type_array -> . str COMMA string_type_array
    (52) str -> . str PLUS str
    (53) str -> . str LD str
    (54) str -> . str LDEQ str
    (55) str -> . str GD str
    (56) str -> . str GDEQ str
    (57) str -> . str EQUALEQUAL str
    (58) str -> . str NOTEQ str
    (59) str -> . STRING
    (61) str -> . NAME
    (69) str -> . LPAREN str RPAREN

    STRING          shift and go to state 28
    NAME            shift and go to state 90
    LPAREN          shift and go to state 91

    str                            shift and go to state 59
    string_type_array              shift and go to state 111

state 102

    (29) var_assign -> datatype NAME EQUALS . expression
    (28) expression -> . NAME
    (31) expression -> . math
    (32) expression -> . str
    (62) expression -> . LBRACE int_type_array RBRACE
    (63) expression -> . LBRACE string_type_array RBRACE
    (33) math -> . math MULTIPLY math
    (34) math -> . math DIVIDE math
    (35) math -> . math MODULO math
    (36) math -> . math PLUS math
    (37) math -> . math MINUS math
    (38) math -> . math LD math
    (39) math -> . math LDEQ math
    (40) math -> . math GD math
    (41) math -> . math GDEQ math
    (42) math -> . math EQUALEQUAL math
    (43) math -> . math NOTEQ math
    (44) math -> . math AND math
    (45) math -> . math OR math
    (46) math -> . NOT math
    (47) math -> . MINUS math
    (48) math -> . INT
    (49) math -> . FLOAT
    (50) math -> . TRUE
    (51) math -> . FALSE
    (60) math -> . NAME
    (68) math -> . LPAREN math RPAREN
    (52) str -> . str PLUS str
    (53) str -> . str LD str
    (54) str -> . str LDEQ str
    (55) str -> . str GD str
    (56) str -> . str GDEQ str
    (57) str -> . str EQUALEQUAL str
    (58) str -> . str NOTEQ str
    (59) str -> . STRING
    (61) str -> . NAME
    (69) str -> . LPAREN str RPAREN

    NAME            shift and go to state 65
    LBRACE          shift and go to state 15
    NOT             shift and go to state 23
    MINUS           shift and go to state 22
    INT             shift and go to state 24
    FLOAT           shift and go to state 25
    TRUE            shift and go to state 26
    FALSE           shift and go to state 27
    LPAREN          shift and go to state 17
    STRING          shift and go to state 28

    expression                     shift and go to state 112
    math                           shift and go to state 13
    str                            shift and go to state 14

state 103

    (13) func_assign -> datatype NAME LPAREN . parameters RPAREN START NEWLINE language return_stmt STOP
    (17) parameters -> . first_param
    (18) parameters -> . empty
    (19) first_param -> . datatype NAME COMMA first_param
    (20) first_param -> . datatype NAME
    (77) empty -> .
    (21) datatype -> . INT_TYPE
    (22) datatype -> . FLOAT_TYPE
    (23) datatype -> . STRING_TYPE
    (24) datatype -> . VOID_TYPE

    RPAREN          reduce using rule 77 (empty -> .)
    INT_TYPE        shift and go to state 29
    FLOAT_TYPE      shift and go to state 30
    STRING_TYPE     shift and go to state 31
    VOID_TYPE       shift and go to state 32

    datatype                       shift and go to state 113
    parameters                     shift and go to state 114
    first_param                    shift and go to state 115
    empty                          shift and go to state 116

state 104

    (68) math -> LPAREN math RPAREN .

    MULTIPLY        reduce using rule 68 (math -> LPAREN math RPAREN .)
    DIVIDE          reduce using rule 68 (math -> LPAREN math RPAREN .)
    MODULO          reduce using rule 68 (math -> LPAREN math RPAREN .)
    PLUS            reduce using rule 68 (math -> LPAREN math RPAREN .)
    MINUS           reduce using rule 68 (math -> LPAREN math RPAREN .)
    LD              reduce using rule 68 (math -> LPAREN math RPAREN .)
    LDEQ            reduce using rule 68 (math -> LPAREN math RPAREN .)
    GD              reduce using rule 68 (math -> LPAREN math RPAREN .)
    GDEQ            reduce using rule 68 (math -> LPAREN math RPAREN .)
    EQUALEQUAL      reduce using rule 68 (math -> LPAREN math RPAREN .)
    NOTEQ           reduce using rule 68 (math -> LPAREN math RPAREN .)
    AND             reduce using rule 68 (math -> LPAREN math RPAREN .)
    OR              reduce using rule 68 (math -> LPAREN math RPAREN .)
    NEWLINE         reduce using rule 68 (math -> LPAREN math RPAREN .)
    $end            reduce using rule 68 (math -> LPAREN math RPAREN .)
    COMMA           reduce using rule 68 (math -> LPAREN math RPAREN .)
    RBRACE          reduce using rule 68 (math -> LPAREN math RPAREN .)
    RPAREN          reduce using rule 68 (math -> LPAREN math RPAREN .)
    START           reduce using rule 68 (math -> LPAREN math RPAREN .)
    STOP            reduce using rule 68 (math -> LPAREN math RPAREN .)
    RETURN          reduce using rule 68 (math -> LPAREN math RPAREN .)


state 105

    (69) str -> LPAREN str RPAREN .

    PLUS            reduce using rule 69 (str -> LPAREN str RPAREN .)
    LD              reduce using rule 69 (str -> LPAREN str RPAREN .)
    LDEQ            reduce using rule 69 (str -> LPAREN str RPAREN .)
    GD              reduce using rule 69 (str -> LPAREN str RPAREN .)
    GDEQ            reduce using rule 69 (str -> LPAREN str RPAREN .)
    EQUALEQUAL      reduce using rule 69 (str -> LPAREN str RPAREN .)
    NOTEQ           reduce using rule 69 (str -> LPAREN str RPAREN .)
    NEWLINE         reduce using rule 69 (str -> LPAREN str RPAREN .)
    $end            reduce using rule 69 (str -> LPAREN str RPAREN .)
    COMMA           reduce using rule 69 (str -> LPAREN str RPAREN .)
    RBRACE          reduce using rule 69 (str -> LPAREN str RPAREN .)
    RPAREN          reduce using rule 69 (str -> LPAREN str RPAREN .)
    START           reduce using rule 69 (str -> LPAREN str RPAREN .)
    STOP            reduce using rule 69 (str -> LPAREN str RPAREN .)
    RETURN          reduce using rule 69 (str -> LPAREN str RPAREN .)


state 106

    (76) iterative -> WHILE expression START . NEWLINE language STOP

    NEWLINE         shift and go to state 117


state 107

    (70) conditional -> IF expression START . NEWLINE language STOP else_if_blocks else_block

    NEWLINE         shift and go to state 118


state 108

    (25) input -> READ LPAREN NAME . RPAREN

    RPAREN          shift and go to state 119


state 109

    (27) output_print -> PRINT LPAREN expression . RPAREN

    RPAREN          shift and go to state 120


state 110

    (65) int_type_array -> math COMMA int_type_array .

    RBRACE          reduce using rule 65 (int_type_array -> math COMMA int_type_array .)


state 111

    (67) string_type_array -> str COMMA string_type_array .

    RBRACE          reduce using rule 67 (string_type_array -> str COMMA string_type_array .)


state 112

    (29) var_assign -> datatype NAME EQUALS expression .

    NEWLINE         reduce using rule 29 (var_assign -> datatype NAME EQUALS expression .)
    $end            reduce using rule 29 (var_assign -> datatype NAME EQUALS expression .)
    STOP            reduce using rule 29 (var_assign -> datatype NAME EQUALS expression .)
    RETURN          reduce using rule 29 (var_assign -> datatype NAME EQUALS expression .)


state 113

    (19) first_param -> datatype . NAME COMMA first_param
    (20) first_param -> datatype . NAME

    NAME            shift and go to state 121


state 114

    (13) func_assign -> datatype NAME LPAREN parameters . RPAREN START NEWLINE language return_stmt STOP

    RPAREN          shift and go to state 122


state 115

    (17) parameters -> first_param .

    RPAREN          reduce using rule 17 (parameters -> first_param .)


state 116

    (18) parameters -> empty .

    RPAREN          reduce using rule 18 (parameters -> empty .)


state 117

    (76) iterative -> WHILE expression START NEWLINE . language STOP
    (3) language -> . language NEWLINE line
    (4) language -> . line
    (5) line -> . expression
    (6) line -> . var_assign
    (7) line -> . func_assign
    (8) line -> . iterative
    (9) line -> . conditional
    (10) line -> . output
    (11) line -> . input
    (12) line -> . empty
    (28) expression -> . NAME
    (31) expression -> . math
    (32) expression -> . str
    (62) expression -> . LBRACE int_type_array RBRACE
    (63) expression -> . LBRACE string_type_array RBRACE
    (29) var_assign -> . datatype NAME EQUALS expression
    (30) var_assign -> . NAME EQUALS expression
    (13) func_assign -> . datatype NAME LPAREN parameters RPAREN START NEWLINE language return_stmt STOP
    (76) iterative -> . WHILE expression START NEWLINE language STOP
    (70) conditional -> . IF expression START NEWLINE language STOP else_if_blocks else_block
    (26) output -> . output_print
    (25) input -> . READ LPAREN NAME RPAREN
    (77) empty -> .
    (33) math -> . math MULTIPLY math
    (34) math -> . math DIVIDE math
    (35) math -> . math MODULO math
    (36) math -> . math PLUS math
    (37) math -> . math MINUS math
    (38) math -> . math LD math
    (39) math -> . math LDEQ math
    (40) math -> . math GD math
    (41) math -> . math GDEQ math
    (42) math -> . math EQUALEQUAL math
    (43) math -> . math NOTEQ math
    (44) math -> . math AND math
    (45) math -> . math OR math
    (46) math -> . NOT math
    (47) math -> . MINUS math
    (48) math -> . INT
    (49) math -> . FLOAT
    (50) math -> . TRUE
    (51) math -> . FALSE
    (60) math -> . NAME
    (68) math -> . LPAREN math RPAREN
    (52) str -> . str PLUS str
    (53) str -> . str LD str
    (54) str -> . str LDEQ str
    (55) str -> . str GD str
    (56) str -> . str GDEQ str
    (57) str -> . str EQUALEQUAL str
    (58) str -> . str NOTEQ str
    (59) str -> . STRING
    (61) str -> . NAME
    (69) str -> . LPAREN str RPAREN
    (21) datatype -> . INT_TYPE
    (22) datatype -> . FLOAT_TYPE
    (23) datatype -> . STRING_TYPE
    (24) datatype -> . VOID_TYPE
    (27) output_print -> . PRINT LPAREN expression RPAREN

    NAME            shift and go to state 12
    LBRACE          shift and go to state 15
    WHILE           shift and go to state 18
    IF              shift and go to state 19
    READ            shift and go to state 21
    STOP            reduce using rule 77 (empty -> .)
    NEWLINE         reduce using rule 77 (empty -> .)
    NOT             shift and go to state 23
    MINUS           shift and go to state 22
    INT             shift and go to state 24
    FLOAT           shift and go to state 25
    TRUE            shift and go to state 26
    FALSE           shift and go to state 27
    LPAREN          shift and go to state 17
    STRING          shift and go to state 28
    INT_TYPE        shift and go to state 29
    FLOAT_TYPE      shift and go to state 30
    STRING_TYPE     shift and go to state 31
    VOID_TYPE       shift and go to state 32
    PRINT           shift and go to state 33

    expression                     shift and go to state 5
    language                       shift and go to state 123
    line                           shift and go to state 4
    var_assign                     shift and go to state 6
    func_assign                    shift and go to state 7
    iterative                      shift and go to state 8
    conditional                    shift and go to state 9
    output                         shift and go to state 10
    input                          shift and go to state 11
    empty                          shift and go to state 74
    math                           shift and go to state 13
    str                            shift and go to state 14
    datatype                       shift and go to state 16
    output_print                   shift and go to state 20

state 118

    (70) conditional -> IF expression START NEWLINE . language STOP else_if_blocks else_block
    (3) language -> . language NEWLINE line
    (4) language -> . line
    (5) line -> . expression
    (6) line -> . var_assign
    (7) line -> . func_assign
    (8) line -> . iterative
    (9) line -> . conditional
    (10) line -> . output
    (11) line -> . input
    (12) line -> . empty
    (28) expression -> . NAME
    (31) expression -> . math
    (32) expression -> . str
    (62) expression -> . LBRACE int_type_array RBRACE
    (63) expression -> . LBRACE string_type_array RBRACE
    (29) var_assign -> . datatype NAME EQUALS expression
    (30) var_assign -> . NAME EQUALS expression
    (13) func_assign -> . datatype NAME LPAREN parameters RPAREN START NEWLINE language return_stmt STOP
    (76) iterative -> . WHILE expression START NEWLINE language STOP
    (70) conditional -> . IF expression START NEWLINE language STOP else_if_blocks else_block
    (26) output -> . output_print
    (25) input -> . READ LPAREN NAME RPAREN
    (77) empty -> .
    (33) math -> . math MULTIPLY math
    (34) math -> . math DIVIDE math
    (35) math -> . math MODULO math
    (36) math -> . math PLUS math
    (37) math -> . math MINUS math
    (38) math -> . math LD math
    (39) math -> . math LDEQ math
    (40) math -> . math GD math
    (41) math -> . math GDEQ math
    (42) math -> . math EQUALEQUAL math
    (43) math -> . math NOTEQ math
    (44) math -> . math AND math
    (45) math -> . math OR math
    (46) math -> . NOT math
    (47) math -> . MINUS math
    (48) math -> . INT
    (49) math -> . FLOAT
    (50) math -> . TRUE
    (51) math -> . FALSE
    (60) math -> . NAME
    (68) math -> . LPAREN math RPAREN
    (52) str -> . str PLUS str
    (53) str -> . str LD str
    (54) str -> . str LDEQ str
    (55) str -> . str GD str
    (56) str -> . str GDEQ str
    (57) str -> . str EQUALEQUAL str
    (58) str -> . str NOTEQ str
    (59) str -> . STRING
    (61) str -> . NAME
    (69) str -> . LPAREN str RPAREN
    (21) datatype -> . INT_TYPE
    (22) datatype -> . FLOAT_TYPE
    (23) datatype -> . STRING_TYPE
    (24) datatype -> . VOID_TYPE
    (27) output_print -> . PRINT LPAREN expression RPAREN

    NAME            shift and go to state 12
    LBRACE          shift and go to state 15
    WHILE           shift and go to state 18
    IF              shift and go to state 19
    READ            shift and go to state 21
    STOP            reduce using rule 77 (empty -> .)
    NEWLINE         reduce using rule 77 (empty -> .)
    NOT             shift and go to state 23
    MINUS           shift and go to state 22
    INT             shift and go to state 24
    FLOAT           shift and go to state 25
    TRUE            shift and go to state 26
    FALSE           shift and go to state 27
    LPAREN          shift and go to state 17
    STRING          shift and go to state 28
    INT_TYPE        shift and go to state 29
    FLOAT_TYPE      shift and go to state 30
    STRING_TYPE     shift and go to state 31
    VOID_TYPE       shift and go to state 32
    PRINT           shift and go to state 33

    expression                     shift and go to state 5
    language                       shift and go to state 124
    line                           shift and go to state 4
    var_assign                     shift and go to state 6
    func_assign                    shift and go to state 7
    iterative                      shift and go to state 8
    conditional                    shift and go to state 9
    output                         shift and go to state 10
    input                          shift and go to state 11
    empty                          shift and go to state 74
    math                           shift and go to state 13
    str                            shift and go to state 14
    datatype                       shift and go to state 16
    output_print                   shift and go to state 20

state 119

    (25) input -> READ LPAREN NAME RPAREN .

    NEWLINE         reduce using rule 25 (input -> READ LPAREN NAME RPAREN .)
    $end            reduce using rule 25 (input -> READ LPAREN NAME RPAREN .)
    STOP            reduce using rule 25 (input -> READ LPAREN NAME RPAREN .)
    RETURN          reduce using rule 25 (input -> READ LPAREN NAME RPAREN .)


state 120

    (27) output_print -> PRINT LPAREN expression RPAREN .

    NEWLINE         reduce using rule 27 (output_print -> PRINT LPAREN expression RPAREN .)
    $end            reduce using rule 27 (output_print -> PRINT LPAREN expression RPAREN .)
    STOP            reduce using rule 27 (output_print -> PRINT LPAREN expression RPAREN .)
    RETURN          reduce using rule 27 (output_print -> PRINT LPAREN expression RPAREN .)


state 121

    (19) first_param -> datatype NAME . COMMA first_param
    (20) first_param -> datatype NAME .

    COMMA           shift and go to state 125
    RPAREN          reduce using rule 20 (first_param -> datatype NAME .)


state 122

    (13) func_assign -> datatype NAME LPAREN parameters RPAREN . START NEWLINE language return_stmt STOP

    START           shift and go to state 126


state 123

    (76) iterative -> WHILE expression START NEWLINE language . STOP
    (3) language -> language . NEWLINE line

    STOP            shift and go to state 127
    NEWLINE         shift and go to state 34


state 124

    (70) conditional -> IF expression START NEWLINE language . STOP else_if_blocks else_block
    (3) language -> language . NEWLINE line

    STOP            shift and go to state 128
    NEWLINE         shift and go to state 34


state 125

    (19) first_param -> datatype NAME COMMA . first_param
    (19) first_param -> . datatype NAME COMMA first_param
    (20) first_param -> . datatype NAME
    (21) datatype -> . INT_TYPE
    (22) datatype -> . FLOAT_TYPE
    (23) datatype -> . STRING_TYPE
    (24) datatype -> . VOID_TYPE

    INT_TYPE        shift and go to state 29
    FLOAT_TYPE      shift and go to state 30
    STRING_TYPE     shift and go to state 31
    VOID_TYPE       shift and go to state 32

    datatype                       shift and go to state 113
    first_param                    shift and go to state 129

state 126

    (13) func_assign -> datatype NAME LPAREN parameters RPAREN START . NEWLINE language return_stmt STOP

    NEWLINE         shift and go to state 130


state 127

    (76) iterative -> WHILE expression START NEWLINE language STOP .

    NEWLINE         reduce using rule 76 (iterative -> WHILE expression START NEWLINE language STOP .)
    $end            reduce using rule 76 (iterative -> WHILE expression START NEWLINE language STOP .)
    STOP            reduce using rule 76 (iterative -> WHILE expression START NEWLINE language STOP .)
    RETURN          reduce using rule 76 (iterative -> WHILE expression START NEWLINE language STOP .)


state 128

    (70) conditional -> IF expression START NEWLINE language STOP . else_if_blocks else_block
    (71) else_if_blocks -> . empty
    (72) else_if_blocks -> . else_if_block else_if_blocks
    (77) empty -> .
    (73) else_if_block -> . ELSE_IF expression START NEWLINE language STOP

    ELSE            reduce using rule 77 (empty -> .)
    NEWLINE         reduce using rule 77 (empty -> .)
    $end            reduce using rule 77 (empty -> .)
    STOP            reduce using rule 77 (empty -> .)
    RETURN          reduce using rule 77 (empty -> .)
    ELSE_IF         shift and go to state 134

    else_if_blocks                 shift and go to state 131
    empty                          shift and go to state 132
    else_if_block                  shift and go to state 133

state 129

    (19) first_param -> datatype NAME COMMA first_param .

    RPAREN          reduce using rule 19 (first_param -> datatype NAME COMMA first_param .)


state 130

    (13) func_assign -> datatype NAME LPAREN parameters RPAREN START NEWLINE . language return_stmt STOP
    (3) language -> . language NEWLINE line
    (4) language -> . line
    (5) line -> . expression
    (6) line -> . var_assign
    (7) line -> . func_assign
    (8) line -> . iterative
    (9) line -> . conditional
    (10) line -> . output
    (11) line -> . input
    (12) line -> . empty
    (28) expression -> . NAME
    (31) expression -> . math
    (32) expression -> . str
    (62) expression -> . LBRACE int_type_array RBRACE
    (63) expression -> . LBRACE string_type_array RBRACE
    (29) var_assign -> . datatype NAME EQUALS expression
    (30) var_assign -> . NAME EQUALS expression
    (13) func_assign -> . datatype NAME LPAREN parameters RPAREN START NEWLINE language return_stmt STOP
    (76) iterative -> . WHILE expression START NEWLINE language STOP
    (70) conditional -> . IF expression START NEWLINE language STOP else_if_blocks else_block
    (26) output -> . output_print
    (25) input -> . READ LPAREN NAME RPAREN
    (77) empty -> .
    (33) math -> . math MULTIPLY math
    (34) math -> . math DIVIDE math
    (35) math -> . math MODULO math
    (36) math -> . math PLUS math
    (37) math -> . math MINUS math
    (38) math -> . math LD math
    (39) math -> . math LDEQ math
    (40) math -> . math GD math
    (41) math -> . math GDEQ math
    (42) math -> . math EQUALEQUAL math
    (43) math -> . math NOTEQ math
    (44) math -> . math AND math
    (45) math -> . math OR math
    (46) math -> . NOT math
    (47) math -> . MINUS math
    (48) math -> . INT
    (49) math -> . FLOAT
    (50) math -> . TRUE
    (51) math -> . FALSE
    (60) math -> . NAME
    (68) math -> . LPAREN math RPAREN
    (52) str -> . str PLUS str
    (53) str -> . str LD str
    (54) str -> . str LDEQ str
    (55) str -> . str GD str
    (56) str -> . str GDEQ str
    (57) str -> . str EQUALEQUAL str
    (58) str -> . str NOTEQ str
    (59) str -> . STRING
    (61) str -> . NAME
    (69) str -> . LPAREN str RPAREN
    (21) datatype -> . INT_TYPE
    (22) datatype -> . FLOAT_TYPE
    (23) datatype -> . STRING_TYPE
    (24) datatype -> . VOID_TYPE
    (27) output_print -> . PRINT LPAREN expression RPAREN

    NAME            shift and go to state 12
    LBRACE          shift and go to state 15
    WHILE           shift and go to state 18
    IF              shift and go to state 19
    READ            shift and go to state 21
    NEWLINE         reduce using rule 77 (empty -> .)
    RETURN          reduce using rule 77 (empty -> .)
    STOP            reduce using rule 77 (empty -> .)
    NOT             shift and go to state 23
    MINUS           shift and go to state 22
    INT             shift and go to state 24
    FLOAT           shift and go to state 25
    TRUE            shift and go to state 26
    FALSE           shift and go to state 27
    LPAREN          shift and go to state 17
    STRING          shift and go to state 28
    INT_TYPE        shift and go to state 29
    FLOAT_TYPE      shift and go to state 30
    STRING_TYPE     shift and go to state 31
    VOID_TYPE       shift and go to state 32
    PRINT           shift and go to state 33

    datatype                       shift and go to state 16
    language                       shift and go to state 135
    line                           shift and go to state 4
    expression                     shift and go to state 5
    var_assign                     shift and go to state 6
    func_assign                    shift and go to state 7
    iterative                      shift and go to state 8
    conditional                    shift and go to state 9
    output                         shift and go to state 10
    input                          shift and go to state 11
    empty                          shift and go to state 74
    math                           shift and go to state 13
    str                            shift and go to state 14
    output_print                   shift and go to state 20

state 131

    (70) conditional -> IF expression START NEWLINE language STOP else_if_blocks . else_block
    (74) else_block -> . ELSE START NEWLINE language STOP
    (75) else_block -> . empty
    (77) empty -> .

    ELSE            shift and go to state 137
    NEWLINE         reduce using rule 77 (empty -> .)
    $end            reduce using rule 77 (empty -> .)
    STOP            reduce using rule 77 (empty -> .)
    RETURN          reduce using rule 77 (empty -> .)

    else_block                     shift and go to state 136
    empty                          shift and go to state 138

state 132

    (71) else_if_blocks -> empty .

    ELSE            reduce using rule 71 (else_if_blocks -> empty .)
    NEWLINE         reduce using rule 71 (else_if_blocks -> empty .)
    $end            reduce using rule 71 (else_if_blocks -> empty .)
    STOP            reduce using rule 71 (else_if_blocks -> empty .)
    RETURN          reduce using rule 71 (else_if_blocks -> empty .)


state 133

    (72) else_if_blocks -> else_if_block . else_if_blocks
    (71) else_if_blocks -> . empty
    (72) else_if_blocks -> . else_if_block else_if_blocks
    (77) empty -> .
    (73) else_if_block -> . ELSE_IF expression START NEWLINE language STOP

    ELSE            reduce using rule 77 (empty -> .)
    NEWLINE         reduce using rule 77 (empty -> .)
    $end            reduce using rule 77 (empty -> .)
    STOP            reduce using rule 77 (empty -> .)
    RETURN          reduce using rule 77 (empty -> .)
    ELSE_IF         shift and go to state 134

    else_if_block                  shift and go to state 133
    else_if_blocks                 shift and go to state 139
    empty                          shift and go to state 132

state 134

    (73) else_if_block -> ELSE_IF . expression START NEWLINE language STOP
    (28) expression -> . NAME
    (31) expression -> . math
    (32) expression -> . str
    (62) expression -> . LBRACE int_type_array RBRACE
    (63) expression -> . LBRACE string_type_array RBRACE
    (33) math -> . math MULTIPLY math
    (34) math -> . math DIVIDE math
    (35) math -> . math MODULO math
    (36) math -> . math PLUS math
    (37) math -> . math MINUS math
    (38) math -> . math LD math
    (39) math -> . math LDEQ math
    (40) math -> . math GD math
    (41) math -> . math GDEQ math
    (42) math -> . math EQUALEQUAL math
    (43) math -> . math NOTEQ math
    (44) math -> . math AND math
    (45) math -> . math OR math
    (46) math -> . NOT math
    (47) math -> . MINUS math
    (48) math -> . INT
    (49) math -> . FLOAT
    (50) math -> . TRUE
    (51) math -> . FALSE
    (60) math -> . NAME
    (68) math -> . LPAREN math RPAREN
    (52) str -> . str PLUS str
    (53) str -> . str LD str
    (54) str -> . str LDEQ str
    (55) str -> . str GD str
    (56) str -> . str GDEQ str
    (57) str -> . str EQUALEQUAL str
    (58) str -> . str NOTEQ str
    (59) str -> . STRING
    (61) str -> . NAME
    (69) str -> . LPAREN str RPAREN

    NAME            shift and go to state 65
    LBRACE          shift and go to state 15
    NOT             shift and go to state 23
    MINUS           shift and go to state 22
    INT             shift and go to state 24
    FLOAT           shift and go to state 25
    TRUE            shift and go to state 26
    FALSE           shift and go to state 27
    LPAREN          shift and go to state 17
    STRING          shift and go to state 28

    expression                     shift and go to state 140
    math                           shift and go to state 13
    str                            shift and go to state 14

state 135

    (13) func_assign -> datatype NAME LPAREN parameters RPAREN START NEWLINE language . return_stmt STOP
    (3) language -> language . NEWLINE line
    (14) return_stmt -> . RETURN expression NEWLINE
    (15) return_stmt -> . RETURN NEWLINE
    (16) return_stmt -> . empty
    (77) empty -> .

    NEWLINE         shift and go to state 34
    RETURN          shift and go to state 142
    STOP            reduce using rule 77 (empty -> .)

    return_stmt                    shift and go to state 141
    empty                          shift and go to state 143

state 136

    (70) conditional -> IF expression START NEWLINE language STOP else_if_blocks else_block .

    NEWLINE         reduce using rule 70 (conditional -> IF expression START NEWLINE language STOP else_if_blocks else_block .)
    $end            reduce using rule 70 (conditional -> IF expression START NEWLINE language STOP else_if_blocks else_block .)
    STOP            reduce using rule 70 (conditional -> IF expression START NEWLINE language STOP else_if_blocks else_block .)
    RETURN          reduce using rule 70 (conditional -> IF expression START NEWLINE language STOP else_if_blocks else_block .)


state 137

    (74) else_block -> ELSE . START NEWLINE language STOP

    START           shift and go to state 144


state 138

    (75) else_block -> empty .

    NEWLINE         reduce using rule 75 (else_block -> empty .)
    $end            reduce using rule 75 (else_block -> empty .)
    STOP            reduce using rule 75 (else_block -> empty .)
    RETURN          reduce using rule 75 (else_block -> empty .)


state 139

    (72) else_if_blocks -> else_if_block else_if_blocks .

    ELSE            reduce using rule 72 (else_if_blocks -> else_if_block else_if_blocks .)
    NEWLINE         reduce using rule 72 (else_if_blocks -> else_if_block else_if_blocks .)
    $end            reduce using rule 72 (else_if_blocks -> else_if_block else_if_blocks .)
    STOP            reduce using rule 72 (else_if_blocks -> else_if_block else_if_blocks .)
    RETURN          reduce using rule 72 (else_if_blocks -> else_if_block else_if_blocks .)


state 140

    (73) else_if_block -> ELSE_IF expression . START NEWLINE language STOP

    START           shift and go to state 145


state 141

    (13) func_assign -> datatype NAME LPAREN parameters RPAREN START NEWLINE language return_stmt . STOP

    STOP            shift and go to state 146


state 142

    (14) return_stmt -> RETURN . expression NEWLINE
    (15) return_stmt -> RETURN . NEWLINE
    (28) expression -> . NAME
    (31) expression -> . math
    (32) expression -> . str
    (62) expression -> . LBRACE int_type_array RBRACE
    (63) expression -> . LBRACE string_type_array RBRACE
    (33) math -> . math MULTIPLY math
    (34) math -> . math DIVIDE math
    (35) math -> . math MODULO math
    (36) math -> . math PLUS math
    (37) math -> . math MINUS math
    (38) math -> . math LD math
    (39) math -> . math LDEQ math
    (40) math -> . math GD math
    (41) math -> . math GDEQ math
    (42) math -> . math EQUALEQUAL math
    (43) math -> . math NOTEQ math
    (44) math -> . math AND math
    (45) math -> . math OR math
    (46) math -> . NOT math
    (47) math -> . MINUS math
    (48) math -> . INT
    (49) math -> . FLOAT
    (50) math -> . TRUE
    (51) math -> . FALSE
    (60) math -> . NAME
    (68) math -> . LPAREN math RPAREN
    (52) str -> . str PLUS str
    (53) str -> . str LD str
    (54) str -> . str LDEQ str
    (55) str -> . str GD str
    (56) str -> . str GDEQ str
    (57) str -> . str EQUALEQUAL str
    (58) str -> . str NOTEQ str
    (59) str -> . STRING
    (61) str -> . NAME
    (69) str -> . LPAREN str RPAREN

    NEWLINE         shift and go to state 148
    NAME            shift and go to state 65
    LBRACE          shift and go to state 15
    NOT             shift and go to state 23
    MINUS           shift and go to state 22
    INT             shift and go to state 24
    FLOAT           shift and go to state 25
    TRUE            shift and go to state 26
    FALSE           shift and go to state 27
    LPAREN          shift and go to state 17
    STRING          shift and go to state 28

    expression                     shift and go to state 147
    math                           shift and go to state 13
    str                            shift and go to state 14

state 143

    (16) return_stmt -> empty .

    STOP            reduce using rule 16 (return_stmt -> empty .)


state 144

    (74) else_block -> ELSE START . NEWLINE language STOP

    NEWLINE         shift and go to state 149


state 145

    (73) else_if_block -> ELSE_IF expression START . NEWLINE language STOP

    NEWLINE         shift and go to state 150


state 146

    (13) func_assign -> datatype NAME LPAREN parameters RPAREN START NEWLINE language return_stmt STOP .

    NEWLINE         reduce using rule 13 (func_assign -> datatype NAME LPAREN parameters RPAREN START NEWLINE language return_stmt STOP .)
    $end            reduce using rule 13 (func_assign -> datatype NAME LPAREN parameters RPAREN START NEWLINE language return_stmt STOP .)
    STOP            reduce using rule 13 (func_assign -> datatype NAME LPAREN parameters RPAREN START NEWLINE language return_stmt STOP .)
    RETURN          reduce using rule 13 (func_assign -> datatype NAME LPAREN parameters RPAREN START NEWLINE language return_stmt STOP .)


state 147

    (14) return_stmt -> RETURN expression . NEWLINE

    NEWLINE         shift and go to state 151


state 148

    (15) return_stmt -> RETURN NEWLINE .

    STOP            reduce using rule 15 (return_stmt -> RETURN NEWLINE .)


state 149

    (74) else_block -> ELSE START NEWLINE . language STOP
    (3) language -> . language NEWLINE line
    (4) language -> . line
    (5) line -> . expression
    (6) line -> . var_assign
    (7) line -> . func_assign
    (8) line -> . iterative
    (9) line -> . conditional
    (10) line -> . output
    (11) line -> . input
    (12) line -> . empty
    (28) expression -> . NAME
    (31) expression -> . math
    (32) expression -> . str
    (62) expression -> . LBRACE int_type_array RBRACE
    (63) expression -> . LBRACE string_type_array RBRACE
    (29) var_assign -> . datatype NAME EQUALS expression
    (30) var_assign -> . NAME EQUALS expression
    (13) func_assign -> . datatype NAME LPAREN parameters RPAREN START NEWLINE language return_stmt STOP
    (76) iterative -> . WHILE expression START NEWLINE language STOP
    (70) conditional -> . IF expression START NEWLINE language STOP else_if_blocks else_block
    (26) output -> . output_print
    (25) input -> . READ LPAREN NAME RPAREN
    (77) empty -> .
    (33) math -> . math MULTIPLY math
    (34) math -> . math DIVIDE math
    (35) math -> . math MODULO math
    (36) math -> . math PLUS math
    (37) math -> . math MINUS math
    (38) math -> . math LD math
    (39) math -> . math LDEQ math
    (40) math -> . math GD math
    (41) math -> . math GDEQ math
    (42) math -> . math EQUALEQUAL math
    (43) math -> . math NOTEQ math
    (44) math -> . math AND math
    (45) math -> . math OR math
    (46) math -> . NOT math
    (47) math -> . MINUS math
    (48) math -> . INT
    (49) math -> . FLOAT
    (50) math -> . TRUE
    (51) math -> . FALSE
    (60) math -> . NAME
    (68) math -> . LPAREN math RPAREN
    (52) str -> . str PLUS str
    (53) str -> . str LD str
    (54) str -> . str LDEQ str
    (55) str -> . str GD str
    (56) str -> . str GDEQ str
    (57) str -> . str EQUALEQUAL str
    (58) str -> . str NOTEQ str
    (59) str -> . STRING
    (61) str -> . NAME
    (69) str -> . LPAREN str RPAREN
    (21) datatype -> . INT_TYPE
    (22) datatype -> . FLOAT_TYPE
    (23) datatype -> . STRING_TYPE
    (24) datatype -> . VOID_TYPE
    (27) output_print -> . PRINT LPAREN expression RPAREN

    NAME            shift and go to state 12
    LBRACE          shift and go to state 15
    WHILE           shift and go to state 18
    IF              shift and go to state 19
    READ            shift and go to state 21
    STOP            reduce using rule 77 (empty -> .)
    NEWLINE         reduce using rule 77 (empty -> .)
    NOT             shift and go to state 23
    MINUS           shift and go to state 22
    INT             shift and go to state 24
    FLOAT           shift and go to state 25
    TRUE            shift and go to state 26
    FALSE           shift and go to state 27
    LPAREN          shift and go to state 17
    STRING          shift and go to state 28
    INT_TYPE        shift and go to state 29
    FLOAT_TYPE      shift and go to state 30
    STRING_TYPE     shift and go to state 31
    VOID_TYPE       shift and go to state 32
    PRINT           shift and go to state 33

    language                       shift and go to state 152
    line                           shift and go to state 4
    expression                     shift and go to state 5
    var_assign                     shift and go to state 6
    func_assign                    shift and go to state 7
    iterative                      shift and go to state 8
    conditional                    shift and go to state 9
    output                         shift and go to state 10
    input                          shift and go to state 11
    empty                          shift and go to state 74
    math                           shift and go to state 13
    str                            shift and go to state 14
    datatype                       shift and go to state 16
    output_print                   shift and go to state 20

state 150

    (73) else_if_block -> ELSE_IF expression START NEWLINE . language STOP
    (3) language -> . language NEWLINE line
    (4) language -> . line
    (5) line -> . expression
    (6) line -> . var_assign
    (7) line -> . func_assign
    (8) line -> . iterative
    (9) line -> . conditional
    (10) line -> . output
    (11) line -> . input
    (12) line -> . empty
    (28) expression -> . NAME
    (31) expression -> . math
    (32) expression -> . str
    (62) expression -> . LBRACE int_type_array RBRACE
    (63) expression -> . LBRACE string_type_array RBRACE
    (29) var_assign -> . datatype NAME EQUALS expression
    (30) var_assign -> . NAME EQUALS expression
    (13) func_assign -> . datatype NAME LPAREN parameters RPAREN START NEWLINE language return_stmt STOP
    (76) iterative -> . WHILE expression START NEWLINE language STOP
    (70) conditional -> . IF expression START NEWLINE language STOP else_if_blocks else_block
    (26) output -> . output_print
    (25) input -> . READ LPAREN NAME RPAREN
    (77) empty -> .
    (33) math -> . math MULTIPLY math
    (34) math -> . math DIVIDE math
    (35) math -> . math MODULO math
    (36) math -> . math PLUS math
    (37) math -> . math MINUS math
    (38) math -> . math LD math
    (39) math -> . math LDEQ math
    (40) math -> . math GD math
    (41) math -> . math GDEQ math
    (42) math -> . math EQUALEQUAL math
    (43) math -> . math NOTEQ math
    (44) math -> . math AND math
    (45) math -> . math OR math
    (46) math -> . NOT math
    (47) math -> . MINUS math
    (48) math -> . INT
    (49) math -> . FLOAT
    (50) math -> . TRUE
    (51) math -> . FALSE
    (60) math -> . NAME
    (68) math -> . LPAREN math RPAREN
    (52) str -> . str PLUS str
    (53) str -> . str LD str
    (54) str -> . str LDEQ str
    (55) str -> . str GD str
    (56) str -> . str GDEQ str
    (57) str -> . str EQUALEQUAL str
    (58) str -> . str NOTEQ str
    (59) str -> . STRING
    (61) str -> . NAME
    (69) str -> . LPAREN str RPAREN
    (21) datatype -> . INT_TYPE
    (22) datatype -> . FLOAT_TYPE
    (23) datatype -> . STRING_TYPE
    (24) datatype -> . VOID_TYPE
    (27) output_print -> . PRINT LPAREN expression RPAREN

    NAME            shift and go to state 12
    LBRACE          shift and go to state 15
    WHILE           shift and go to state 18
    IF              shift and go to state 19
    READ            shift and go to state 21
    STOP            reduce using rule 77 (empty -> .)
    NEWLINE         reduce using rule 77 (empty -> .)
    NOT             shift and go to state 23
    MINUS           shift and go to state 22
    INT             shift and go to state 24
    FLOAT           shift and go to state 25
    TRUE            shift and go to state 26
    FALSE           shift and go to state 27
    LPAREN          shift and go to state 17
    STRING          shift and go to state 28
    INT_TYPE        shift and go to state 29
    FLOAT_TYPE      shift and go to state 30
    STRING_TYPE     shift and go to state 31
    VOID_TYPE       shift and go to state 32
    PRINT           shift and go to state 33

    expression                     shift and go to state 5
    language                       shift and go to state 153
    line                           shift and go to state 4
    var_assign                     shift and go to state 6
    func_assign                    shift and go to state 7
    iterative                      shift and go to state 8
    conditional                    shift and go to state 9
    output                         shift and go to state 10
    input                          shift and go to state 11
    empty                          shift and go to state 74
    math                           shift and go to state 13
    str                            shift and go to state 14
    datatype                       shift and go to state 16
    output_print                   shift and go to state 20

state 151

    (14) return_stmt -> RETURN expression NEWLINE .

    STOP            reduce using rule 14 (return_stmt -> RETURN expression NEWLINE .)


state 152

    (74) else_block -> ELSE START NEWLINE language . STOP
    (3) language -> language . NEWLINE line

    STOP            shift and go to state 154
    NEWLINE         shift and go to state 34


state 153

    (73) else_if_block -> ELSE_IF expression START NEWLINE language . STOP
    (3) language -> language . NEWLINE line

    STOP            shift and go to state 155
    NEWLINE         shift and go to state 34


state 154

    (74) else_block -> ELSE START NEWLINE language STOP .

    NEWLINE         reduce using rule 74 (else_block -> ELSE START NEWLINE language STOP .)
    $end            reduce using rule 74 (else_block -> ELSE START NEWLINE language STOP .)
    STOP            reduce using rule 74 (else_block -> ELSE START NEWLINE language STOP .)
    RETURN          reduce using rule 74 (else_block -> ELSE START NEWLINE language STOP .)


state 155

    (73) else_if_block -> ELSE_IF expression START NEWLINE language STOP .

    ELSE_IF         reduce using rule 73 (else_if_block -> ELSE_IF expression START NEWLINE language STOP .)
    ELSE            reduce using rule 73 (else_if_block -> ELSE_IF expression START NEWLINE language STOP .)
    NEWLINE         reduce using rule 73 (else_if_block -> ELSE_IF expression START NEWLINE language STOP .)
    $end            reduce using rule 73 (else_if_block -> ELSE_IF expression START NEWLINE language STOP .)
    STOP            reduce using rule 73 (else_if_block -> ELSE_IF expression START NEWLINE language STOP .)
    RETURN          reduce using rule 73 (else_if_block -> ELSE_IF expression START NEWLINE language STOP .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: reduce/reduce conflict in state 3 resolved using rule (start -> empty)
WARNING: rejected rule (line -> empty) in state 3
WARNING: reduce/reduce conflict in state 12 resolved using rule (expression -> NAME)
WARNING: rejected rule (math -> NAME) in state 12
WARNING: reduce/reduce conflict in state 12 resolved using rule (math -> NAME)
WARNING: rejected rule (str -> NAME) in state 12
WARNING: reduce/reduce conflict in state 12 resolved using rule (expression -> NAME)
WARNING: rejected rule (str -> NAME) in state 12
WARNING: reduce/reduce conflict in state 60 resolved using rule (math -> NAME)
WARNING: rejected rule (str -> NAME) in state 60
WARNING: reduce/reduce conflict in state 65 resolved using rule (expression -> NAME)
WARNING: rejected rule (math -> NAME) in state 65
WARNING: reduce/reduce conflict in state 65 resolved using rule (math -> NAME)
WARNING: rejected rule (str -> NAME) in state 65
WARNING: reduce/reduce conflict in state 65 resolved using rule (expression -> NAME)
WARNING: rejected rule (str -> NAME) in state 65
