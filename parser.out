Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> start
Rule 1     start -> language
Rule 2     start -> empty
Rule 3     language -> language NEWLINE line
Rule 4     language -> line
Rule 5     line -> expression
Rule 6     line -> var_assign
Rule 7     line -> func_assign
Rule 8     line -> iterative
Rule 9     line -> conditional
Rule 10    line -> func_call
Rule 11    line -> output
Rule 12    line -> input
Rule 13    line -> empty
Rule 14    func_call -> NAME LPAREN pars RPAREN
Rule 15    pars -> expression
Rule 16    pars -> expression COMMA expression
Rule 17    func_assign -> datatype NAME LPAREN parameters RPAREN START NEWLINE language return_stmt STOP
Rule 18    return_stmt -> RETURN expression NEWLINE
Rule 19    return_stmt -> RETURN NEWLINE
Rule 20    return_stmt -> empty
Rule 21    parameters -> first_param
Rule 22    parameters -> empty
Rule 23    first_param -> datatype NAME COMMA first_param
Rule 24    first_param -> datatype NAME
Rule 25    datatype -> INT_TYPE
Rule 26    datatype -> FLOAT_TYPE
Rule 27    datatype -> STRING_TYPE
Rule 28    datatype -> VOID_TYPE
Rule 29    input -> READ LPAREN NAME RPAREN
Rule 30    output -> output_print
Rule 31    output_print -> PRINT LPAREN expression RPAREN
Rule 32    expression -> NAME
Rule 33    var_assign -> datatype NAME EQUALS expression
Rule 34    var_assign -> NAME EQUALS expression
Rule 35    expression -> math
Rule 36    expression -> str
Rule 37    math -> math MULTIPLY math
Rule 38    math -> math DIVIDE math
Rule 39    math -> math MODULO math
Rule 40    math -> math PLUS math
Rule 41    math -> math MINUS math
Rule 42    math -> math LD math
Rule 43    math -> math LDEQ math
Rule 44    math -> math GD math
Rule 45    math -> math GDEQ math
Rule 46    math -> math EQUALEQUAL math
Rule 47    math -> math NOTEQ math
Rule 48    math -> math AND math
Rule 49    math -> math OR math
Rule 50    math -> NOT math
Rule 51    math -> MINUS math
Rule 52    math -> INT
Rule 53    math -> FLOAT
Rule 54    math -> TRUE
Rule 55    math -> FALSE
Rule 56    str -> str PLUS str
Rule 57    str -> str LD str
Rule 58    str -> str LDEQ str
Rule 59    str -> str GD str
Rule 60    str -> str GDEQ str
Rule 61    str -> str EQUALEQUAL str
Rule 62    str -> str NOTEQ str
Rule 63    str -> STRING
Rule 64    math -> NAME
Rule 65    str -> NAME
Rule 66    expression -> LBRACE int_type_array RBRACE
Rule 67    expression -> LBRACE string_type_array RBRACE
Rule 68    int_type_array -> math
Rule 69    int_type_array -> math COMMA int_type_array
Rule 70    string_type_array -> str
Rule 71    string_type_array -> str COMMA string_type_array
Rule 72    math -> LPAREN math RPAREN
Rule 73    str -> LPAREN str RPAREN
Rule 74    conditional -> IF expression START NEWLINE language STOP else_if_blocks else_block
Rule 75    else_if_blocks -> empty
Rule 76    else_if_blocks -> else_if_block else_if_blocks
Rule 77    else_if_block -> ELSE_IF expression START NEWLINE language STOP
Rule 78    else_block -> ELSE START NEWLINE language STOP
Rule 79    else_block -> empty
Rule 80    iterative -> WHILE expression START NEWLINE language STOP
Rule 81    empty -> <empty>

Terminals, with rules where they appear

AND                  : 48
COMMA                : 16 23 69 71
DIVIDE               : 38
ELSE                 : 78
ELSE_IF              : 77
EQUALEQUAL           : 46 61
EQUALS               : 33 34
FALSE                : 55
FLOAT                : 53
FLOAT_TYPE           : 26
GD                   : 44 59
GDEQ                 : 45 60
IF                   : 74
INT                  : 52
INT_TYPE             : 25
LBRACE               : 66 67
LD                   : 42 57
LDEQ                 : 43 58
LPAREN               : 14 17 29 31 72 73
MINUS                : 41 51
MODULO               : 39
MULTIPLY             : 37
NAME                 : 14 17 23 24 29 32 33 34 64 65
NEWLINE              : 3 17 18 19 74 77 78 80
NOT                  : 50
NOTEQ                : 47 62
OR                   : 49
PLUS                 : 40 56
PRINT                : 31
RBRACE               : 66 67
READ                 : 29
RETURN               : 18 19
RPAREN               : 14 17 29 31 72 73
START                : 17 74 77 78 80
STOP                 : 17 74 77 78 80
STRING               : 63
STRING_TYPE          : 27
TRUE                 : 54
VOID_TYPE            : 28
WHILE                : 80
error                : 

Nonterminals, with rules where they appear

conditional          : 9
datatype             : 17 23 24 33
else_block           : 74
else_if_block        : 76
else_if_blocks       : 74 76
empty                : 2 13 20 22 75 79
expression           : 5 15 16 16 18 31 33 34 74 77 80
first_param          : 21 23
func_assign          : 7
func_call            : 10
input                : 12
int_type_array       : 66 69
iterative            : 8
language             : 1 3 17 74 77 78 80
line                 : 3 4
math                 : 35 37 37 38 38 39 39 40 40 41 41 42 42 43 43 44 44 45 45 46 46 47 47 48 48 49 49 50 51 68 69 72
output               : 11
output_print         : 30
parameters           : 17
pars                 : 14
return_stmt          : 17
start                : 0
str                  : 36 56 56 57 57 58 58 59 59 60 60 61 61 62 62 70 71 73
string_type_array    : 67 71
var_assign           : 6

Parsing method: LALR

state 0

    (0) S' -> . start
    (1) start -> . language
    (2) start -> . empty
    (3) language -> . language NEWLINE line
    (4) language -> . line
    (81) empty -> .
    (5) line -> . expression
    (6) line -> . var_assign
    (7) line -> . func_assign
    (8) line -> . iterative
    (9) line -> . conditional
    (10) line -> . func_call
    (11) line -> . output
    (12) line -> . input
    (13) line -> . empty
    (32) expression -> . NAME
    (35) expression -> . math
    (36) expression -> . str
    (66) expression -> . LBRACE int_type_array RBRACE
    (67) expression -> . LBRACE string_type_array RBRACE
    (33) var_assign -> . datatype NAME EQUALS expression
    (34) var_assign -> . NAME EQUALS expression
    (17) func_assign -> . datatype NAME LPAREN parameters RPAREN START NEWLINE language return_stmt STOP
    (80) iterative -> . WHILE expression START NEWLINE language STOP
    (74) conditional -> . IF expression START NEWLINE language STOP else_if_blocks else_block
    (14) func_call -> . NAME LPAREN pars RPAREN
    (30) output -> . output_print
    (29) input -> . READ LPAREN NAME RPAREN
    (37) math -> . math MULTIPLY math
    (38) math -> . math DIVIDE math
    (39) math -> . math MODULO math
    (40) math -> . math PLUS math
    (41) math -> . math MINUS math
    (42) math -> . math LD math
    (43) math -> . math LDEQ math
    (44) math -> . math GD math
    (45) math -> . math GDEQ math
    (46) math -> . math EQUALEQUAL math
    (47) math -> . math NOTEQ math
    (48) math -> . math AND math
    (49) math -> . math OR math
    (50) math -> . NOT math
    (51) math -> . MINUS math
    (52) math -> . INT
    (53) math -> . FLOAT
    (54) math -> . TRUE
    (55) math -> . FALSE
    (64) math -> . NAME
    (72) math -> . LPAREN math RPAREN
    (56) str -> . str PLUS str
    (57) str -> . str LD str
    (58) str -> . str LDEQ str
    (59) str -> . str GD str
    (60) str -> . str GDEQ str
    (61) str -> . str EQUALEQUAL str
    (62) str -> . str NOTEQ str
    (63) str -> . STRING
    (65) str -> . NAME
    (73) str -> . LPAREN str RPAREN
    (25) datatype -> . INT_TYPE
    (26) datatype -> . FLOAT_TYPE
    (27) datatype -> . STRING_TYPE
    (28) datatype -> . VOID_TYPE
    (31) output_print -> . PRINT LPAREN expression RPAREN

    $end            reduce using rule 81 (empty -> .)
    NEWLINE         reduce using rule 81 (empty -> .)
    NAME            shift and go to state 13
    LBRACE          shift and go to state 16
    WHILE           shift and go to state 19
    IF              shift and go to state 20
    READ            shift and go to state 22
    NOT             shift and go to state 24
    MINUS           shift and go to state 23
    INT             shift and go to state 25
    FLOAT           shift and go to state 26
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    LPAREN          shift and go to state 18
    STRING          shift and go to state 29
    INT_TYPE        shift and go to state 30
    FLOAT_TYPE      shift and go to state 31
    STRING_TYPE     shift and go to state 32
    VOID_TYPE       shift and go to state 33
    PRINT           shift and go to state 34

    start                          shift and go to state 1
    language                       shift and go to state 2
    empty                          shift and go to state 3
    line                           shift and go to state 4
    expression                     shift and go to state 5
    var_assign                     shift and go to state 6
    func_assign                    shift and go to state 7
    iterative                      shift and go to state 8
    conditional                    shift and go to state 9
    func_call                      shift and go to state 10
    output                         shift and go to state 11
    input                          shift and go to state 12
    math                           shift and go to state 14
    str                            shift and go to state 15
    datatype                       shift and go to state 17
    output_print                   shift and go to state 21

state 1

    (0) S' -> start .



state 2

    (1) start -> language .
    (3) language -> language . NEWLINE line

    $end            reduce using rule 1 (start -> language .)
    NEWLINE         shift and go to state 35


state 3

    (2) start -> empty .
    (13) line -> empty .

  ! reduce/reduce conflict for $end resolved using rule 2 (start -> empty .)
    $end            reduce using rule 2 (start -> empty .)
    NEWLINE         reduce using rule 13 (line -> empty .)

  ! $end            [ reduce using rule 13 (line -> empty .) ]


state 4

    (4) language -> line .

    NEWLINE         reduce using rule 4 (language -> line .)
    $end            reduce using rule 4 (language -> line .)
    STOP            reduce using rule 4 (language -> line .)
    RETURN          reduce using rule 4 (language -> line .)


state 5

    (5) line -> expression .

    NEWLINE         reduce using rule 5 (line -> expression .)
    $end            reduce using rule 5 (line -> expression .)
    STOP            reduce using rule 5 (line -> expression .)
    RETURN          reduce using rule 5 (line -> expression .)


state 6

    (6) line -> var_assign .

    NEWLINE         reduce using rule 6 (line -> var_assign .)
    $end            reduce using rule 6 (line -> var_assign .)
    STOP            reduce using rule 6 (line -> var_assign .)
    RETURN          reduce using rule 6 (line -> var_assign .)


state 7

    (7) line -> func_assign .

    NEWLINE         reduce using rule 7 (line -> func_assign .)
    $end            reduce using rule 7 (line -> func_assign .)
    STOP            reduce using rule 7 (line -> func_assign .)
    RETURN          reduce using rule 7 (line -> func_assign .)


state 8

    (8) line -> iterative .

    NEWLINE         reduce using rule 8 (line -> iterative .)
    $end            reduce using rule 8 (line -> iterative .)
    STOP            reduce using rule 8 (line -> iterative .)
    RETURN          reduce using rule 8 (line -> iterative .)


state 9

    (9) line -> conditional .

    NEWLINE         reduce using rule 9 (line -> conditional .)
    $end            reduce using rule 9 (line -> conditional .)
    STOP            reduce using rule 9 (line -> conditional .)
    RETURN          reduce using rule 9 (line -> conditional .)


state 10

    (10) line -> func_call .

    NEWLINE         reduce using rule 10 (line -> func_call .)
    $end            reduce using rule 10 (line -> func_call .)
    STOP            reduce using rule 10 (line -> func_call .)
    RETURN          reduce using rule 10 (line -> func_call .)


state 11

    (11) line -> output .

    NEWLINE         reduce using rule 11 (line -> output .)
    $end            reduce using rule 11 (line -> output .)
    STOP            reduce using rule 11 (line -> output .)
    RETURN          reduce using rule 11 (line -> output .)


state 12

    (12) line -> input .

    NEWLINE         reduce using rule 12 (line -> input .)
    $end            reduce using rule 12 (line -> input .)
    STOP            reduce using rule 12 (line -> input .)
    RETURN          reduce using rule 12 (line -> input .)


state 13

    (32) expression -> NAME .
    (34) var_assign -> NAME . EQUALS expression
    (14) func_call -> NAME . LPAREN pars RPAREN
    (64) math -> NAME .
    (65) str -> NAME .

  ! reduce/reduce conflict for NEWLINE resolved using rule 32 (expression -> NAME .)
  ! reduce/reduce conflict for $end resolved using rule 32 (expression -> NAME .)
  ! reduce/reduce conflict for STOP resolved using rule 32 (expression -> NAME .)
  ! reduce/reduce conflict for RETURN resolved using rule 32 (expression -> NAME .)
  ! reduce/reduce conflict for PLUS resolved using rule 64 (math -> NAME .)
  ! reduce/reduce conflict for LD resolved using rule 64 (math -> NAME .)
  ! reduce/reduce conflict for LDEQ resolved using rule 64 (math -> NAME .)
  ! reduce/reduce conflict for GD resolved using rule 64 (math -> NAME .)
  ! reduce/reduce conflict for GDEQ resolved using rule 64 (math -> NAME .)
  ! reduce/reduce conflict for EQUALEQUAL resolved using rule 64 (math -> NAME .)
  ! reduce/reduce conflict for NOTEQ resolved using rule 64 (math -> NAME .)
  ! reduce/reduce conflict for NEWLINE resolved using rule 32 (expression -> NAME .)
  ! reduce/reduce conflict for $end resolved using rule 32 (expression -> NAME .)
  ! reduce/reduce conflict for STOP resolved using rule 32 (expression -> NAME .)
  ! reduce/reduce conflict for RETURN resolved using rule 32 (expression -> NAME .)
    NEWLINE         reduce using rule 32 (expression -> NAME .)
    $end            reduce using rule 32 (expression -> NAME .)
    STOP            reduce using rule 32 (expression -> NAME .)
    RETURN          reduce using rule 32 (expression -> NAME .)
    EQUALS          shift and go to state 36
    LPAREN          shift and go to state 37
    MULTIPLY        reduce using rule 64 (math -> NAME .)
    DIVIDE          reduce using rule 64 (math -> NAME .)
    MODULO          reduce using rule 64 (math -> NAME .)
    PLUS            reduce using rule 64 (math -> NAME .)
    MINUS           reduce using rule 64 (math -> NAME .)
    LD              reduce using rule 64 (math -> NAME .)
    LDEQ            reduce using rule 64 (math -> NAME .)
    GD              reduce using rule 64 (math -> NAME .)
    GDEQ            reduce using rule 64 (math -> NAME .)
    EQUALEQUAL      reduce using rule 64 (math -> NAME .)
    NOTEQ           reduce using rule 64 (math -> NAME .)
    AND             reduce using rule 64 (math -> NAME .)
    OR              reduce using rule 64 (math -> NAME .)

  ! NEWLINE         [ reduce using rule 64 (math -> NAME .) ]
  ! $end            [ reduce using rule 64 (math -> NAME .) ]
  ! STOP            [ reduce using rule 64 (math -> NAME .) ]
  ! RETURN          [ reduce using rule 64 (math -> NAME .) ]
  ! PLUS            [ reduce using rule 65 (str -> NAME .) ]
  ! LD              [ reduce using rule 65 (str -> NAME .) ]
  ! LDEQ            [ reduce using rule 65 (str -> NAME .) ]
  ! GD              [ reduce using rule 65 (str -> NAME .) ]
  ! GDEQ            [ reduce using rule 65 (str -> NAME .) ]
  ! EQUALEQUAL      [ reduce using rule 65 (str -> NAME .) ]
  ! NOTEQ           [ reduce using rule 65 (str -> NAME .) ]
  ! NEWLINE         [ reduce using rule 65 (str -> NAME .) ]
  ! $end            [ reduce using rule 65 (str -> NAME .) ]
  ! STOP            [ reduce using rule 65 (str -> NAME .) ]
  ! RETURN          [ reduce using rule 65 (str -> NAME .) ]


state 14

    (35) expression -> math .
    (37) math -> math . MULTIPLY math
    (38) math -> math . DIVIDE math
    (39) math -> math . MODULO math
    (40) math -> math . PLUS math
    (41) math -> math . MINUS math
    (42) math -> math . LD math
    (43) math -> math . LDEQ math
    (44) math -> math . GD math
    (45) math -> math . GDEQ math
    (46) math -> math . EQUALEQUAL math
    (47) math -> math . NOTEQ math
    (48) math -> math . AND math
    (49) math -> math . OR math

    NEWLINE         reduce using rule 35 (expression -> math .)
    $end            reduce using rule 35 (expression -> math .)
    START           reduce using rule 35 (expression -> math .)
    STOP            reduce using rule 35 (expression -> math .)
    RETURN          reduce using rule 35 (expression -> math .)
    COMMA           reduce using rule 35 (expression -> math .)
    RPAREN          reduce using rule 35 (expression -> math .)
    MULTIPLY        shift and go to state 38
    DIVIDE          shift and go to state 39
    MODULO          shift and go to state 40
    PLUS            shift and go to state 41
    MINUS           shift and go to state 42
    LD              shift and go to state 43
    LDEQ            shift and go to state 44
    GD              shift and go to state 45
    GDEQ            shift and go to state 46
    EQUALEQUAL      shift and go to state 47
    NOTEQ           shift and go to state 48
    AND             shift and go to state 49
    OR              shift and go to state 50


state 15

    (36) expression -> str .
    (56) str -> str . PLUS str
    (57) str -> str . LD str
    (58) str -> str . LDEQ str
    (59) str -> str . GD str
    (60) str -> str . GDEQ str
    (61) str -> str . EQUALEQUAL str
    (62) str -> str . NOTEQ str

    NEWLINE         reduce using rule 36 (expression -> str .)
    $end            reduce using rule 36 (expression -> str .)
    START           reduce using rule 36 (expression -> str .)
    STOP            reduce using rule 36 (expression -> str .)
    RETURN          reduce using rule 36 (expression -> str .)
    COMMA           reduce using rule 36 (expression -> str .)
    RPAREN          reduce using rule 36 (expression -> str .)
    PLUS            shift and go to state 51
    LD              shift and go to state 52
    LDEQ            shift and go to state 53
    GD              shift and go to state 54
    GDEQ            shift and go to state 55
    EQUALEQUAL      shift and go to state 56
    NOTEQ           shift and go to state 57


state 16

    (66) expression -> LBRACE . int_type_array RBRACE
    (67) expression -> LBRACE . string_type_array RBRACE
    (68) int_type_array -> . math
    (69) int_type_array -> . math COMMA int_type_array
    (70) string_type_array -> . str
    (71) string_type_array -> . str COMMA string_type_array
    (37) math -> . math MULTIPLY math
    (38) math -> . math DIVIDE math
    (39) math -> . math MODULO math
    (40) math -> . math PLUS math
    (41) math -> . math MINUS math
    (42) math -> . math LD math
    (43) math -> . math LDEQ math
    (44) math -> . math GD math
    (45) math -> . math GDEQ math
    (46) math -> . math EQUALEQUAL math
    (47) math -> . math NOTEQ math
    (48) math -> . math AND math
    (49) math -> . math OR math
    (50) math -> . NOT math
    (51) math -> . MINUS math
    (52) math -> . INT
    (53) math -> . FLOAT
    (54) math -> . TRUE
    (55) math -> . FALSE
    (64) math -> . NAME
    (72) math -> . LPAREN math RPAREN
    (56) str -> . str PLUS str
    (57) str -> . str LD str
    (58) str -> . str LDEQ str
    (59) str -> . str GD str
    (60) str -> . str GDEQ str
    (61) str -> . str EQUALEQUAL str
    (62) str -> . str NOTEQ str
    (63) str -> . STRING
    (65) str -> . NAME
    (73) str -> . LPAREN str RPAREN

    NOT             shift and go to state 24
    MINUS           shift and go to state 23
    INT             shift and go to state 25
    FLOAT           shift and go to state 26
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    NAME            shift and go to state 62
    LPAREN          shift and go to state 18
    STRING          shift and go to state 29

    int_type_array                 shift and go to state 58
    string_type_array              shift and go to state 59
    math                           shift and go to state 60
    str                            shift and go to state 61

state 17

    (33) var_assign -> datatype . NAME EQUALS expression
    (17) func_assign -> datatype . NAME LPAREN parameters RPAREN START NEWLINE language return_stmt STOP

    NAME            shift and go to state 63


state 18

    (72) math -> LPAREN . math RPAREN
    (73) str -> LPAREN . str RPAREN
    (37) math -> . math MULTIPLY math
    (38) math -> . math DIVIDE math
    (39) math -> . math MODULO math
    (40) math -> . math PLUS math
    (41) math -> . math MINUS math
    (42) math -> . math LD math
    (43) math -> . math LDEQ math
    (44) math -> . math GD math
    (45) math -> . math GDEQ math
    (46) math -> . math EQUALEQUAL math
    (47) math -> . math NOTEQ math
    (48) math -> . math AND math
    (49) math -> . math OR math
    (50) math -> . NOT math
    (51) math -> . MINUS math
    (52) math -> . INT
    (53) math -> . FLOAT
    (54) math -> . TRUE
    (55) math -> . FALSE
    (64) math -> . NAME
    (72) math -> . LPAREN math RPAREN
    (56) str -> . str PLUS str
    (57) str -> . str LD str
    (58) str -> . str LDEQ str
    (59) str -> . str GD str
    (60) str -> . str GDEQ str
    (61) str -> . str EQUALEQUAL str
    (62) str -> . str NOTEQ str
    (63) str -> . STRING
    (65) str -> . NAME
    (73) str -> . LPAREN str RPAREN

    NOT             shift and go to state 24
    MINUS           shift and go to state 23
    INT             shift and go to state 25
    FLOAT           shift and go to state 26
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    NAME            shift and go to state 62
    LPAREN          shift and go to state 18
    STRING          shift and go to state 29

    math                           shift and go to state 64
    str                            shift and go to state 65

state 19

    (80) iterative -> WHILE . expression START NEWLINE language STOP
    (32) expression -> . NAME
    (35) expression -> . math
    (36) expression -> . str
    (66) expression -> . LBRACE int_type_array RBRACE
    (67) expression -> . LBRACE string_type_array RBRACE
    (37) math -> . math MULTIPLY math
    (38) math -> . math DIVIDE math
    (39) math -> . math MODULO math
    (40) math -> . math PLUS math
    (41) math -> . math MINUS math
    (42) math -> . math LD math
    (43) math -> . math LDEQ math
    (44) math -> . math GD math
    (45) math -> . math GDEQ math
    (46) math -> . math EQUALEQUAL math
    (47) math -> . math NOTEQ math
    (48) math -> . math AND math
    (49) math -> . math OR math
    (50) math -> . NOT math
    (51) math -> . MINUS math
    (52) math -> . INT
    (53) math -> . FLOAT
    (54) math -> . TRUE
    (55) math -> . FALSE
    (64) math -> . NAME
    (72) math -> . LPAREN math RPAREN
    (56) str -> . str PLUS str
    (57) str -> . str LD str
    (58) str -> . str LDEQ str
    (59) str -> . str GD str
    (60) str -> . str GDEQ str
    (61) str -> . str EQUALEQUAL str
    (62) str -> . str NOTEQ str
    (63) str -> . STRING
    (65) str -> . NAME
    (73) str -> . LPAREN str RPAREN

    NAME            shift and go to state 67
    LBRACE          shift and go to state 16
    NOT             shift and go to state 24
    MINUS           shift and go to state 23
    INT             shift and go to state 25
    FLOAT           shift and go to state 26
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    LPAREN          shift and go to state 18
    STRING          shift and go to state 29

    expression                     shift and go to state 66
    math                           shift and go to state 14
    str                            shift and go to state 15

state 20

    (74) conditional -> IF . expression START NEWLINE language STOP else_if_blocks else_block
    (32) expression -> . NAME
    (35) expression -> . math
    (36) expression -> . str
    (66) expression -> . LBRACE int_type_array RBRACE
    (67) expression -> . LBRACE string_type_array RBRACE
    (37) math -> . math MULTIPLY math
    (38) math -> . math DIVIDE math
    (39) math -> . math MODULO math
    (40) math -> . math PLUS math
    (41) math -> . math MINUS math
    (42) math -> . math LD math
    (43) math -> . math LDEQ math
    (44) math -> . math GD math
    (45) math -> . math GDEQ math
    (46) math -> . math EQUALEQUAL math
    (47) math -> . math NOTEQ math
    (48) math -> . math AND math
    (49) math -> . math OR math
    (50) math -> . NOT math
    (51) math -> . MINUS math
    (52) math -> . INT
    (53) math -> . FLOAT
    (54) math -> . TRUE
    (55) math -> . FALSE
    (64) math -> . NAME
    (72) math -> . LPAREN math RPAREN
    (56) str -> . str PLUS str
    (57) str -> . str LD str
    (58) str -> . str LDEQ str
    (59) str -> . str GD str
    (60) str -> . str GDEQ str
    (61) str -> . str EQUALEQUAL str
    (62) str -> . str NOTEQ str
    (63) str -> . STRING
    (65) str -> . NAME
    (73) str -> . LPAREN str RPAREN

    NAME            shift and go to state 67
    LBRACE          shift and go to state 16
    NOT             shift and go to state 24
    MINUS           shift and go to state 23
    INT             shift and go to state 25
    FLOAT           shift and go to state 26
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    LPAREN          shift and go to state 18
    STRING          shift and go to state 29

    expression                     shift and go to state 68
    math                           shift and go to state 14
    str                            shift and go to state 15

state 21

    (30) output -> output_print .

    NEWLINE         reduce using rule 30 (output -> output_print .)
    $end            reduce using rule 30 (output -> output_print .)
    STOP            reduce using rule 30 (output -> output_print .)
    RETURN          reduce using rule 30 (output -> output_print .)


state 22

    (29) input -> READ . LPAREN NAME RPAREN

    LPAREN          shift and go to state 69


state 23

    (51) math -> MINUS . math
    (37) math -> . math MULTIPLY math
    (38) math -> . math DIVIDE math
    (39) math -> . math MODULO math
    (40) math -> . math PLUS math
    (41) math -> . math MINUS math
    (42) math -> . math LD math
    (43) math -> . math LDEQ math
    (44) math -> . math GD math
    (45) math -> . math GDEQ math
    (46) math -> . math EQUALEQUAL math
    (47) math -> . math NOTEQ math
    (48) math -> . math AND math
    (49) math -> . math OR math
    (50) math -> . NOT math
    (51) math -> . MINUS math
    (52) math -> . INT
    (53) math -> . FLOAT
    (54) math -> . TRUE
    (55) math -> . FALSE
    (64) math -> . NAME
    (72) math -> . LPAREN math RPAREN

    NOT             shift and go to state 24
    MINUS           shift and go to state 23
    INT             shift and go to state 25
    FLOAT           shift and go to state 26
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    NAME            shift and go to state 71
    LPAREN          shift and go to state 72

    math                           shift and go to state 70

state 24

    (50) math -> NOT . math
    (37) math -> . math MULTIPLY math
    (38) math -> . math DIVIDE math
    (39) math -> . math MODULO math
    (40) math -> . math PLUS math
    (41) math -> . math MINUS math
    (42) math -> . math LD math
    (43) math -> . math LDEQ math
    (44) math -> . math GD math
    (45) math -> . math GDEQ math
    (46) math -> . math EQUALEQUAL math
    (47) math -> . math NOTEQ math
    (48) math -> . math AND math
    (49) math -> . math OR math
    (50) math -> . NOT math
    (51) math -> . MINUS math
    (52) math -> . INT
    (53) math -> . FLOAT
    (54) math -> . TRUE
    (55) math -> . FALSE
    (64) math -> . NAME
    (72) math -> . LPAREN math RPAREN

    NOT             shift and go to state 24
    MINUS           shift and go to state 23
    INT             shift and go to state 25
    FLOAT           shift and go to state 26
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    NAME            shift and go to state 71
    LPAREN          shift and go to state 72

    math                           shift and go to state 73

state 25

    (52) math -> INT .

    MULTIPLY        reduce using rule 52 (math -> INT .)
    DIVIDE          reduce using rule 52 (math -> INT .)
    MODULO          reduce using rule 52 (math -> INT .)
    PLUS            reduce using rule 52 (math -> INT .)
    MINUS           reduce using rule 52 (math -> INT .)
    LD              reduce using rule 52 (math -> INT .)
    LDEQ            reduce using rule 52 (math -> INT .)
    GD              reduce using rule 52 (math -> INT .)
    GDEQ            reduce using rule 52 (math -> INT .)
    EQUALEQUAL      reduce using rule 52 (math -> INT .)
    NOTEQ           reduce using rule 52 (math -> INT .)
    AND             reduce using rule 52 (math -> INT .)
    OR              reduce using rule 52 (math -> INT .)
    NEWLINE         reduce using rule 52 (math -> INT .)
    $end            reduce using rule 52 (math -> INT .)
    COMMA           reduce using rule 52 (math -> INT .)
    RBRACE          reduce using rule 52 (math -> INT .)
    RPAREN          reduce using rule 52 (math -> INT .)
    START           reduce using rule 52 (math -> INT .)
    STOP            reduce using rule 52 (math -> INT .)
    RETURN          reduce using rule 52 (math -> INT .)


state 26

    (53) math -> FLOAT .

    MULTIPLY        reduce using rule 53 (math -> FLOAT .)
    DIVIDE          reduce using rule 53 (math -> FLOAT .)
    MODULO          reduce using rule 53 (math -> FLOAT .)
    PLUS            reduce using rule 53 (math -> FLOAT .)
    MINUS           reduce using rule 53 (math -> FLOAT .)
    LD              reduce using rule 53 (math -> FLOAT .)
    LDEQ            reduce using rule 53 (math -> FLOAT .)
    GD              reduce using rule 53 (math -> FLOAT .)
    GDEQ            reduce using rule 53 (math -> FLOAT .)
    EQUALEQUAL      reduce using rule 53 (math -> FLOAT .)
    NOTEQ           reduce using rule 53 (math -> FLOAT .)
    AND             reduce using rule 53 (math -> FLOAT .)
    OR              reduce using rule 53 (math -> FLOAT .)
    NEWLINE         reduce using rule 53 (math -> FLOAT .)
    $end            reduce using rule 53 (math -> FLOAT .)
    COMMA           reduce using rule 53 (math -> FLOAT .)
    RBRACE          reduce using rule 53 (math -> FLOAT .)
    RPAREN          reduce using rule 53 (math -> FLOAT .)
    START           reduce using rule 53 (math -> FLOAT .)
    STOP            reduce using rule 53 (math -> FLOAT .)
    RETURN          reduce using rule 53 (math -> FLOAT .)


state 27

    (54) math -> TRUE .

    MULTIPLY        reduce using rule 54 (math -> TRUE .)
    DIVIDE          reduce using rule 54 (math -> TRUE .)
    MODULO          reduce using rule 54 (math -> TRUE .)
    PLUS            reduce using rule 54 (math -> TRUE .)
    MINUS           reduce using rule 54 (math -> TRUE .)
    LD              reduce using rule 54 (math -> TRUE .)
    LDEQ            reduce using rule 54 (math -> TRUE .)
    GD              reduce using rule 54 (math -> TRUE .)
    GDEQ            reduce using rule 54 (math -> TRUE .)
    EQUALEQUAL      reduce using rule 54 (math -> TRUE .)
    NOTEQ           reduce using rule 54 (math -> TRUE .)
    AND             reduce using rule 54 (math -> TRUE .)
    OR              reduce using rule 54 (math -> TRUE .)
    NEWLINE         reduce using rule 54 (math -> TRUE .)
    $end            reduce using rule 54 (math -> TRUE .)
    COMMA           reduce using rule 54 (math -> TRUE .)
    RBRACE          reduce using rule 54 (math -> TRUE .)
    RPAREN          reduce using rule 54 (math -> TRUE .)
    START           reduce using rule 54 (math -> TRUE .)
    STOP            reduce using rule 54 (math -> TRUE .)
    RETURN          reduce using rule 54 (math -> TRUE .)


state 28

    (55) math -> FALSE .

    MULTIPLY        reduce using rule 55 (math -> FALSE .)
    DIVIDE          reduce using rule 55 (math -> FALSE .)
    MODULO          reduce using rule 55 (math -> FALSE .)
    PLUS            reduce using rule 55 (math -> FALSE .)
    MINUS           reduce using rule 55 (math -> FALSE .)
    LD              reduce using rule 55 (math -> FALSE .)
    LDEQ            reduce using rule 55 (math -> FALSE .)
    GD              reduce using rule 55 (math -> FALSE .)
    GDEQ            reduce using rule 55 (math -> FALSE .)
    EQUALEQUAL      reduce using rule 55 (math -> FALSE .)
    NOTEQ           reduce using rule 55 (math -> FALSE .)
    AND             reduce using rule 55 (math -> FALSE .)
    OR              reduce using rule 55 (math -> FALSE .)
    NEWLINE         reduce using rule 55 (math -> FALSE .)
    $end            reduce using rule 55 (math -> FALSE .)
    COMMA           reduce using rule 55 (math -> FALSE .)
    RBRACE          reduce using rule 55 (math -> FALSE .)
    RPAREN          reduce using rule 55 (math -> FALSE .)
    START           reduce using rule 55 (math -> FALSE .)
    STOP            reduce using rule 55 (math -> FALSE .)
    RETURN          reduce using rule 55 (math -> FALSE .)


state 29

    (63) str -> STRING .

    PLUS            reduce using rule 63 (str -> STRING .)
    LD              reduce using rule 63 (str -> STRING .)
    LDEQ            reduce using rule 63 (str -> STRING .)
    GD              reduce using rule 63 (str -> STRING .)
    GDEQ            reduce using rule 63 (str -> STRING .)
    EQUALEQUAL      reduce using rule 63 (str -> STRING .)
    NOTEQ           reduce using rule 63 (str -> STRING .)
    NEWLINE         reduce using rule 63 (str -> STRING .)
    $end            reduce using rule 63 (str -> STRING .)
    COMMA           reduce using rule 63 (str -> STRING .)
    RBRACE          reduce using rule 63 (str -> STRING .)
    RPAREN          reduce using rule 63 (str -> STRING .)
    START           reduce using rule 63 (str -> STRING .)
    STOP            reduce using rule 63 (str -> STRING .)
    RETURN          reduce using rule 63 (str -> STRING .)


state 30

    (25) datatype -> INT_TYPE .

    NAME            reduce using rule 25 (datatype -> INT_TYPE .)


state 31

    (26) datatype -> FLOAT_TYPE .

    NAME            reduce using rule 26 (datatype -> FLOAT_TYPE .)


state 32

    (27) datatype -> STRING_TYPE .

    NAME            reduce using rule 27 (datatype -> STRING_TYPE .)


state 33

    (28) datatype -> VOID_TYPE .

    NAME            reduce using rule 28 (datatype -> VOID_TYPE .)


state 34

    (31) output_print -> PRINT . LPAREN expression RPAREN

    LPAREN          shift and go to state 74


state 35

    (3) language -> language NEWLINE . line
    (5) line -> . expression
    (6) line -> . var_assign
    (7) line -> . func_assign
    (8) line -> . iterative
    (9) line -> . conditional
    (10) line -> . func_call
    (11) line -> . output
    (12) line -> . input
    (13) line -> . empty
    (32) expression -> . NAME
    (35) expression -> . math
    (36) expression -> . str
    (66) expression -> . LBRACE int_type_array RBRACE
    (67) expression -> . LBRACE string_type_array RBRACE
    (33) var_assign -> . datatype NAME EQUALS expression
    (34) var_assign -> . NAME EQUALS expression
    (17) func_assign -> . datatype NAME LPAREN parameters RPAREN START NEWLINE language return_stmt STOP
    (80) iterative -> . WHILE expression START NEWLINE language STOP
    (74) conditional -> . IF expression START NEWLINE language STOP else_if_blocks else_block
    (14) func_call -> . NAME LPAREN pars RPAREN
    (30) output -> . output_print
    (29) input -> . READ LPAREN NAME RPAREN
    (81) empty -> .
    (37) math -> . math MULTIPLY math
    (38) math -> . math DIVIDE math
    (39) math -> . math MODULO math
    (40) math -> . math PLUS math
    (41) math -> . math MINUS math
    (42) math -> . math LD math
    (43) math -> . math LDEQ math
    (44) math -> . math GD math
    (45) math -> . math GDEQ math
    (46) math -> . math EQUALEQUAL math
    (47) math -> . math NOTEQ math
    (48) math -> . math AND math
    (49) math -> . math OR math
    (50) math -> . NOT math
    (51) math -> . MINUS math
    (52) math -> . INT
    (53) math -> . FLOAT
    (54) math -> . TRUE
    (55) math -> . FALSE
    (64) math -> . NAME
    (72) math -> . LPAREN math RPAREN
    (56) str -> . str PLUS str
    (57) str -> . str LD str
    (58) str -> . str LDEQ str
    (59) str -> . str GD str
    (60) str -> . str GDEQ str
    (61) str -> . str EQUALEQUAL str
    (62) str -> . str NOTEQ str
    (63) str -> . STRING
    (65) str -> . NAME
    (73) str -> . LPAREN str RPAREN
    (25) datatype -> . INT_TYPE
    (26) datatype -> . FLOAT_TYPE
    (27) datatype -> . STRING_TYPE
    (28) datatype -> . VOID_TYPE
    (31) output_print -> . PRINT LPAREN expression RPAREN

    NAME            shift and go to state 13
    LBRACE          shift and go to state 16
    WHILE           shift and go to state 19
    IF              shift and go to state 20
    READ            shift and go to state 22
    NEWLINE         reduce using rule 81 (empty -> .)
    $end            reduce using rule 81 (empty -> .)
    STOP            reduce using rule 81 (empty -> .)
    RETURN          reduce using rule 81 (empty -> .)
    NOT             shift and go to state 24
    MINUS           shift and go to state 23
    INT             shift and go to state 25
    FLOAT           shift and go to state 26
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    LPAREN          shift and go to state 18
    STRING          shift and go to state 29
    INT_TYPE        shift and go to state 30
    FLOAT_TYPE      shift and go to state 31
    STRING_TYPE     shift and go to state 32
    VOID_TYPE       shift and go to state 33
    PRINT           shift and go to state 34

    line                           shift and go to state 75
    expression                     shift and go to state 5
    var_assign                     shift and go to state 6
    func_assign                    shift and go to state 7
    iterative                      shift and go to state 8
    conditional                    shift and go to state 9
    func_call                      shift and go to state 10
    output                         shift and go to state 11
    input                          shift and go to state 12
    empty                          shift and go to state 76
    math                           shift and go to state 14
    str                            shift and go to state 15
    datatype                       shift and go to state 17
    output_print                   shift and go to state 21

state 36

    (34) var_assign -> NAME EQUALS . expression
    (32) expression -> . NAME
    (35) expression -> . math
    (36) expression -> . str
    (66) expression -> . LBRACE int_type_array RBRACE
    (67) expression -> . LBRACE string_type_array RBRACE
    (37) math -> . math MULTIPLY math
    (38) math -> . math DIVIDE math
    (39) math -> . math MODULO math
    (40) math -> . math PLUS math
    (41) math -> . math MINUS math
    (42) math -> . math LD math
    (43) math -> . math LDEQ math
    (44) math -> . math GD math
    (45) math -> . math GDEQ math
    (46) math -> . math EQUALEQUAL math
    (47) math -> . math NOTEQ math
    (48) math -> . math AND math
    (49) math -> . math OR math
    (50) math -> . NOT math
    (51) math -> . MINUS math
    (52) math -> . INT
    (53) math -> . FLOAT
    (54) math -> . TRUE
    (55) math -> . FALSE
    (64) math -> . NAME
    (72) math -> . LPAREN math RPAREN
    (56) str -> . str PLUS str
    (57) str -> . str LD str
    (58) str -> . str LDEQ str
    (59) str -> . str GD str
    (60) str -> . str GDEQ str
    (61) str -> . str EQUALEQUAL str
    (62) str -> . str NOTEQ str
    (63) str -> . STRING
    (65) str -> . NAME
    (73) str -> . LPAREN str RPAREN

    NAME            shift and go to state 67
    LBRACE          shift and go to state 16
    NOT             shift and go to state 24
    MINUS           shift and go to state 23
    INT             shift and go to state 25
    FLOAT           shift and go to state 26
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    LPAREN          shift and go to state 18
    STRING          shift and go to state 29

    expression                     shift and go to state 77
    math                           shift and go to state 14
    str                            shift and go to state 15

state 37

    (14) func_call -> NAME LPAREN . pars RPAREN
    (15) pars -> . expression
    (16) pars -> . expression COMMA expression
    (32) expression -> . NAME
    (35) expression -> . math
    (36) expression -> . str
    (66) expression -> . LBRACE int_type_array RBRACE
    (67) expression -> . LBRACE string_type_array RBRACE
    (37) math -> . math MULTIPLY math
    (38) math -> . math DIVIDE math
    (39) math -> . math MODULO math
    (40) math -> . math PLUS math
    (41) math -> . math MINUS math
    (42) math -> . math LD math
    (43) math -> . math LDEQ math
    (44) math -> . math GD math
    (45) math -> . math GDEQ math
    (46) math -> . math EQUALEQUAL math
    (47) math -> . math NOTEQ math
    (48) math -> . math AND math
    (49) math -> . math OR math
    (50) math -> . NOT math
    (51) math -> . MINUS math
    (52) math -> . INT
    (53) math -> . FLOAT
    (54) math -> . TRUE
    (55) math -> . FALSE
    (64) math -> . NAME
    (72) math -> . LPAREN math RPAREN
    (56) str -> . str PLUS str
    (57) str -> . str LD str
    (58) str -> . str LDEQ str
    (59) str -> . str GD str
    (60) str -> . str GDEQ str
    (61) str -> . str EQUALEQUAL str
    (62) str -> . str NOTEQ str
    (63) str -> . STRING
    (65) str -> . NAME
    (73) str -> . LPAREN str RPAREN

    NAME            shift and go to state 67
    LBRACE          shift and go to state 16
    NOT             shift and go to state 24
    MINUS           shift and go to state 23
    INT             shift and go to state 25
    FLOAT           shift and go to state 26
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    LPAREN          shift and go to state 18
    STRING          shift and go to state 29

    pars                           shift and go to state 78
    expression                     shift and go to state 79
    math                           shift and go to state 14
    str                            shift and go to state 15

state 38

    (37) math -> math MULTIPLY . math
    (37) math -> . math MULTIPLY math
    (38) math -> . math DIVIDE math
    (39) math -> . math MODULO math
    (40) math -> . math PLUS math
    (41) math -> . math MINUS math
    (42) math -> . math LD math
    (43) math -> . math LDEQ math
    (44) math -> . math GD math
    (45) math -> . math GDEQ math
    (46) math -> . math EQUALEQUAL math
    (47) math -> . math NOTEQ math
    (48) math -> . math AND math
    (49) math -> . math OR math
    (50) math -> . NOT math
    (51) math -> . MINUS math
    (52) math -> . INT
    (53) math -> . FLOAT
    (54) math -> . TRUE
    (55) math -> . FALSE
    (64) math -> . NAME
    (72) math -> . LPAREN math RPAREN

    NOT             shift and go to state 24
    MINUS           shift and go to state 23
    INT             shift and go to state 25
    FLOAT           shift and go to state 26
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    NAME            shift and go to state 71
    LPAREN          shift and go to state 72

    math                           shift and go to state 80

state 39

    (38) math -> math DIVIDE . math
    (37) math -> . math MULTIPLY math
    (38) math -> . math DIVIDE math
    (39) math -> . math MODULO math
    (40) math -> . math PLUS math
    (41) math -> . math MINUS math
    (42) math -> . math LD math
    (43) math -> . math LDEQ math
    (44) math -> . math GD math
    (45) math -> . math GDEQ math
    (46) math -> . math EQUALEQUAL math
    (47) math -> . math NOTEQ math
    (48) math -> . math AND math
    (49) math -> . math OR math
    (50) math -> . NOT math
    (51) math -> . MINUS math
    (52) math -> . INT
    (53) math -> . FLOAT
    (54) math -> . TRUE
    (55) math -> . FALSE
    (64) math -> . NAME
    (72) math -> . LPAREN math RPAREN

    NOT             shift and go to state 24
    MINUS           shift and go to state 23
    INT             shift and go to state 25
    FLOAT           shift and go to state 26
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    NAME            shift and go to state 71
    LPAREN          shift and go to state 72

    math                           shift and go to state 81

state 40

    (39) math -> math MODULO . math
    (37) math -> . math MULTIPLY math
    (38) math -> . math DIVIDE math
    (39) math -> . math MODULO math
    (40) math -> . math PLUS math
    (41) math -> . math MINUS math
    (42) math -> . math LD math
    (43) math -> . math LDEQ math
    (44) math -> . math GD math
    (45) math -> . math GDEQ math
    (46) math -> . math EQUALEQUAL math
    (47) math -> . math NOTEQ math
    (48) math -> . math AND math
    (49) math -> . math OR math
    (50) math -> . NOT math
    (51) math -> . MINUS math
    (52) math -> . INT
    (53) math -> . FLOAT
    (54) math -> . TRUE
    (55) math -> . FALSE
    (64) math -> . NAME
    (72) math -> . LPAREN math RPAREN

    NOT             shift and go to state 24
    MINUS           shift and go to state 23
    INT             shift and go to state 25
    FLOAT           shift and go to state 26
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    NAME            shift and go to state 71
    LPAREN          shift and go to state 72

    math                           shift and go to state 82

state 41

    (40) math -> math PLUS . math
    (37) math -> . math MULTIPLY math
    (38) math -> . math DIVIDE math
    (39) math -> . math MODULO math
    (40) math -> . math PLUS math
    (41) math -> . math MINUS math
    (42) math -> . math LD math
    (43) math -> . math LDEQ math
    (44) math -> . math GD math
    (45) math -> . math GDEQ math
    (46) math -> . math EQUALEQUAL math
    (47) math -> . math NOTEQ math
    (48) math -> . math AND math
    (49) math -> . math OR math
    (50) math -> . NOT math
    (51) math -> . MINUS math
    (52) math -> . INT
    (53) math -> . FLOAT
    (54) math -> . TRUE
    (55) math -> . FALSE
    (64) math -> . NAME
    (72) math -> . LPAREN math RPAREN

    NOT             shift and go to state 24
    MINUS           shift and go to state 23
    INT             shift and go to state 25
    FLOAT           shift and go to state 26
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    NAME            shift and go to state 71
    LPAREN          shift and go to state 72

    math                           shift and go to state 83

state 42

    (41) math -> math MINUS . math
    (37) math -> . math MULTIPLY math
    (38) math -> . math DIVIDE math
    (39) math -> . math MODULO math
    (40) math -> . math PLUS math
    (41) math -> . math MINUS math
    (42) math -> . math LD math
    (43) math -> . math LDEQ math
    (44) math -> . math GD math
    (45) math -> . math GDEQ math
    (46) math -> . math EQUALEQUAL math
    (47) math -> . math NOTEQ math
    (48) math -> . math AND math
    (49) math -> . math OR math
    (50) math -> . NOT math
    (51) math -> . MINUS math
    (52) math -> . INT
    (53) math -> . FLOAT
    (54) math -> . TRUE
    (55) math -> . FALSE
    (64) math -> . NAME
    (72) math -> . LPAREN math RPAREN

    NOT             shift and go to state 24
    MINUS           shift and go to state 23
    INT             shift and go to state 25
    FLOAT           shift and go to state 26
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    NAME            shift and go to state 71
    LPAREN          shift and go to state 72

    math                           shift and go to state 84

state 43

    (42) math -> math LD . math
    (37) math -> . math MULTIPLY math
    (38) math -> . math DIVIDE math
    (39) math -> . math MODULO math
    (40) math -> . math PLUS math
    (41) math -> . math MINUS math
    (42) math -> . math LD math
    (43) math -> . math LDEQ math
    (44) math -> . math GD math
    (45) math -> . math GDEQ math
    (46) math -> . math EQUALEQUAL math
    (47) math -> . math NOTEQ math
    (48) math -> . math AND math
    (49) math -> . math OR math
    (50) math -> . NOT math
    (51) math -> . MINUS math
    (52) math -> . INT
    (53) math -> . FLOAT
    (54) math -> . TRUE
    (55) math -> . FALSE
    (64) math -> . NAME
    (72) math -> . LPAREN math RPAREN

    NOT             shift and go to state 24
    MINUS           shift and go to state 23
    INT             shift and go to state 25
    FLOAT           shift and go to state 26
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    NAME            shift and go to state 71
    LPAREN          shift and go to state 72

    math                           shift and go to state 85

state 44

    (43) math -> math LDEQ . math
    (37) math -> . math MULTIPLY math
    (38) math -> . math DIVIDE math
    (39) math -> . math MODULO math
    (40) math -> . math PLUS math
    (41) math -> . math MINUS math
    (42) math -> . math LD math
    (43) math -> . math LDEQ math
    (44) math -> . math GD math
    (45) math -> . math GDEQ math
    (46) math -> . math EQUALEQUAL math
    (47) math -> . math NOTEQ math
    (48) math -> . math AND math
    (49) math -> . math OR math
    (50) math -> . NOT math
    (51) math -> . MINUS math
    (52) math -> . INT
    (53) math -> . FLOAT
    (54) math -> . TRUE
    (55) math -> . FALSE
    (64) math -> . NAME
    (72) math -> . LPAREN math RPAREN

    NOT             shift and go to state 24
    MINUS           shift and go to state 23
    INT             shift and go to state 25
    FLOAT           shift and go to state 26
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    NAME            shift and go to state 71
    LPAREN          shift and go to state 72

    math                           shift and go to state 86

state 45

    (44) math -> math GD . math
    (37) math -> . math MULTIPLY math
    (38) math -> . math DIVIDE math
    (39) math -> . math MODULO math
    (40) math -> . math PLUS math
    (41) math -> . math MINUS math
    (42) math -> . math LD math
    (43) math -> . math LDEQ math
    (44) math -> . math GD math
    (45) math -> . math GDEQ math
    (46) math -> . math EQUALEQUAL math
    (47) math -> . math NOTEQ math
    (48) math -> . math AND math
    (49) math -> . math OR math
    (50) math -> . NOT math
    (51) math -> . MINUS math
    (52) math -> . INT
    (53) math -> . FLOAT
    (54) math -> . TRUE
    (55) math -> . FALSE
    (64) math -> . NAME
    (72) math -> . LPAREN math RPAREN

    NOT             shift and go to state 24
    MINUS           shift and go to state 23
    INT             shift and go to state 25
    FLOAT           shift and go to state 26
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    NAME            shift and go to state 71
    LPAREN          shift and go to state 72

    math                           shift and go to state 87

state 46

    (45) math -> math GDEQ . math
    (37) math -> . math MULTIPLY math
    (38) math -> . math DIVIDE math
    (39) math -> . math MODULO math
    (40) math -> . math PLUS math
    (41) math -> . math MINUS math
    (42) math -> . math LD math
    (43) math -> . math LDEQ math
    (44) math -> . math GD math
    (45) math -> . math GDEQ math
    (46) math -> . math EQUALEQUAL math
    (47) math -> . math NOTEQ math
    (48) math -> . math AND math
    (49) math -> . math OR math
    (50) math -> . NOT math
    (51) math -> . MINUS math
    (52) math -> . INT
    (53) math -> . FLOAT
    (54) math -> . TRUE
    (55) math -> . FALSE
    (64) math -> . NAME
    (72) math -> . LPAREN math RPAREN

    NOT             shift and go to state 24
    MINUS           shift and go to state 23
    INT             shift and go to state 25
    FLOAT           shift and go to state 26
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    NAME            shift and go to state 71
    LPAREN          shift and go to state 72

    math                           shift and go to state 88

state 47

    (46) math -> math EQUALEQUAL . math
    (37) math -> . math MULTIPLY math
    (38) math -> . math DIVIDE math
    (39) math -> . math MODULO math
    (40) math -> . math PLUS math
    (41) math -> . math MINUS math
    (42) math -> . math LD math
    (43) math -> . math LDEQ math
    (44) math -> . math GD math
    (45) math -> . math GDEQ math
    (46) math -> . math EQUALEQUAL math
    (47) math -> . math NOTEQ math
    (48) math -> . math AND math
    (49) math -> . math OR math
    (50) math -> . NOT math
    (51) math -> . MINUS math
    (52) math -> . INT
    (53) math -> . FLOAT
    (54) math -> . TRUE
    (55) math -> . FALSE
    (64) math -> . NAME
    (72) math -> . LPAREN math RPAREN

    NOT             shift and go to state 24
    MINUS           shift and go to state 23
    INT             shift and go to state 25
    FLOAT           shift and go to state 26
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    NAME            shift and go to state 71
    LPAREN          shift and go to state 72

    math                           shift and go to state 89

state 48

    (47) math -> math NOTEQ . math
    (37) math -> . math MULTIPLY math
    (38) math -> . math DIVIDE math
    (39) math -> . math MODULO math
    (40) math -> . math PLUS math
    (41) math -> . math MINUS math
    (42) math -> . math LD math
    (43) math -> . math LDEQ math
    (44) math -> . math GD math
    (45) math -> . math GDEQ math
    (46) math -> . math EQUALEQUAL math
    (47) math -> . math NOTEQ math
    (48) math -> . math AND math
    (49) math -> . math OR math
    (50) math -> . NOT math
    (51) math -> . MINUS math
    (52) math -> . INT
    (53) math -> . FLOAT
    (54) math -> . TRUE
    (55) math -> . FALSE
    (64) math -> . NAME
    (72) math -> . LPAREN math RPAREN

    NOT             shift and go to state 24
    MINUS           shift and go to state 23
    INT             shift and go to state 25
    FLOAT           shift and go to state 26
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    NAME            shift and go to state 71
    LPAREN          shift and go to state 72

    math                           shift and go to state 90

state 49

    (48) math -> math AND . math
    (37) math -> . math MULTIPLY math
    (38) math -> . math DIVIDE math
    (39) math -> . math MODULO math
    (40) math -> . math PLUS math
    (41) math -> . math MINUS math
    (42) math -> . math LD math
    (43) math -> . math LDEQ math
    (44) math -> . math GD math
    (45) math -> . math GDEQ math
    (46) math -> . math EQUALEQUAL math
    (47) math -> . math NOTEQ math
    (48) math -> . math AND math
    (49) math -> . math OR math
    (50) math -> . NOT math
    (51) math -> . MINUS math
    (52) math -> . INT
    (53) math -> . FLOAT
    (54) math -> . TRUE
    (55) math -> . FALSE
    (64) math -> . NAME
    (72) math -> . LPAREN math RPAREN

    NOT             shift and go to state 24
    MINUS           shift and go to state 23
    INT             shift and go to state 25
    FLOAT           shift and go to state 26
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    NAME            shift and go to state 71
    LPAREN          shift and go to state 72

    math                           shift and go to state 91

state 50

    (49) math -> math OR . math
    (37) math -> . math MULTIPLY math
    (38) math -> . math DIVIDE math
    (39) math -> . math MODULO math
    (40) math -> . math PLUS math
    (41) math -> . math MINUS math
    (42) math -> . math LD math
    (43) math -> . math LDEQ math
    (44) math -> . math GD math
    (45) math -> . math GDEQ math
    (46) math -> . math EQUALEQUAL math
    (47) math -> . math NOTEQ math
    (48) math -> . math AND math
    (49) math -> . math OR math
    (50) math -> . NOT math
    (51) math -> . MINUS math
    (52) math -> . INT
    (53) math -> . FLOAT
    (54) math -> . TRUE
    (55) math -> . FALSE
    (64) math -> . NAME
    (72) math -> . LPAREN math RPAREN

    NOT             shift and go to state 24
    MINUS           shift and go to state 23
    INT             shift and go to state 25
    FLOAT           shift and go to state 26
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    NAME            shift and go to state 71
    LPAREN          shift and go to state 72

    math                           shift and go to state 92

state 51

    (56) str -> str PLUS . str
    (56) str -> . str PLUS str
    (57) str -> . str LD str
    (58) str -> . str LDEQ str
    (59) str -> . str GD str
    (60) str -> . str GDEQ str
    (61) str -> . str EQUALEQUAL str
    (62) str -> . str NOTEQ str
    (63) str -> . STRING
    (65) str -> . NAME
    (73) str -> . LPAREN str RPAREN

    STRING          shift and go to state 29
    NAME            shift and go to state 94
    LPAREN          shift and go to state 95

    str                            shift and go to state 93

state 52

    (57) str -> str LD . str
    (56) str -> . str PLUS str
    (57) str -> . str LD str
    (58) str -> . str LDEQ str
    (59) str -> . str GD str
    (60) str -> . str GDEQ str
    (61) str -> . str EQUALEQUAL str
    (62) str -> . str NOTEQ str
    (63) str -> . STRING
    (65) str -> . NAME
    (73) str -> . LPAREN str RPAREN

    STRING          shift and go to state 29
    NAME            shift and go to state 94
    LPAREN          shift and go to state 95

    str                            shift and go to state 96

state 53

    (58) str -> str LDEQ . str
    (56) str -> . str PLUS str
    (57) str -> . str LD str
    (58) str -> . str LDEQ str
    (59) str -> . str GD str
    (60) str -> . str GDEQ str
    (61) str -> . str EQUALEQUAL str
    (62) str -> . str NOTEQ str
    (63) str -> . STRING
    (65) str -> . NAME
    (73) str -> . LPAREN str RPAREN

    STRING          shift and go to state 29
    NAME            shift and go to state 94
    LPAREN          shift and go to state 95

    str                            shift and go to state 97

state 54

    (59) str -> str GD . str
    (56) str -> . str PLUS str
    (57) str -> . str LD str
    (58) str -> . str LDEQ str
    (59) str -> . str GD str
    (60) str -> . str GDEQ str
    (61) str -> . str EQUALEQUAL str
    (62) str -> . str NOTEQ str
    (63) str -> . STRING
    (65) str -> . NAME
    (73) str -> . LPAREN str RPAREN

    STRING          shift and go to state 29
    NAME            shift and go to state 94
    LPAREN          shift and go to state 95

    str                            shift and go to state 98

state 55

    (60) str -> str GDEQ . str
    (56) str -> . str PLUS str
    (57) str -> . str LD str
    (58) str -> . str LDEQ str
    (59) str -> . str GD str
    (60) str -> . str GDEQ str
    (61) str -> . str EQUALEQUAL str
    (62) str -> . str NOTEQ str
    (63) str -> . STRING
    (65) str -> . NAME
    (73) str -> . LPAREN str RPAREN

    STRING          shift and go to state 29
    NAME            shift and go to state 94
    LPAREN          shift and go to state 95

    str                            shift and go to state 99

state 56

    (61) str -> str EQUALEQUAL . str
    (56) str -> . str PLUS str
    (57) str -> . str LD str
    (58) str -> . str LDEQ str
    (59) str -> . str GD str
    (60) str -> . str GDEQ str
    (61) str -> . str EQUALEQUAL str
    (62) str -> . str NOTEQ str
    (63) str -> . STRING
    (65) str -> . NAME
    (73) str -> . LPAREN str RPAREN

    STRING          shift and go to state 29
    NAME            shift and go to state 94
    LPAREN          shift and go to state 95

    str                            shift and go to state 100

state 57

    (62) str -> str NOTEQ . str
    (56) str -> . str PLUS str
    (57) str -> . str LD str
    (58) str -> . str LDEQ str
    (59) str -> . str GD str
    (60) str -> . str GDEQ str
    (61) str -> . str EQUALEQUAL str
    (62) str -> . str NOTEQ str
    (63) str -> . STRING
    (65) str -> . NAME
    (73) str -> . LPAREN str RPAREN

    STRING          shift and go to state 29
    NAME            shift and go to state 94
    LPAREN          shift and go to state 95

    str                            shift and go to state 101

state 58

    (66) expression -> LBRACE int_type_array . RBRACE

    RBRACE          shift and go to state 102


state 59

    (67) expression -> LBRACE string_type_array . RBRACE

    RBRACE          shift and go to state 103


state 60

    (68) int_type_array -> math .
    (69) int_type_array -> math . COMMA int_type_array
    (37) math -> math . MULTIPLY math
    (38) math -> math . DIVIDE math
    (39) math -> math . MODULO math
    (40) math -> math . PLUS math
    (41) math -> math . MINUS math
    (42) math -> math . LD math
    (43) math -> math . LDEQ math
    (44) math -> math . GD math
    (45) math -> math . GDEQ math
    (46) math -> math . EQUALEQUAL math
    (47) math -> math . NOTEQ math
    (48) math -> math . AND math
    (49) math -> math . OR math

    RBRACE          reduce using rule 68 (int_type_array -> math .)
    COMMA           shift and go to state 104
    MULTIPLY        shift and go to state 38
    DIVIDE          shift and go to state 39
    MODULO          shift and go to state 40
    PLUS            shift and go to state 41
    MINUS           shift and go to state 42
    LD              shift and go to state 43
    LDEQ            shift and go to state 44
    GD              shift and go to state 45
    GDEQ            shift and go to state 46
    EQUALEQUAL      shift and go to state 47
    NOTEQ           shift and go to state 48
    AND             shift and go to state 49
    OR              shift and go to state 50


state 61

    (70) string_type_array -> str .
    (71) string_type_array -> str . COMMA string_type_array
    (56) str -> str . PLUS str
    (57) str -> str . LD str
    (58) str -> str . LDEQ str
    (59) str -> str . GD str
    (60) str -> str . GDEQ str
    (61) str -> str . EQUALEQUAL str
    (62) str -> str . NOTEQ str

    RBRACE          reduce using rule 70 (string_type_array -> str .)
    COMMA           shift and go to state 105
    PLUS            shift and go to state 51
    LD              shift and go to state 52
    LDEQ            shift and go to state 53
    GD              shift and go to state 54
    GDEQ            shift and go to state 55
    EQUALEQUAL      shift and go to state 56
    NOTEQ           shift and go to state 57


state 62

    (64) math -> NAME .
    (65) str -> NAME .

  ! reduce/reduce conflict for COMMA resolved using rule 64 (math -> NAME .)
  ! reduce/reduce conflict for PLUS resolved using rule 64 (math -> NAME .)
  ! reduce/reduce conflict for LD resolved using rule 64 (math -> NAME .)
  ! reduce/reduce conflict for LDEQ resolved using rule 64 (math -> NAME .)
  ! reduce/reduce conflict for GD resolved using rule 64 (math -> NAME .)
  ! reduce/reduce conflict for GDEQ resolved using rule 64 (math -> NAME .)
  ! reduce/reduce conflict for EQUALEQUAL resolved using rule 64 (math -> NAME .)
  ! reduce/reduce conflict for NOTEQ resolved using rule 64 (math -> NAME .)
  ! reduce/reduce conflict for RBRACE resolved using rule 64 (math -> NAME .)
  ! reduce/reduce conflict for RPAREN resolved using rule 64 (math -> NAME .)
    COMMA           reduce using rule 64 (math -> NAME .)
    MULTIPLY        reduce using rule 64 (math -> NAME .)
    DIVIDE          reduce using rule 64 (math -> NAME .)
    MODULO          reduce using rule 64 (math -> NAME .)
    PLUS            reduce using rule 64 (math -> NAME .)
    MINUS           reduce using rule 64 (math -> NAME .)
    LD              reduce using rule 64 (math -> NAME .)
    LDEQ            reduce using rule 64 (math -> NAME .)
    GD              reduce using rule 64 (math -> NAME .)
    GDEQ            reduce using rule 64 (math -> NAME .)
    EQUALEQUAL      reduce using rule 64 (math -> NAME .)
    NOTEQ           reduce using rule 64 (math -> NAME .)
    AND             reduce using rule 64 (math -> NAME .)
    OR              reduce using rule 64 (math -> NAME .)
    RBRACE          reduce using rule 64 (math -> NAME .)
    RPAREN          reduce using rule 64 (math -> NAME .)

  ! COMMA           [ reduce using rule 65 (str -> NAME .) ]
  ! PLUS            [ reduce using rule 65 (str -> NAME .) ]
  ! LD              [ reduce using rule 65 (str -> NAME .) ]
  ! LDEQ            [ reduce using rule 65 (str -> NAME .) ]
  ! GD              [ reduce using rule 65 (str -> NAME .) ]
  ! GDEQ            [ reduce using rule 65 (str -> NAME .) ]
  ! EQUALEQUAL      [ reduce using rule 65 (str -> NAME .) ]
  ! NOTEQ           [ reduce using rule 65 (str -> NAME .) ]
  ! RBRACE          [ reduce using rule 65 (str -> NAME .) ]
  ! RPAREN          [ reduce using rule 65 (str -> NAME .) ]


state 63

    (33) var_assign -> datatype NAME . EQUALS expression
    (17) func_assign -> datatype NAME . LPAREN parameters RPAREN START NEWLINE language return_stmt STOP

    EQUALS          shift and go to state 106
    LPAREN          shift and go to state 107


state 64

    (72) math -> LPAREN math . RPAREN
    (37) math -> math . MULTIPLY math
    (38) math -> math . DIVIDE math
    (39) math -> math . MODULO math
    (40) math -> math . PLUS math
    (41) math -> math . MINUS math
    (42) math -> math . LD math
    (43) math -> math . LDEQ math
    (44) math -> math . GD math
    (45) math -> math . GDEQ math
    (46) math -> math . EQUALEQUAL math
    (47) math -> math . NOTEQ math
    (48) math -> math . AND math
    (49) math -> math . OR math

    RPAREN          shift and go to state 108
    MULTIPLY        shift and go to state 38
    DIVIDE          shift and go to state 39
    MODULO          shift and go to state 40
    PLUS            shift and go to state 41
    MINUS           shift and go to state 42
    LD              shift and go to state 43
    LDEQ            shift and go to state 44
    GD              shift and go to state 45
    GDEQ            shift and go to state 46
    EQUALEQUAL      shift and go to state 47
    NOTEQ           shift and go to state 48
    AND             shift and go to state 49
    OR              shift and go to state 50


state 65

    (73) str -> LPAREN str . RPAREN
    (56) str -> str . PLUS str
    (57) str -> str . LD str
    (58) str -> str . LDEQ str
    (59) str -> str . GD str
    (60) str -> str . GDEQ str
    (61) str -> str . EQUALEQUAL str
    (62) str -> str . NOTEQ str

    RPAREN          shift and go to state 109
    PLUS            shift and go to state 51
    LD              shift and go to state 52
    LDEQ            shift and go to state 53
    GD              shift and go to state 54
    GDEQ            shift and go to state 55
    EQUALEQUAL      shift and go to state 56
    NOTEQ           shift and go to state 57


state 66

    (80) iterative -> WHILE expression . START NEWLINE language STOP

    START           shift and go to state 110


state 67

    (32) expression -> NAME .
    (64) math -> NAME .
    (65) str -> NAME .

  ! reduce/reduce conflict for START resolved using rule 32 (expression -> NAME .)
  ! reduce/reduce conflict for NEWLINE resolved using rule 32 (expression -> NAME .)
  ! reduce/reduce conflict for $end resolved using rule 32 (expression -> NAME .)
  ! reduce/reduce conflict for STOP resolved using rule 32 (expression -> NAME .)
  ! reduce/reduce conflict for RETURN resolved using rule 32 (expression -> NAME .)
  ! reduce/reduce conflict for COMMA resolved using rule 32 (expression -> NAME .)
  ! reduce/reduce conflict for RPAREN resolved using rule 32 (expression -> NAME .)
  ! reduce/reduce conflict for PLUS resolved using rule 64 (math -> NAME .)
  ! reduce/reduce conflict for LD resolved using rule 64 (math -> NAME .)
  ! reduce/reduce conflict for LDEQ resolved using rule 64 (math -> NAME .)
  ! reduce/reduce conflict for GD resolved using rule 64 (math -> NAME .)
  ! reduce/reduce conflict for GDEQ resolved using rule 64 (math -> NAME .)
  ! reduce/reduce conflict for EQUALEQUAL resolved using rule 64 (math -> NAME .)
  ! reduce/reduce conflict for NOTEQ resolved using rule 64 (math -> NAME .)
  ! reduce/reduce conflict for START resolved using rule 32 (expression -> NAME .)
  ! reduce/reduce conflict for NEWLINE resolved using rule 32 (expression -> NAME .)
  ! reduce/reduce conflict for $end resolved using rule 32 (expression -> NAME .)
  ! reduce/reduce conflict for STOP resolved using rule 32 (expression -> NAME .)
  ! reduce/reduce conflict for RETURN resolved using rule 32 (expression -> NAME .)
  ! reduce/reduce conflict for COMMA resolved using rule 32 (expression -> NAME .)
  ! reduce/reduce conflict for RPAREN resolved using rule 32 (expression -> NAME .)
    START           reduce using rule 32 (expression -> NAME .)
    NEWLINE         reduce using rule 32 (expression -> NAME .)
    $end            reduce using rule 32 (expression -> NAME .)
    STOP            reduce using rule 32 (expression -> NAME .)
    RETURN          reduce using rule 32 (expression -> NAME .)
    COMMA           reduce using rule 32 (expression -> NAME .)
    RPAREN          reduce using rule 32 (expression -> NAME .)
    MULTIPLY        reduce using rule 64 (math -> NAME .)
    DIVIDE          reduce using rule 64 (math -> NAME .)
    MODULO          reduce using rule 64 (math -> NAME .)
    PLUS            reduce using rule 64 (math -> NAME .)
    MINUS           reduce using rule 64 (math -> NAME .)
    LD              reduce using rule 64 (math -> NAME .)
    LDEQ            reduce using rule 64 (math -> NAME .)
    GD              reduce using rule 64 (math -> NAME .)
    GDEQ            reduce using rule 64 (math -> NAME .)
    EQUALEQUAL      reduce using rule 64 (math -> NAME .)
    NOTEQ           reduce using rule 64 (math -> NAME .)
    AND             reduce using rule 64 (math -> NAME .)
    OR              reduce using rule 64 (math -> NAME .)

  ! START           [ reduce using rule 64 (math -> NAME .) ]
  ! NEWLINE         [ reduce using rule 64 (math -> NAME .) ]
  ! $end            [ reduce using rule 64 (math -> NAME .) ]
  ! STOP            [ reduce using rule 64 (math -> NAME .) ]
  ! RETURN          [ reduce using rule 64 (math -> NAME .) ]
  ! COMMA           [ reduce using rule 64 (math -> NAME .) ]
  ! RPAREN          [ reduce using rule 64 (math -> NAME .) ]
  ! PLUS            [ reduce using rule 65 (str -> NAME .) ]
  ! LD              [ reduce using rule 65 (str -> NAME .) ]
  ! LDEQ            [ reduce using rule 65 (str -> NAME .) ]
  ! GD              [ reduce using rule 65 (str -> NAME .) ]
  ! GDEQ            [ reduce using rule 65 (str -> NAME .) ]
  ! EQUALEQUAL      [ reduce using rule 65 (str -> NAME .) ]
  ! NOTEQ           [ reduce using rule 65 (str -> NAME .) ]
  ! START           [ reduce using rule 65 (str -> NAME .) ]
  ! NEWLINE         [ reduce using rule 65 (str -> NAME .) ]
  ! $end            [ reduce using rule 65 (str -> NAME .) ]
  ! STOP            [ reduce using rule 65 (str -> NAME .) ]
  ! RETURN          [ reduce using rule 65 (str -> NAME .) ]
  ! COMMA           [ reduce using rule 65 (str -> NAME .) ]
  ! RPAREN          [ reduce using rule 65 (str -> NAME .) ]


state 68

    (74) conditional -> IF expression . START NEWLINE language STOP else_if_blocks else_block

    START           shift and go to state 111


state 69

    (29) input -> READ LPAREN . NAME RPAREN

    NAME            shift and go to state 112


state 70

    (51) math -> MINUS math .
    (37) math -> math . MULTIPLY math
    (38) math -> math . DIVIDE math
    (39) math -> math . MODULO math
    (40) math -> math . PLUS math
    (41) math -> math . MINUS math
    (42) math -> math . LD math
    (43) math -> math . LDEQ math
    (44) math -> math . GD math
    (45) math -> math . GDEQ math
    (46) math -> math . EQUALEQUAL math
    (47) math -> math . NOTEQ math
    (48) math -> math . AND math
    (49) math -> math . OR math

    PLUS            reduce using rule 51 (math -> MINUS math .)
    MINUS           reduce using rule 51 (math -> MINUS math .)
    LD              reduce using rule 51 (math -> MINUS math .)
    LDEQ            reduce using rule 51 (math -> MINUS math .)
    GD              reduce using rule 51 (math -> MINUS math .)
    GDEQ            reduce using rule 51 (math -> MINUS math .)
    EQUALEQUAL      reduce using rule 51 (math -> MINUS math .)
    NOTEQ           reduce using rule 51 (math -> MINUS math .)
    AND             reduce using rule 51 (math -> MINUS math .)
    OR              reduce using rule 51 (math -> MINUS math .)
    NEWLINE         reduce using rule 51 (math -> MINUS math .)
    $end            reduce using rule 51 (math -> MINUS math .)
    COMMA           reduce using rule 51 (math -> MINUS math .)
    RBRACE          reduce using rule 51 (math -> MINUS math .)
    RPAREN          reduce using rule 51 (math -> MINUS math .)
    START           reduce using rule 51 (math -> MINUS math .)
    STOP            reduce using rule 51 (math -> MINUS math .)
    RETURN          reduce using rule 51 (math -> MINUS math .)
    MULTIPLY        shift and go to state 38
    DIVIDE          shift and go to state 39
    MODULO          shift and go to state 40

  ! MULTIPLY        [ reduce using rule 51 (math -> MINUS math .) ]
  ! DIVIDE          [ reduce using rule 51 (math -> MINUS math .) ]
  ! MODULO          [ reduce using rule 51 (math -> MINUS math .) ]
  ! PLUS            [ shift and go to state 41 ]
  ! MINUS           [ shift and go to state 42 ]
  ! LD              [ shift and go to state 43 ]
  ! LDEQ            [ shift and go to state 44 ]
  ! GD              [ shift and go to state 45 ]
  ! GDEQ            [ shift and go to state 46 ]
  ! EQUALEQUAL      [ shift and go to state 47 ]
  ! NOTEQ           [ shift and go to state 48 ]
  ! AND             [ shift and go to state 49 ]
  ! OR              [ shift and go to state 50 ]


state 71

    (64) math -> NAME .

    MULTIPLY        reduce using rule 64 (math -> NAME .)
    DIVIDE          reduce using rule 64 (math -> NAME .)
    MODULO          reduce using rule 64 (math -> NAME .)
    PLUS            reduce using rule 64 (math -> NAME .)
    MINUS           reduce using rule 64 (math -> NAME .)
    LD              reduce using rule 64 (math -> NAME .)
    LDEQ            reduce using rule 64 (math -> NAME .)
    GD              reduce using rule 64 (math -> NAME .)
    GDEQ            reduce using rule 64 (math -> NAME .)
    EQUALEQUAL      reduce using rule 64 (math -> NAME .)
    NOTEQ           reduce using rule 64 (math -> NAME .)
    AND             reduce using rule 64 (math -> NAME .)
    OR              reduce using rule 64 (math -> NAME .)
    NEWLINE         reduce using rule 64 (math -> NAME .)
    $end            reduce using rule 64 (math -> NAME .)
    COMMA           reduce using rule 64 (math -> NAME .)
    RBRACE          reduce using rule 64 (math -> NAME .)
    RPAREN          reduce using rule 64 (math -> NAME .)
    START           reduce using rule 64 (math -> NAME .)
    STOP            reduce using rule 64 (math -> NAME .)
    RETURN          reduce using rule 64 (math -> NAME .)


state 72

    (72) math -> LPAREN . math RPAREN
    (37) math -> . math MULTIPLY math
    (38) math -> . math DIVIDE math
    (39) math -> . math MODULO math
    (40) math -> . math PLUS math
    (41) math -> . math MINUS math
    (42) math -> . math LD math
    (43) math -> . math LDEQ math
    (44) math -> . math GD math
    (45) math -> . math GDEQ math
    (46) math -> . math EQUALEQUAL math
    (47) math -> . math NOTEQ math
    (48) math -> . math AND math
    (49) math -> . math OR math
    (50) math -> . NOT math
    (51) math -> . MINUS math
    (52) math -> . INT
    (53) math -> . FLOAT
    (54) math -> . TRUE
    (55) math -> . FALSE
    (64) math -> . NAME
    (72) math -> . LPAREN math RPAREN

    NOT             shift and go to state 24
    MINUS           shift and go to state 23
    INT             shift and go to state 25
    FLOAT           shift and go to state 26
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    NAME            shift and go to state 71
    LPAREN          shift and go to state 72

    math                           shift and go to state 64

state 73

    (50) math -> NOT math .
    (37) math -> math . MULTIPLY math
    (38) math -> math . DIVIDE math
    (39) math -> math . MODULO math
    (40) math -> math . PLUS math
    (41) math -> math . MINUS math
    (42) math -> math . LD math
    (43) math -> math . LDEQ math
    (44) math -> math . GD math
    (45) math -> math . GDEQ math
    (46) math -> math . EQUALEQUAL math
    (47) math -> math . NOTEQ math
    (48) math -> math . AND math
    (49) math -> math . OR math

    MULTIPLY        reduce using rule 50 (math -> NOT math .)
    DIVIDE          reduce using rule 50 (math -> NOT math .)
    MODULO          reduce using rule 50 (math -> NOT math .)
    PLUS            reduce using rule 50 (math -> NOT math .)
    MINUS           reduce using rule 50 (math -> NOT math .)
    LD              reduce using rule 50 (math -> NOT math .)
    LDEQ            reduce using rule 50 (math -> NOT math .)
    GD              reduce using rule 50 (math -> NOT math .)
    GDEQ            reduce using rule 50 (math -> NOT math .)
    EQUALEQUAL      reduce using rule 50 (math -> NOT math .)
    NOTEQ           reduce using rule 50 (math -> NOT math .)
    AND             reduce using rule 50 (math -> NOT math .)
    OR              reduce using rule 50 (math -> NOT math .)
    NEWLINE         reduce using rule 50 (math -> NOT math .)
    $end            reduce using rule 50 (math -> NOT math .)
    COMMA           reduce using rule 50 (math -> NOT math .)
    RBRACE          reduce using rule 50 (math -> NOT math .)
    RPAREN          reduce using rule 50 (math -> NOT math .)
    START           reduce using rule 50 (math -> NOT math .)
    STOP            reduce using rule 50 (math -> NOT math .)
    RETURN          reduce using rule 50 (math -> NOT math .)

  ! MULTIPLY        [ shift and go to state 38 ]
  ! DIVIDE          [ shift and go to state 39 ]
  ! MODULO          [ shift and go to state 40 ]
  ! PLUS            [ shift and go to state 41 ]
  ! MINUS           [ shift and go to state 42 ]
  ! LD              [ shift and go to state 43 ]
  ! LDEQ            [ shift and go to state 44 ]
  ! GD              [ shift and go to state 45 ]
  ! GDEQ            [ shift and go to state 46 ]
  ! EQUALEQUAL      [ shift and go to state 47 ]
  ! NOTEQ           [ shift and go to state 48 ]
  ! AND             [ shift and go to state 49 ]
  ! OR              [ shift and go to state 50 ]


state 74

    (31) output_print -> PRINT LPAREN . expression RPAREN
    (32) expression -> . NAME
    (35) expression -> . math
    (36) expression -> . str
    (66) expression -> . LBRACE int_type_array RBRACE
    (67) expression -> . LBRACE string_type_array RBRACE
    (37) math -> . math MULTIPLY math
    (38) math -> . math DIVIDE math
    (39) math -> . math MODULO math
    (40) math -> . math PLUS math
    (41) math -> . math MINUS math
    (42) math -> . math LD math
    (43) math -> . math LDEQ math
    (44) math -> . math GD math
    (45) math -> . math GDEQ math
    (46) math -> . math EQUALEQUAL math
    (47) math -> . math NOTEQ math
    (48) math -> . math AND math
    (49) math -> . math OR math
    (50) math -> . NOT math
    (51) math -> . MINUS math
    (52) math -> . INT
    (53) math -> . FLOAT
    (54) math -> . TRUE
    (55) math -> . FALSE
    (64) math -> . NAME
    (72) math -> . LPAREN math RPAREN
    (56) str -> . str PLUS str
    (57) str -> . str LD str
    (58) str -> . str LDEQ str
    (59) str -> . str GD str
    (60) str -> . str GDEQ str
    (61) str -> . str EQUALEQUAL str
    (62) str -> . str NOTEQ str
    (63) str -> . STRING
    (65) str -> . NAME
    (73) str -> . LPAREN str RPAREN

    NAME            shift and go to state 67
    LBRACE          shift and go to state 16
    NOT             shift and go to state 24
    MINUS           shift and go to state 23
    INT             shift and go to state 25
    FLOAT           shift and go to state 26
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    LPAREN          shift and go to state 18
    STRING          shift and go to state 29

    expression                     shift and go to state 113
    math                           shift and go to state 14
    str                            shift and go to state 15

state 75

    (3) language -> language NEWLINE line .

    NEWLINE         reduce using rule 3 (language -> language NEWLINE line .)
    $end            reduce using rule 3 (language -> language NEWLINE line .)
    STOP            reduce using rule 3 (language -> language NEWLINE line .)
    RETURN          reduce using rule 3 (language -> language NEWLINE line .)


state 76

    (13) line -> empty .

    NEWLINE         reduce using rule 13 (line -> empty .)
    $end            reduce using rule 13 (line -> empty .)
    STOP            reduce using rule 13 (line -> empty .)
    RETURN          reduce using rule 13 (line -> empty .)


state 77

    (34) var_assign -> NAME EQUALS expression .

    NEWLINE         reduce using rule 34 (var_assign -> NAME EQUALS expression .)
    $end            reduce using rule 34 (var_assign -> NAME EQUALS expression .)
    STOP            reduce using rule 34 (var_assign -> NAME EQUALS expression .)
    RETURN          reduce using rule 34 (var_assign -> NAME EQUALS expression .)


state 78

    (14) func_call -> NAME LPAREN pars . RPAREN

    RPAREN          shift and go to state 114


state 79

    (15) pars -> expression .
    (16) pars -> expression . COMMA expression

    RPAREN          reduce using rule 15 (pars -> expression .)
    COMMA           shift and go to state 115


state 80

    (37) math -> math MULTIPLY math .
    (37) math -> math . MULTIPLY math
    (38) math -> math . DIVIDE math
    (39) math -> math . MODULO math
    (40) math -> math . PLUS math
    (41) math -> math . MINUS math
    (42) math -> math . LD math
    (43) math -> math . LDEQ math
    (44) math -> math . GD math
    (45) math -> math . GDEQ math
    (46) math -> math . EQUALEQUAL math
    (47) math -> math . NOTEQ math
    (48) math -> math . AND math
    (49) math -> math . OR math

    MULTIPLY        reduce using rule 37 (math -> math MULTIPLY math .)
    DIVIDE          reduce using rule 37 (math -> math MULTIPLY math .)
    MODULO          reduce using rule 37 (math -> math MULTIPLY math .)
    PLUS            reduce using rule 37 (math -> math MULTIPLY math .)
    MINUS           reduce using rule 37 (math -> math MULTIPLY math .)
    LD              reduce using rule 37 (math -> math MULTIPLY math .)
    LDEQ            reduce using rule 37 (math -> math MULTIPLY math .)
    GD              reduce using rule 37 (math -> math MULTIPLY math .)
    GDEQ            reduce using rule 37 (math -> math MULTIPLY math .)
    EQUALEQUAL      reduce using rule 37 (math -> math MULTIPLY math .)
    NOTEQ           reduce using rule 37 (math -> math MULTIPLY math .)
    AND             reduce using rule 37 (math -> math MULTIPLY math .)
    OR              reduce using rule 37 (math -> math MULTIPLY math .)
    NEWLINE         reduce using rule 37 (math -> math MULTIPLY math .)
    $end            reduce using rule 37 (math -> math MULTIPLY math .)
    COMMA           reduce using rule 37 (math -> math MULTIPLY math .)
    RBRACE          reduce using rule 37 (math -> math MULTIPLY math .)
    RPAREN          reduce using rule 37 (math -> math MULTIPLY math .)
    START           reduce using rule 37 (math -> math MULTIPLY math .)
    STOP            reduce using rule 37 (math -> math MULTIPLY math .)
    RETURN          reduce using rule 37 (math -> math MULTIPLY math .)

  ! MULTIPLY        [ shift and go to state 38 ]
  ! DIVIDE          [ shift and go to state 39 ]
  ! MODULO          [ shift and go to state 40 ]
  ! PLUS            [ shift and go to state 41 ]
  ! MINUS           [ shift and go to state 42 ]
  ! LD              [ shift and go to state 43 ]
  ! LDEQ            [ shift and go to state 44 ]
  ! GD              [ shift and go to state 45 ]
  ! GDEQ            [ shift and go to state 46 ]
  ! EQUALEQUAL      [ shift and go to state 47 ]
  ! NOTEQ           [ shift and go to state 48 ]
  ! AND             [ shift and go to state 49 ]
  ! OR              [ shift and go to state 50 ]


state 81

    (38) math -> math DIVIDE math .
    (37) math -> math . MULTIPLY math
    (38) math -> math . DIVIDE math
    (39) math -> math . MODULO math
    (40) math -> math . PLUS math
    (41) math -> math . MINUS math
    (42) math -> math . LD math
    (43) math -> math . LDEQ math
    (44) math -> math . GD math
    (45) math -> math . GDEQ math
    (46) math -> math . EQUALEQUAL math
    (47) math -> math . NOTEQ math
    (48) math -> math . AND math
    (49) math -> math . OR math

    MULTIPLY        reduce using rule 38 (math -> math DIVIDE math .)
    DIVIDE          reduce using rule 38 (math -> math DIVIDE math .)
    MODULO          reduce using rule 38 (math -> math DIVIDE math .)
    PLUS            reduce using rule 38 (math -> math DIVIDE math .)
    MINUS           reduce using rule 38 (math -> math DIVIDE math .)
    LD              reduce using rule 38 (math -> math DIVIDE math .)
    LDEQ            reduce using rule 38 (math -> math DIVIDE math .)
    GD              reduce using rule 38 (math -> math DIVIDE math .)
    GDEQ            reduce using rule 38 (math -> math DIVIDE math .)
    EQUALEQUAL      reduce using rule 38 (math -> math DIVIDE math .)
    NOTEQ           reduce using rule 38 (math -> math DIVIDE math .)
    AND             reduce using rule 38 (math -> math DIVIDE math .)
    OR              reduce using rule 38 (math -> math DIVIDE math .)
    NEWLINE         reduce using rule 38 (math -> math DIVIDE math .)
    $end            reduce using rule 38 (math -> math DIVIDE math .)
    COMMA           reduce using rule 38 (math -> math DIVIDE math .)
    RBRACE          reduce using rule 38 (math -> math DIVIDE math .)
    RPAREN          reduce using rule 38 (math -> math DIVIDE math .)
    START           reduce using rule 38 (math -> math DIVIDE math .)
    STOP            reduce using rule 38 (math -> math DIVIDE math .)
    RETURN          reduce using rule 38 (math -> math DIVIDE math .)

  ! MULTIPLY        [ shift and go to state 38 ]
  ! DIVIDE          [ shift and go to state 39 ]
  ! MODULO          [ shift and go to state 40 ]
  ! PLUS            [ shift and go to state 41 ]
  ! MINUS           [ shift and go to state 42 ]
  ! LD              [ shift and go to state 43 ]
  ! LDEQ            [ shift and go to state 44 ]
  ! GD              [ shift and go to state 45 ]
  ! GDEQ            [ shift and go to state 46 ]
  ! EQUALEQUAL      [ shift and go to state 47 ]
  ! NOTEQ           [ shift and go to state 48 ]
  ! AND             [ shift and go to state 49 ]
  ! OR              [ shift and go to state 50 ]


state 82

    (39) math -> math MODULO math .
    (37) math -> math . MULTIPLY math
    (38) math -> math . DIVIDE math
    (39) math -> math . MODULO math
    (40) math -> math . PLUS math
    (41) math -> math . MINUS math
    (42) math -> math . LD math
    (43) math -> math . LDEQ math
    (44) math -> math . GD math
    (45) math -> math . GDEQ math
    (46) math -> math . EQUALEQUAL math
    (47) math -> math . NOTEQ math
    (48) math -> math . AND math
    (49) math -> math . OR math

    MULTIPLY        reduce using rule 39 (math -> math MODULO math .)
    DIVIDE          reduce using rule 39 (math -> math MODULO math .)
    MODULO          reduce using rule 39 (math -> math MODULO math .)
    PLUS            reduce using rule 39 (math -> math MODULO math .)
    MINUS           reduce using rule 39 (math -> math MODULO math .)
    LD              reduce using rule 39 (math -> math MODULO math .)
    LDEQ            reduce using rule 39 (math -> math MODULO math .)
    GD              reduce using rule 39 (math -> math MODULO math .)
    GDEQ            reduce using rule 39 (math -> math MODULO math .)
    EQUALEQUAL      reduce using rule 39 (math -> math MODULO math .)
    NOTEQ           reduce using rule 39 (math -> math MODULO math .)
    AND             reduce using rule 39 (math -> math MODULO math .)
    OR              reduce using rule 39 (math -> math MODULO math .)
    NEWLINE         reduce using rule 39 (math -> math MODULO math .)
    $end            reduce using rule 39 (math -> math MODULO math .)
    COMMA           reduce using rule 39 (math -> math MODULO math .)
    RBRACE          reduce using rule 39 (math -> math MODULO math .)
    RPAREN          reduce using rule 39 (math -> math MODULO math .)
    START           reduce using rule 39 (math -> math MODULO math .)
    STOP            reduce using rule 39 (math -> math MODULO math .)
    RETURN          reduce using rule 39 (math -> math MODULO math .)

  ! MULTIPLY        [ shift and go to state 38 ]
  ! DIVIDE          [ shift and go to state 39 ]
  ! MODULO          [ shift and go to state 40 ]
  ! PLUS            [ shift and go to state 41 ]
  ! MINUS           [ shift and go to state 42 ]
  ! LD              [ shift and go to state 43 ]
  ! LDEQ            [ shift and go to state 44 ]
  ! GD              [ shift and go to state 45 ]
  ! GDEQ            [ shift and go to state 46 ]
  ! EQUALEQUAL      [ shift and go to state 47 ]
  ! NOTEQ           [ shift and go to state 48 ]
  ! AND             [ shift and go to state 49 ]
  ! OR              [ shift and go to state 50 ]


state 83

    (40) math -> math PLUS math .
    (37) math -> math . MULTIPLY math
    (38) math -> math . DIVIDE math
    (39) math -> math . MODULO math
    (40) math -> math . PLUS math
    (41) math -> math . MINUS math
    (42) math -> math . LD math
    (43) math -> math . LDEQ math
    (44) math -> math . GD math
    (45) math -> math . GDEQ math
    (46) math -> math . EQUALEQUAL math
    (47) math -> math . NOTEQ math
    (48) math -> math . AND math
    (49) math -> math . OR math

    PLUS            reduce using rule 40 (math -> math PLUS math .)
    MINUS           reduce using rule 40 (math -> math PLUS math .)
    LD              reduce using rule 40 (math -> math PLUS math .)
    LDEQ            reduce using rule 40 (math -> math PLUS math .)
    GD              reduce using rule 40 (math -> math PLUS math .)
    GDEQ            reduce using rule 40 (math -> math PLUS math .)
    EQUALEQUAL      reduce using rule 40 (math -> math PLUS math .)
    NOTEQ           reduce using rule 40 (math -> math PLUS math .)
    AND             reduce using rule 40 (math -> math PLUS math .)
    OR              reduce using rule 40 (math -> math PLUS math .)
    NEWLINE         reduce using rule 40 (math -> math PLUS math .)
    $end            reduce using rule 40 (math -> math PLUS math .)
    COMMA           reduce using rule 40 (math -> math PLUS math .)
    RBRACE          reduce using rule 40 (math -> math PLUS math .)
    RPAREN          reduce using rule 40 (math -> math PLUS math .)
    START           reduce using rule 40 (math -> math PLUS math .)
    STOP            reduce using rule 40 (math -> math PLUS math .)
    RETURN          reduce using rule 40 (math -> math PLUS math .)
    MULTIPLY        shift and go to state 38
    DIVIDE          shift and go to state 39
    MODULO          shift and go to state 40

  ! MULTIPLY        [ reduce using rule 40 (math -> math PLUS math .) ]
  ! DIVIDE          [ reduce using rule 40 (math -> math PLUS math .) ]
  ! MODULO          [ reduce using rule 40 (math -> math PLUS math .) ]
  ! PLUS            [ shift and go to state 41 ]
  ! MINUS           [ shift and go to state 42 ]
  ! LD              [ shift and go to state 43 ]
  ! LDEQ            [ shift and go to state 44 ]
  ! GD              [ shift and go to state 45 ]
  ! GDEQ            [ shift and go to state 46 ]
  ! EQUALEQUAL      [ shift and go to state 47 ]
  ! NOTEQ           [ shift and go to state 48 ]
  ! AND             [ shift and go to state 49 ]
  ! OR              [ shift and go to state 50 ]


state 84

    (41) math -> math MINUS math .
    (37) math -> math . MULTIPLY math
    (38) math -> math . DIVIDE math
    (39) math -> math . MODULO math
    (40) math -> math . PLUS math
    (41) math -> math . MINUS math
    (42) math -> math . LD math
    (43) math -> math . LDEQ math
    (44) math -> math . GD math
    (45) math -> math . GDEQ math
    (46) math -> math . EQUALEQUAL math
    (47) math -> math . NOTEQ math
    (48) math -> math . AND math
    (49) math -> math . OR math

    PLUS            reduce using rule 41 (math -> math MINUS math .)
    MINUS           reduce using rule 41 (math -> math MINUS math .)
    LD              reduce using rule 41 (math -> math MINUS math .)
    LDEQ            reduce using rule 41 (math -> math MINUS math .)
    GD              reduce using rule 41 (math -> math MINUS math .)
    GDEQ            reduce using rule 41 (math -> math MINUS math .)
    EQUALEQUAL      reduce using rule 41 (math -> math MINUS math .)
    NOTEQ           reduce using rule 41 (math -> math MINUS math .)
    AND             reduce using rule 41 (math -> math MINUS math .)
    OR              reduce using rule 41 (math -> math MINUS math .)
    NEWLINE         reduce using rule 41 (math -> math MINUS math .)
    $end            reduce using rule 41 (math -> math MINUS math .)
    COMMA           reduce using rule 41 (math -> math MINUS math .)
    RBRACE          reduce using rule 41 (math -> math MINUS math .)
    RPAREN          reduce using rule 41 (math -> math MINUS math .)
    START           reduce using rule 41 (math -> math MINUS math .)
    STOP            reduce using rule 41 (math -> math MINUS math .)
    RETURN          reduce using rule 41 (math -> math MINUS math .)
    MULTIPLY        shift and go to state 38
    DIVIDE          shift and go to state 39
    MODULO          shift and go to state 40

  ! MULTIPLY        [ reduce using rule 41 (math -> math MINUS math .) ]
  ! DIVIDE          [ reduce using rule 41 (math -> math MINUS math .) ]
  ! MODULO          [ reduce using rule 41 (math -> math MINUS math .) ]
  ! PLUS            [ shift and go to state 41 ]
  ! MINUS           [ shift and go to state 42 ]
  ! LD              [ shift and go to state 43 ]
  ! LDEQ            [ shift and go to state 44 ]
  ! GD              [ shift and go to state 45 ]
  ! GDEQ            [ shift and go to state 46 ]
  ! EQUALEQUAL      [ shift and go to state 47 ]
  ! NOTEQ           [ shift and go to state 48 ]
  ! AND             [ shift and go to state 49 ]
  ! OR              [ shift and go to state 50 ]


state 85

    (42) math -> math LD math .
    (37) math -> math . MULTIPLY math
    (38) math -> math . DIVIDE math
    (39) math -> math . MODULO math
    (40) math -> math . PLUS math
    (41) math -> math . MINUS math
    (42) math -> math . LD math
    (43) math -> math . LDEQ math
    (44) math -> math . GD math
    (45) math -> math . GDEQ math
    (46) math -> math . EQUALEQUAL math
    (47) math -> math . NOTEQ math
    (48) math -> math . AND math
    (49) math -> math . OR math

    LD              reduce using rule 42 (math -> math LD math .)
    LDEQ            reduce using rule 42 (math -> math LD math .)
    GD              reduce using rule 42 (math -> math LD math .)
    GDEQ            reduce using rule 42 (math -> math LD math .)
    EQUALEQUAL      reduce using rule 42 (math -> math LD math .)
    NOTEQ           reduce using rule 42 (math -> math LD math .)
    AND             reduce using rule 42 (math -> math LD math .)
    OR              reduce using rule 42 (math -> math LD math .)
    NEWLINE         reduce using rule 42 (math -> math LD math .)
    $end            reduce using rule 42 (math -> math LD math .)
    COMMA           reduce using rule 42 (math -> math LD math .)
    RBRACE          reduce using rule 42 (math -> math LD math .)
    RPAREN          reduce using rule 42 (math -> math LD math .)
    START           reduce using rule 42 (math -> math LD math .)
    STOP            reduce using rule 42 (math -> math LD math .)
    RETURN          reduce using rule 42 (math -> math LD math .)
    MULTIPLY        shift and go to state 38
    DIVIDE          shift and go to state 39
    MODULO          shift and go to state 40
    PLUS            shift and go to state 41
    MINUS           shift and go to state 42

  ! MULTIPLY        [ reduce using rule 42 (math -> math LD math .) ]
  ! DIVIDE          [ reduce using rule 42 (math -> math LD math .) ]
  ! MODULO          [ reduce using rule 42 (math -> math LD math .) ]
  ! PLUS            [ reduce using rule 42 (math -> math LD math .) ]
  ! MINUS           [ reduce using rule 42 (math -> math LD math .) ]
  ! LD              [ shift and go to state 43 ]
  ! LDEQ            [ shift and go to state 44 ]
  ! GD              [ shift and go to state 45 ]
  ! GDEQ            [ shift and go to state 46 ]
  ! EQUALEQUAL      [ shift and go to state 47 ]
  ! NOTEQ           [ shift and go to state 48 ]
  ! AND             [ shift and go to state 49 ]
  ! OR              [ shift and go to state 50 ]


state 86

    (43) math -> math LDEQ math .
    (37) math -> math . MULTIPLY math
    (38) math -> math . DIVIDE math
    (39) math -> math . MODULO math
    (40) math -> math . PLUS math
    (41) math -> math . MINUS math
    (42) math -> math . LD math
    (43) math -> math . LDEQ math
    (44) math -> math . GD math
    (45) math -> math . GDEQ math
    (46) math -> math . EQUALEQUAL math
    (47) math -> math . NOTEQ math
    (48) math -> math . AND math
    (49) math -> math . OR math

    LD              reduce using rule 43 (math -> math LDEQ math .)
    LDEQ            reduce using rule 43 (math -> math LDEQ math .)
    GD              reduce using rule 43 (math -> math LDEQ math .)
    GDEQ            reduce using rule 43 (math -> math LDEQ math .)
    EQUALEQUAL      reduce using rule 43 (math -> math LDEQ math .)
    NOTEQ           reduce using rule 43 (math -> math LDEQ math .)
    AND             reduce using rule 43 (math -> math LDEQ math .)
    OR              reduce using rule 43 (math -> math LDEQ math .)
    NEWLINE         reduce using rule 43 (math -> math LDEQ math .)
    $end            reduce using rule 43 (math -> math LDEQ math .)
    COMMA           reduce using rule 43 (math -> math LDEQ math .)
    RBRACE          reduce using rule 43 (math -> math LDEQ math .)
    RPAREN          reduce using rule 43 (math -> math LDEQ math .)
    START           reduce using rule 43 (math -> math LDEQ math .)
    STOP            reduce using rule 43 (math -> math LDEQ math .)
    RETURN          reduce using rule 43 (math -> math LDEQ math .)
    MULTIPLY        shift and go to state 38
    DIVIDE          shift and go to state 39
    MODULO          shift and go to state 40
    PLUS            shift and go to state 41
    MINUS           shift and go to state 42

  ! MULTIPLY        [ reduce using rule 43 (math -> math LDEQ math .) ]
  ! DIVIDE          [ reduce using rule 43 (math -> math LDEQ math .) ]
  ! MODULO          [ reduce using rule 43 (math -> math LDEQ math .) ]
  ! PLUS            [ reduce using rule 43 (math -> math LDEQ math .) ]
  ! MINUS           [ reduce using rule 43 (math -> math LDEQ math .) ]
  ! LD              [ shift and go to state 43 ]
  ! LDEQ            [ shift and go to state 44 ]
  ! GD              [ shift and go to state 45 ]
  ! GDEQ            [ shift and go to state 46 ]
  ! EQUALEQUAL      [ shift and go to state 47 ]
  ! NOTEQ           [ shift and go to state 48 ]
  ! AND             [ shift and go to state 49 ]
  ! OR              [ shift and go to state 50 ]


state 87

    (44) math -> math GD math .
    (37) math -> math . MULTIPLY math
    (38) math -> math . DIVIDE math
    (39) math -> math . MODULO math
    (40) math -> math . PLUS math
    (41) math -> math . MINUS math
    (42) math -> math . LD math
    (43) math -> math . LDEQ math
    (44) math -> math . GD math
    (45) math -> math . GDEQ math
    (46) math -> math . EQUALEQUAL math
    (47) math -> math . NOTEQ math
    (48) math -> math . AND math
    (49) math -> math . OR math

    LD              reduce using rule 44 (math -> math GD math .)
    LDEQ            reduce using rule 44 (math -> math GD math .)
    GD              reduce using rule 44 (math -> math GD math .)
    GDEQ            reduce using rule 44 (math -> math GD math .)
    EQUALEQUAL      reduce using rule 44 (math -> math GD math .)
    NOTEQ           reduce using rule 44 (math -> math GD math .)
    AND             reduce using rule 44 (math -> math GD math .)
    OR              reduce using rule 44 (math -> math GD math .)
    NEWLINE         reduce using rule 44 (math -> math GD math .)
    $end            reduce using rule 44 (math -> math GD math .)
    COMMA           reduce using rule 44 (math -> math GD math .)
    RBRACE          reduce using rule 44 (math -> math GD math .)
    RPAREN          reduce using rule 44 (math -> math GD math .)
    START           reduce using rule 44 (math -> math GD math .)
    STOP            reduce using rule 44 (math -> math GD math .)
    RETURN          reduce using rule 44 (math -> math GD math .)
    MULTIPLY        shift and go to state 38
    DIVIDE          shift and go to state 39
    MODULO          shift and go to state 40
    PLUS            shift and go to state 41
    MINUS           shift and go to state 42

  ! MULTIPLY        [ reduce using rule 44 (math -> math GD math .) ]
  ! DIVIDE          [ reduce using rule 44 (math -> math GD math .) ]
  ! MODULO          [ reduce using rule 44 (math -> math GD math .) ]
  ! PLUS            [ reduce using rule 44 (math -> math GD math .) ]
  ! MINUS           [ reduce using rule 44 (math -> math GD math .) ]
  ! LD              [ shift and go to state 43 ]
  ! LDEQ            [ shift and go to state 44 ]
  ! GD              [ shift and go to state 45 ]
  ! GDEQ            [ shift and go to state 46 ]
  ! EQUALEQUAL      [ shift and go to state 47 ]
  ! NOTEQ           [ shift and go to state 48 ]
  ! AND             [ shift and go to state 49 ]
  ! OR              [ shift and go to state 50 ]


state 88

    (45) math -> math GDEQ math .
    (37) math -> math . MULTIPLY math
    (38) math -> math . DIVIDE math
    (39) math -> math . MODULO math
    (40) math -> math . PLUS math
    (41) math -> math . MINUS math
    (42) math -> math . LD math
    (43) math -> math . LDEQ math
    (44) math -> math . GD math
    (45) math -> math . GDEQ math
    (46) math -> math . EQUALEQUAL math
    (47) math -> math . NOTEQ math
    (48) math -> math . AND math
    (49) math -> math . OR math

    LD              reduce using rule 45 (math -> math GDEQ math .)
    LDEQ            reduce using rule 45 (math -> math GDEQ math .)
    GD              reduce using rule 45 (math -> math GDEQ math .)
    GDEQ            reduce using rule 45 (math -> math GDEQ math .)
    EQUALEQUAL      reduce using rule 45 (math -> math GDEQ math .)
    NOTEQ           reduce using rule 45 (math -> math GDEQ math .)
    AND             reduce using rule 45 (math -> math GDEQ math .)
    OR              reduce using rule 45 (math -> math GDEQ math .)
    NEWLINE         reduce using rule 45 (math -> math GDEQ math .)
    $end            reduce using rule 45 (math -> math GDEQ math .)
    COMMA           reduce using rule 45 (math -> math GDEQ math .)
    RBRACE          reduce using rule 45 (math -> math GDEQ math .)
    RPAREN          reduce using rule 45 (math -> math GDEQ math .)
    START           reduce using rule 45 (math -> math GDEQ math .)
    STOP            reduce using rule 45 (math -> math GDEQ math .)
    RETURN          reduce using rule 45 (math -> math GDEQ math .)
    MULTIPLY        shift and go to state 38
    DIVIDE          shift and go to state 39
    MODULO          shift and go to state 40
    PLUS            shift and go to state 41
    MINUS           shift and go to state 42

  ! MULTIPLY        [ reduce using rule 45 (math -> math GDEQ math .) ]
  ! DIVIDE          [ reduce using rule 45 (math -> math GDEQ math .) ]
  ! MODULO          [ reduce using rule 45 (math -> math GDEQ math .) ]
  ! PLUS            [ reduce using rule 45 (math -> math GDEQ math .) ]
  ! MINUS           [ reduce using rule 45 (math -> math GDEQ math .) ]
  ! LD              [ shift and go to state 43 ]
  ! LDEQ            [ shift and go to state 44 ]
  ! GD              [ shift and go to state 45 ]
  ! GDEQ            [ shift and go to state 46 ]
  ! EQUALEQUAL      [ shift and go to state 47 ]
  ! NOTEQ           [ shift and go to state 48 ]
  ! AND             [ shift and go to state 49 ]
  ! OR              [ shift and go to state 50 ]


state 89

    (46) math -> math EQUALEQUAL math .
    (37) math -> math . MULTIPLY math
    (38) math -> math . DIVIDE math
    (39) math -> math . MODULO math
    (40) math -> math . PLUS math
    (41) math -> math . MINUS math
    (42) math -> math . LD math
    (43) math -> math . LDEQ math
    (44) math -> math . GD math
    (45) math -> math . GDEQ math
    (46) math -> math . EQUALEQUAL math
    (47) math -> math . NOTEQ math
    (48) math -> math . AND math
    (49) math -> math . OR math

    EQUALEQUAL      reduce using rule 46 (math -> math EQUALEQUAL math .)
    NOTEQ           reduce using rule 46 (math -> math EQUALEQUAL math .)
    AND             reduce using rule 46 (math -> math EQUALEQUAL math .)
    OR              reduce using rule 46 (math -> math EQUALEQUAL math .)
    NEWLINE         reduce using rule 46 (math -> math EQUALEQUAL math .)
    $end            reduce using rule 46 (math -> math EQUALEQUAL math .)
    COMMA           reduce using rule 46 (math -> math EQUALEQUAL math .)
    RBRACE          reduce using rule 46 (math -> math EQUALEQUAL math .)
    RPAREN          reduce using rule 46 (math -> math EQUALEQUAL math .)
    START           reduce using rule 46 (math -> math EQUALEQUAL math .)
    STOP            reduce using rule 46 (math -> math EQUALEQUAL math .)
    RETURN          reduce using rule 46 (math -> math EQUALEQUAL math .)
    MULTIPLY        shift and go to state 38
    DIVIDE          shift and go to state 39
    MODULO          shift and go to state 40
    PLUS            shift and go to state 41
    MINUS           shift and go to state 42
    LD              shift and go to state 43
    LDEQ            shift and go to state 44
    GD              shift and go to state 45
    GDEQ            shift and go to state 46

  ! MULTIPLY        [ reduce using rule 46 (math -> math EQUALEQUAL math .) ]
  ! DIVIDE          [ reduce using rule 46 (math -> math EQUALEQUAL math .) ]
  ! MODULO          [ reduce using rule 46 (math -> math EQUALEQUAL math .) ]
  ! PLUS            [ reduce using rule 46 (math -> math EQUALEQUAL math .) ]
  ! MINUS           [ reduce using rule 46 (math -> math EQUALEQUAL math .) ]
  ! LD              [ reduce using rule 46 (math -> math EQUALEQUAL math .) ]
  ! LDEQ            [ reduce using rule 46 (math -> math EQUALEQUAL math .) ]
  ! GD              [ reduce using rule 46 (math -> math EQUALEQUAL math .) ]
  ! GDEQ            [ reduce using rule 46 (math -> math EQUALEQUAL math .) ]
  ! EQUALEQUAL      [ shift and go to state 47 ]
  ! NOTEQ           [ shift and go to state 48 ]
  ! AND             [ shift and go to state 49 ]
  ! OR              [ shift and go to state 50 ]


state 90

    (47) math -> math NOTEQ math .
    (37) math -> math . MULTIPLY math
    (38) math -> math . DIVIDE math
    (39) math -> math . MODULO math
    (40) math -> math . PLUS math
    (41) math -> math . MINUS math
    (42) math -> math . LD math
    (43) math -> math . LDEQ math
    (44) math -> math . GD math
    (45) math -> math . GDEQ math
    (46) math -> math . EQUALEQUAL math
    (47) math -> math . NOTEQ math
    (48) math -> math . AND math
    (49) math -> math . OR math

    EQUALEQUAL      reduce using rule 47 (math -> math NOTEQ math .)
    NOTEQ           reduce using rule 47 (math -> math NOTEQ math .)
    AND             reduce using rule 47 (math -> math NOTEQ math .)
    OR              reduce using rule 47 (math -> math NOTEQ math .)
    NEWLINE         reduce using rule 47 (math -> math NOTEQ math .)
    $end            reduce using rule 47 (math -> math NOTEQ math .)
    COMMA           reduce using rule 47 (math -> math NOTEQ math .)
    RBRACE          reduce using rule 47 (math -> math NOTEQ math .)
    RPAREN          reduce using rule 47 (math -> math NOTEQ math .)
    START           reduce using rule 47 (math -> math NOTEQ math .)
    STOP            reduce using rule 47 (math -> math NOTEQ math .)
    RETURN          reduce using rule 47 (math -> math NOTEQ math .)
    MULTIPLY        shift and go to state 38
    DIVIDE          shift and go to state 39
    MODULO          shift and go to state 40
    PLUS            shift and go to state 41
    MINUS           shift and go to state 42
    LD              shift and go to state 43
    LDEQ            shift and go to state 44
    GD              shift and go to state 45
    GDEQ            shift and go to state 46

  ! MULTIPLY        [ reduce using rule 47 (math -> math NOTEQ math .) ]
  ! DIVIDE          [ reduce using rule 47 (math -> math NOTEQ math .) ]
  ! MODULO          [ reduce using rule 47 (math -> math NOTEQ math .) ]
  ! PLUS            [ reduce using rule 47 (math -> math NOTEQ math .) ]
  ! MINUS           [ reduce using rule 47 (math -> math NOTEQ math .) ]
  ! LD              [ reduce using rule 47 (math -> math NOTEQ math .) ]
  ! LDEQ            [ reduce using rule 47 (math -> math NOTEQ math .) ]
  ! GD              [ reduce using rule 47 (math -> math NOTEQ math .) ]
  ! GDEQ            [ reduce using rule 47 (math -> math NOTEQ math .) ]
  ! EQUALEQUAL      [ shift and go to state 47 ]
  ! NOTEQ           [ shift and go to state 48 ]
  ! AND             [ shift and go to state 49 ]
  ! OR              [ shift and go to state 50 ]


state 91

    (48) math -> math AND math .
    (37) math -> math . MULTIPLY math
    (38) math -> math . DIVIDE math
    (39) math -> math . MODULO math
    (40) math -> math . PLUS math
    (41) math -> math . MINUS math
    (42) math -> math . LD math
    (43) math -> math . LDEQ math
    (44) math -> math . GD math
    (45) math -> math . GDEQ math
    (46) math -> math . EQUALEQUAL math
    (47) math -> math . NOTEQ math
    (48) math -> math . AND math
    (49) math -> math . OR math

    AND             reduce using rule 48 (math -> math AND math .)
    OR              reduce using rule 48 (math -> math AND math .)
    NEWLINE         reduce using rule 48 (math -> math AND math .)
    $end            reduce using rule 48 (math -> math AND math .)
    COMMA           reduce using rule 48 (math -> math AND math .)
    RBRACE          reduce using rule 48 (math -> math AND math .)
    RPAREN          reduce using rule 48 (math -> math AND math .)
    START           reduce using rule 48 (math -> math AND math .)
    STOP            reduce using rule 48 (math -> math AND math .)
    RETURN          reduce using rule 48 (math -> math AND math .)
    MULTIPLY        shift and go to state 38
    DIVIDE          shift and go to state 39
    MODULO          shift and go to state 40
    PLUS            shift and go to state 41
    MINUS           shift and go to state 42
    LD              shift and go to state 43
    LDEQ            shift and go to state 44
    GD              shift and go to state 45
    GDEQ            shift and go to state 46
    EQUALEQUAL      shift and go to state 47
    NOTEQ           shift and go to state 48

  ! MULTIPLY        [ reduce using rule 48 (math -> math AND math .) ]
  ! DIVIDE          [ reduce using rule 48 (math -> math AND math .) ]
  ! MODULO          [ reduce using rule 48 (math -> math AND math .) ]
  ! PLUS            [ reduce using rule 48 (math -> math AND math .) ]
  ! MINUS           [ reduce using rule 48 (math -> math AND math .) ]
  ! LD              [ reduce using rule 48 (math -> math AND math .) ]
  ! LDEQ            [ reduce using rule 48 (math -> math AND math .) ]
  ! GD              [ reduce using rule 48 (math -> math AND math .) ]
  ! GDEQ            [ reduce using rule 48 (math -> math AND math .) ]
  ! EQUALEQUAL      [ reduce using rule 48 (math -> math AND math .) ]
  ! NOTEQ           [ reduce using rule 48 (math -> math AND math .) ]
  ! AND             [ shift and go to state 49 ]
  ! OR              [ shift and go to state 50 ]


state 92

    (49) math -> math OR math .
    (37) math -> math . MULTIPLY math
    (38) math -> math . DIVIDE math
    (39) math -> math . MODULO math
    (40) math -> math . PLUS math
    (41) math -> math . MINUS math
    (42) math -> math . LD math
    (43) math -> math . LDEQ math
    (44) math -> math . GD math
    (45) math -> math . GDEQ math
    (46) math -> math . EQUALEQUAL math
    (47) math -> math . NOTEQ math
    (48) math -> math . AND math
    (49) math -> math . OR math

    AND             reduce using rule 49 (math -> math OR math .)
    OR              reduce using rule 49 (math -> math OR math .)
    NEWLINE         reduce using rule 49 (math -> math OR math .)
    $end            reduce using rule 49 (math -> math OR math .)
    COMMA           reduce using rule 49 (math -> math OR math .)
    RBRACE          reduce using rule 49 (math -> math OR math .)
    RPAREN          reduce using rule 49 (math -> math OR math .)
    START           reduce using rule 49 (math -> math OR math .)
    STOP            reduce using rule 49 (math -> math OR math .)
    RETURN          reduce using rule 49 (math -> math OR math .)
    MULTIPLY        shift and go to state 38
    DIVIDE          shift and go to state 39
    MODULO          shift and go to state 40
    PLUS            shift and go to state 41
    MINUS           shift and go to state 42
    LD              shift and go to state 43
    LDEQ            shift and go to state 44
    GD              shift and go to state 45
    GDEQ            shift and go to state 46
    EQUALEQUAL      shift and go to state 47
    NOTEQ           shift and go to state 48

  ! MULTIPLY        [ reduce using rule 49 (math -> math OR math .) ]
  ! DIVIDE          [ reduce using rule 49 (math -> math OR math .) ]
  ! MODULO          [ reduce using rule 49 (math -> math OR math .) ]
  ! PLUS            [ reduce using rule 49 (math -> math OR math .) ]
  ! MINUS           [ reduce using rule 49 (math -> math OR math .) ]
  ! LD              [ reduce using rule 49 (math -> math OR math .) ]
  ! LDEQ            [ reduce using rule 49 (math -> math OR math .) ]
  ! GD              [ reduce using rule 49 (math -> math OR math .) ]
  ! GDEQ            [ reduce using rule 49 (math -> math OR math .) ]
  ! EQUALEQUAL      [ reduce using rule 49 (math -> math OR math .) ]
  ! NOTEQ           [ reduce using rule 49 (math -> math OR math .) ]
  ! AND             [ shift and go to state 49 ]
  ! OR              [ shift and go to state 50 ]


state 93

    (56) str -> str PLUS str .
    (56) str -> str . PLUS str
    (57) str -> str . LD str
    (58) str -> str . LDEQ str
    (59) str -> str . GD str
    (60) str -> str . GDEQ str
    (61) str -> str . EQUALEQUAL str
    (62) str -> str . NOTEQ str

    PLUS            reduce using rule 56 (str -> str PLUS str .)
    LD              reduce using rule 56 (str -> str PLUS str .)
    LDEQ            reduce using rule 56 (str -> str PLUS str .)
    GD              reduce using rule 56 (str -> str PLUS str .)
    GDEQ            reduce using rule 56 (str -> str PLUS str .)
    EQUALEQUAL      reduce using rule 56 (str -> str PLUS str .)
    NOTEQ           reduce using rule 56 (str -> str PLUS str .)
    NEWLINE         reduce using rule 56 (str -> str PLUS str .)
    $end            reduce using rule 56 (str -> str PLUS str .)
    COMMA           reduce using rule 56 (str -> str PLUS str .)
    RBRACE          reduce using rule 56 (str -> str PLUS str .)
    RPAREN          reduce using rule 56 (str -> str PLUS str .)
    START           reduce using rule 56 (str -> str PLUS str .)
    STOP            reduce using rule 56 (str -> str PLUS str .)
    RETURN          reduce using rule 56 (str -> str PLUS str .)

  ! PLUS            [ shift and go to state 51 ]
  ! LD              [ shift and go to state 52 ]
  ! LDEQ            [ shift and go to state 53 ]
  ! GD              [ shift and go to state 54 ]
  ! GDEQ            [ shift and go to state 55 ]
  ! EQUALEQUAL      [ shift and go to state 56 ]
  ! NOTEQ           [ shift and go to state 57 ]


state 94

    (65) str -> NAME .

    PLUS            reduce using rule 65 (str -> NAME .)
    LD              reduce using rule 65 (str -> NAME .)
    LDEQ            reduce using rule 65 (str -> NAME .)
    GD              reduce using rule 65 (str -> NAME .)
    GDEQ            reduce using rule 65 (str -> NAME .)
    EQUALEQUAL      reduce using rule 65 (str -> NAME .)
    NOTEQ           reduce using rule 65 (str -> NAME .)
    NEWLINE         reduce using rule 65 (str -> NAME .)
    $end            reduce using rule 65 (str -> NAME .)
    COMMA           reduce using rule 65 (str -> NAME .)
    RBRACE          reduce using rule 65 (str -> NAME .)
    RPAREN          reduce using rule 65 (str -> NAME .)
    START           reduce using rule 65 (str -> NAME .)
    STOP            reduce using rule 65 (str -> NAME .)
    RETURN          reduce using rule 65 (str -> NAME .)


state 95

    (73) str -> LPAREN . str RPAREN
    (56) str -> . str PLUS str
    (57) str -> . str LD str
    (58) str -> . str LDEQ str
    (59) str -> . str GD str
    (60) str -> . str GDEQ str
    (61) str -> . str EQUALEQUAL str
    (62) str -> . str NOTEQ str
    (63) str -> . STRING
    (65) str -> . NAME
    (73) str -> . LPAREN str RPAREN

    STRING          shift and go to state 29
    NAME            shift and go to state 94
    LPAREN          shift and go to state 95

    str                            shift and go to state 65

state 96

    (57) str -> str LD str .
    (56) str -> str . PLUS str
    (57) str -> str . LD str
    (58) str -> str . LDEQ str
    (59) str -> str . GD str
    (60) str -> str . GDEQ str
    (61) str -> str . EQUALEQUAL str
    (62) str -> str . NOTEQ str

    LD              reduce using rule 57 (str -> str LD str .)
    LDEQ            reduce using rule 57 (str -> str LD str .)
    GD              reduce using rule 57 (str -> str LD str .)
    GDEQ            reduce using rule 57 (str -> str LD str .)
    EQUALEQUAL      reduce using rule 57 (str -> str LD str .)
    NOTEQ           reduce using rule 57 (str -> str LD str .)
    NEWLINE         reduce using rule 57 (str -> str LD str .)
    $end            reduce using rule 57 (str -> str LD str .)
    COMMA           reduce using rule 57 (str -> str LD str .)
    RBRACE          reduce using rule 57 (str -> str LD str .)
    RPAREN          reduce using rule 57 (str -> str LD str .)
    START           reduce using rule 57 (str -> str LD str .)
    STOP            reduce using rule 57 (str -> str LD str .)
    RETURN          reduce using rule 57 (str -> str LD str .)
    PLUS            shift and go to state 51

  ! PLUS            [ reduce using rule 57 (str -> str LD str .) ]
  ! LD              [ shift and go to state 52 ]
  ! LDEQ            [ shift and go to state 53 ]
  ! GD              [ shift and go to state 54 ]
  ! GDEQ            [ shift and go to state 55 ]
  ! EQUALEQUAL      [ shift and go to state 56 ]
  ! NOTEQ           [ shift and go to state 57 ]


state 97

    (58) str -> str LDEQ str .
    (56) str -> str . PLUS str
    (57) str -> str . LD str
    (58) str -> str . LDEQ str
    (59) str -> str . GD str
    (60) str -> str . GDEQ str
    (61) str -> str . EQUALEQUAL str
    (62) str -> str . NOTEQ str

    LD              reduce using rule 58 (str -> str LDEQ str .)
    LDEQ            reduce using rule 58 (str -> str LDEQ str .)
    GD              reduce using rule 58 (str -> str LDEQ str .)
    GDEQ            reduce using rule 58 (str -> str LDEQ str .)
    EQUALEQUAL      reduce using rule 58 (str -> str LDEQ str .)
    NOTEQ           reduce using rule 58 (str -> str LDEQ str .)
    NEWLINE         reduce using rule 58 (str -> str LDEQ str .)
    $end            reduce using rule 58 (str -> str LDEQ str .)
    COMMA           reduce using rule 58 (str -> str LDEQ str .)
    RBRACE          reduce using rule 58 (str -> str LDEQ str .)
    RPAREN          reduce using rule 58 (str -> str LDEQ str .)
    START           reduce using rule 58 (str -> str LDEQ str .)
    STOP            reduce using rule 58 (str -> str LDEQ str .)
    RETURN          reduce using rule 58 (str -> str LDEQ str .)
    PLUS            shift and go to state 51

  ! PLUS            [ reduce using rule 58 (str -> str LDEQ str .) ]
  ! LD              [ shift and go to state 52 ]
  ! LDEQ            [ shift and go to state 53 ]
  ! GD              [ shift and go to state 54 ]
  ! GDEQ            [ shift and go to state 55 ]
  ! EQUALEQUAL      [ shift and go to state 56 ]
  ! NOTEQ           [ shift and go to state 57 ]


state 98

    (59) str -> str GD str .
    (56) str -> str . PLUS str
    (57) str -> str . LD str
    (58) str -> str . LDEQ str
    (59) str -> str . GD str
    (60) str -> str . GDEQ str
    (61) str -> str . EQUALEQUAL str
    (62) str -> str . NOTEQ str

    LD              reduce using rule 59 (str -> str GD str .)
    LDEQ            reduce using rule 59 (str -> str GD str .)
    GD              reduce using rule 59 (str -> str GD str .)
    GDEQ            reduce using rule 59 (str -> str GD str .)
    EQUALEQUAL      reduce using rule 59 (str -> str GD str .)
    NOTEQ           reduce using rule 59 (str -> str GD str .)
    NEWLINE         reduce using rule 59 (str -> str GD str .)
    $end            reduce using rule 59 (str -> str GD str .)
    COMMA           reduce using rule 59 (str -> str GD str .)
    RBRACE          reduce using rule 59 (str -> str GD str .)
    RPAREN          reduce using rule 59 (str -> str GD str .)
    START           reduce using rule 59 (str -> str GD str .)
    STOP            reduce using rule 59 (str -> str GD str .)
    RETURN          reduce using rule 59 (str -> str GD str .)
    PLUS            shift and go to state 51

  ! PLUS            [ reduce using rule 59 (str -> str GD str .) ]
  ! LD              [ shift and go to state 52 ]
  ! LDEQ            [ shift and go to state 53 ]
  ! GD              [ shift and go to state 54 ]
  ! GDEQ            [ shift and go to state 55 ]
  ! EQUALEQUAL      [ shift and go to state 56 ]
  ! NOTEQ           [ shift and go to state 57 ]


state 99

    (60) str -> str GDEQ str .
    (56) str -> str . PLUS str
    (57) str -> str . LD str
    (58) str -> str . LDEQ str
    (59) str -> str . GD str
    (60) str -> str . GDEQ str
    (61) str -> str . EQUALEQUAL str
    (62) str -> str . NOTEQ str

    LD              reduce using rule 60 (str -> str GDEQ str .)
    LDEQ            reduce using rule 60 (str -> str GDEQ str .)
    GD              reduce using rule 60 (str -> str GDEQ str .)
    GDEQ            reduce using rule 60 (str -> str GDEQ str .)
    EQUALEQUAL      reduce using rule 60 (str -> str GDEQ str .)
    NOTEQ           reduce using rule 60 (str -> str GDEQ str .)
    NEWLINE         reduce using rule 60 (str -> str GDEQ str .)
    $end            reduce using rule 60 (str -> str GDEQ str .)
    COMMA           reduce using rule 60 (str -> str GDEQ str .)
    RBRACE          reduce using rule 60 (str -> str GDEQ str .)
    RPAREN          reduce using rule 60 (str -> str GDEQ str .)
    START           reduce using rule 60 (str -> str GDEQ str .)
    STOP            reduce using rule 60 (str -> str GDEQ str .)
    RETURN          reduce using rule 60 (str -> str GDEQ str .)
    PLUS            shift and go to state 51

  ! PLUS            [ reduce using rule 60 (str -> str GDEQ str .) ]
  ! LD              [ shift and go to state 52 ]
  ! LDEQ            [ shift and go to state 53 ]
  ! GD              [ shift and go to state 54 ]
  ! GDEQ            [ shift and go to state 55 ]
  ! EQUALEQUAL      [ shift and go to state 56 ]
  ! NOTEQ           [ shift and go to state 57 ]


state 100

    (61) str -> str EQUALEQUAL str .
    (56) str -> str . PLUS str
    (57) str -> str . LD str
    (58) str -> str . LDEQ str
    (59) str -> str . GD str
    (60) str -> str . GDEQ str
    (61) str -> str . EQUALEQUAL str
    (62) str -> str . NOTEQ str

    EQUALEQUAL      reduce using rule 61 (str -> str EQUALEQUAL str .)
    NOTEQ           reduce using rule 61 (str -> str EQUALEQUAL str .)
    NEWLINE         reduce using rule 61 (str -> str EQUALEQUAL str .)
    $end            reduce using rule 61 (str -> str EQUALEQUAL str .)
    COMMA           reduce using rule 61 (str -> str EQUALEQUAL str .)
    RBRACE          reduce using rule 61 (str -> str EQUALEQUAL str .)
    RPAREN          reduce using rule 61 (str -> str EQUALEQUAL str .)
    START           reduce using rule 61 (str -> str EQUALEQUAL str .)
    STOP            reduce using rule 61 (str -> str EQUALEQUAL str .)
    RETURN          reduce using rule 61 (str -> str EQUALEQUAL str .)
    PLUS            shift and go to state 51
    LD              shift and go to state 52
    LDEQ            shift and go to state 53
    GD              shift and go to state 54
    GDEQ            shift and go to state 55

  ! PLUS            [ reduce using rule 61 (str -> str EQUALEQUAL str .) ]
  ! LD              [ reduce using rule 61 (str -> str EQUALEQUAL str .) ]
  ! LDEQ            [ reduce using rule 61 (str -> str EQUALEQUAL str .) ]
  ! GD              [ reduce using rule 61 (str -> str EQUALEQUAL str .) ]
  ! GDEQ            [ reduce using rule 61 (str -> str EQUALEQUAL str .) ]
  ! EQUALEQUAL      [ shift and go to state 56 ]
  ! NOTEQ           [ shift and go to state 57 ]


state 101

    (62) str -> str NOTEQ str .
    (56) str -> str . PLUS str
    (57) str -> str . LD str
    (58) str -> str . LDEQ str
    (59) str -> str . GD str
    (60) str -> str . GDEQ str
    (61) str -> str . EQUALEQUAL str
    (62) str -> str . NOTEQ str

    EQUALEQUAL      reduce using rule 62 (str -> str NOTEQ str .)
    NOTEQ           reduce using rule 62 (str -> str NOTEQ str .)
    NEWLINE         reduce using rule 62 (str -> str NOTEQ str .)
    $end            reduce using rule 62 (str -> str NOTEQ str .)
    COMMA           reduce using rule 62 (str -> str NOTEQ str .)
    RBRACE          reduce using rule 62 (str -> str NOTEQ str .)
    RPAREN          reduce using rule 62 (str -> str NOTEQ str .)
    START           reduce using rule 62 (str -> str NOTEQ str .)
    STOP            reduce using rule 62 (str -> str NOTEQ str .)
    RETURN          reduce using rule 62 (str -> str NOTEQ str .)
    PLUS            shift and go to state 51
    LD              shift and go to state 52
    LDEQ            shift and go to state 53
    GD              shift and go to state 54
    GDEQ            shift and go to state 55

  ! PLUS            [ reduce using rule 62 (str -> str NOTEQ str .) ]
  ! LD              [ reduce using rule 62 (str -> str NOTEQ str .) ]
  ! LDEQ            [ reduce using rule 62 (str -> str NOTEQ str .) ]
  ! GD              [ reduce using rule 62 (str -> str NOTEQ str .) ]
  ! GDEQ            [ reduce using rule 62 (str -> str NOTEQ str .) ]
  ! EQUALEQUAL      [ shift and go to state 56 ]
  ! NOTEQ           [ shift and go to state 57 ]


state 102

    (66) expression -> LBRACE int_type_array RBRACE .

    NEWLINE         reduce using rule 66 (expression -> LBRACE int_type_array RBRACE .)
    $end            reduce using rule 66 (expression -> LBRACE int_type_array RBRACE .)
    START           reduce using rule 66 (expression -> LBRACE int_type_array RBRACE .)
    STOP            reduce using rule 66 (expression -> LBRACE int_type_array RBRACE .)
    RETURN          reduce using rule 66 (expression -> LBRACE int_type_array RBRACE .)
    COMMA           reduce using rule 66 (expression -> LBRACE int_type_array RBRACE .)
    RPAREN          reduce using rule 66 (expression -> LBRACE int_type_array RBRACE .)


state 103

    (67) expression -> LBRACE string_type_array RBRACE .

    NEWLINE         reduce using rule 67 (expression -> LBRACE string_type_array RBRACE .)
    $end            reduce using rule 67 (expression -> LBRACE string_type_array RBRACE .)
    START           reduce using rule 67 (expression -> LBRACE string_type_array RBRACE .)
    STOP            reduce using rule 67 (expression -> LBRACE string_type_array RBRACE .)
    RETURN          reduce using rule 67 (expression -> LBRACE string_type_array RBRACE .)
    COMMA           reduce using rule 67 (expression -> LBRACE string_type_array RBRACE .)
    RPAREN          reduce using rule 67 (expression -> LBRACE string_type_array RBRACE .)


state 104

    (69) int_type_array -> math COMMA . int_type_array
    (68) int_type_array -> . math
    (69) int_type_array -> . math COMMA int_type_array
    (37) math -> . math MULTIPLY math
    (38) math -> . math DIVIDE math
    (39) math -> . math MODULO math
    (40) math -> . math PLUS math
    (41) math -> . math MINUS math
    (42) math -> . math LD math
    (43) math -> . math LDEQ math
    (44) math -> . math GD math
    (45) math -> . math GDEQ math
    (46) math -> . math EQUALEQUAL math
    (47) math -> . math NOTEQ math
    (48) math -> . math AND math
    (49) math -> . math OR math
    (50) math -> . NOT math
    (51) math -> . MINUS math
    (52) math -> . INT
    (53) math -> . FLOAT
    (54) math -> . TRUE
    (55) math -> . FALSE
    (64) math -> . NAME
    (72) math -> . LPAREN math RPAREN

    NOT             shift and go to state 24
    MINUS           shift and go to state 23
    INT             shift and go to state 25
    FLOAT           shift and go to state 26
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    NAME            shift and go to state 71
    LPAREN          shift and go to state 72

    math                           shift and go to state 60
    int_type_array                 shift and go to state 116

state 105

    (71) string_type_array -> str COMMA . string_type_array
    (70) string_type_array -> . str
    (71) string_type_array -> . str COMMA string_type_array
    (56) str -> . str PLUS str
    (57) str -> . str LD str
    (58) str -> . str LDEQ str
    (59) str -> . str GD str
    (60) str -> . str GDEQ str
    (61) str -> . str EQUALEQUAL str
    (62) str -> . str NOTEQ str
    (63) str -> . STRING
    (65) str -> . NAME
    (73) str -> . LPAREN str RPAREN

    STRING          shift and go to state 29
    NAME            shift and go to state 94
    LPAREN          shift and go to state 95

    str                            shift and go to state 61
    string_type_array              shift and go to state 117

state 106

    (33) var_assign -> datatype NAME EQUALS . expression
    (32) expression -> . NAME
    (35) expression -> . math
    (36) expression -> . str
    (66) expression -> . LBRACE int_type_array RBRACE
    (67) expression -> . LBRACE string_type_array RBRACE
    (37) math -> . math MULTIPLY math
    (38) math -> . math DIVIDE math
    (39) math -> . math MODULO math
    (40) math -> . math PLUS math
    (41) math -> . math MINUS math
    (42) math -> . math LD math
    (43) math -> . math LDEQ math
    (44) math -> . math GD math
    (45) math -> . math GDEQ math
    (46) math -> . math EQUALEQUAL math
    (47) math -> . math NOTEQ math
    (48) math -> . math AND math
    (49) math -> . math OR math
    (50) math -> . NOT math
    (51) math -> . MINUS math
    (52) math -> . INT
    (53) math -> . FLOAT
    (54) math -> . TRUE
    (55) math -> . FALSE
    (64) math -> . NAME
    (72) math -> . LPAREN math RPAREN
    (56) str -> . str PLUS str
    (57) str -> . str LD str
    (58) str -> . str LDEQ str
    (59) str -> . str GD str
    (60) str -> . str GDEQ str
    (61) str -> . str EQUALEQUAL str
    (62) str -> . str NOTEQ str
    (63) str -> . STRING
    (65) str -> . NAME
    (73) str -> . LPAREN str RPAREN

    NAME            shift and go to state 67
    LBRACE          shift and go to state 16
    NOT             shift and go to state 24
    MINUS           shift and go to state 23
    INT             shift and go to state 25
    FLOAT           shift and go to state 26
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    LPAREN          shift and go to state 18
    STRING          shift and go to state 29

    expression                     shift and go to state 118
    math                           shift and go to state 14
    str                            shift and go to state 15

state 107

    (17) func_assign -> datatype NAME LPAREN . parameters RPAREN START NEWLINE language return_stmt STOP
    (21) parameters -> . first_param
    (22) parameters -> . empty
    (23) first_param -> . datatype NAME COMMA first_param
    (24) first_param -> . datatype NAME
    (81) empty -> .
    (25) datatype -> . INT_TYPE
    (26) datatype -> . FLOAT_TYPE
    (27) datatype -> . STRING_TYPE
    (28) datatype -> . VOID_TYPE

    RPAREN          reduce using rule 81 (empty -> .)
    INT_TYPE        shift and go to state 30
    FLOAT_TYPE      shift and go to state 31
    STRING_TYPE     shift and go to state 32
    VOID_TYPE       shift and go to state 33

    datatype                       shift and go to state 119
    parameters                     shift and go to state 120
    first_param                    shift and go to state 121
    empty                          shift and go to state 122

state 108

    (72) math -> LPAREN math RPAREN .

    MULTIPLY        reduce using rule 72 (math -> LPAREN math RPAREN .)
    DIVIDE          reduce using rule 72 (math -> LPAREN math RPAREN .)
    MODULO          reduce using rule 72 (math -> LPAREN math RPAREN .)
    PLUS            reduce using rule 72 (math -> LPAREN math RPAREN .)
    MINUS           reduce using rule 72 (math -> LPAREN math RPAREN .)
    LD              reduce using rule 72 (math -> LPAREN math RPAREN .)
    LDEQ            reduce using rule 72 (math -> LPAREN math RPAREN .)
    GD              reduce using rule 72 (math -> LPAREN math RPAREN .)
    GDEQ            reduce using rule 72 (math -> LPAREN math RPAREN .)
    EQUALEQUAL      reduce using rule 72 (math -> LPAREN math RPAREN .)
    NOTEQ           reduce using rule 72 (math -> LPAREN math RPAREN .)
    AND             reduce using rule 72 (math -> LPAREN math RPAREN .)
    OR              reduce using rule 72 (math -> LPAREN math RPAREN .)
    NEWLINE         reduce using rule 72 (math -> LPAREN math RPAREN .)
    $end            reduce using rule 72 (math -> LPAREN math RPAREN .)
    COMMA           reduce using rule 72 (math -> LPAREN math RPAREN .)
    RBRACE          reduce using rule 72 (math -> LPAREN math RPAREN .)
    RPAREN          reduce using rule 72 (math -> LPAREN math RPAREN .)
    START           reduce using rule 72 (math -> LPAREN math RPAREN .)
    STOP            reduce using rule 72 (math -> LPAREN math RPAREN .)
    RETURN          reduce using rule 72 (math -> LPAREN math RPAREN .)


state 109

    (73) str -> LPAREN str RPAREN .

    PLUS            reduce using rule 73 (str -> LPAREN str RPAREN .)
    LD              reduce using rule 73 (str -> LPAREN str RPAREN .)
    LDEQ            reduce using rule 73 (str -> LPAREN str RPAREN .)
    GD              reduce using rule 73 (str -> LPAREN str RPAREN .)
    GDEQ            reduce using rule 73 (str -> LPAREN str RPAREN .)
    EQUALEQUAL      reduce using rule 73 (str -> LPAREN str RPAREN .)
    NOTEQ           reduce using rule 73 (str -> LPAREN str RPAREN .)
    NEWLINE         reduce using rule 73 (str -> LPAREN str RPAREN .)
    $end            reduce using rule 73 (str -> LPAREN str RPAREN .)
    COMMA           reduce using rule 73 (str -> LPAREN str RPAREN .)
    RBRACE          reduce using rule 73 (str -> LPAREN str RPAREN .)
    RPAREN          reduce using rule 73 (str -> LPAREN str RPAREN .)
    START           reduce using rule 73 (str -> LPAREN str RPAREN .)
    STOP            reduce using rule 73 (str -> LPAREN str RPAREN .)
    RETURN          reduce using rule 73 (str -> LPAREN str RPAREN .)


state 110

    (80) iterative -> WHILE expression START . NEWLINE language STOP

    NEWLINE         shift and go to state 123


state 111

    (74) conditional -> IF expression START . NEWLINE language STOP else_if_blocks else_block

    NEWLINE         shift and go to state 124


state 112

    (29) input -> READ LPAREN NAME . RPAREN

    RPAREN          shift and go to state 125


state 113

    (31) output_print -> PRINT LPAREN expression . RPAREN

    RPAREN          shift and go to state 126


state 114

    (14) func_call -> NAME LPAREN pars RPAREN .

    NEWLINE         reduce using rule 14 (func_call -> NAME LPAREN pars RPAREN .)
    $end            reduce using rule 14 (func_call -> NAME LPAREN pars RPAREN .)
    STOP            reduce using rule 14 (func_call -> NAME LPAREN pars RPAREN .)
    RETURN          reduce using rule 14 (func_call -> NAME LPAREN pars RPAREN .)


state 115

    (16) pars -> expression COMMA . expression
    (32) expression -> . NAME
    (35) expression -> . math
    (36) expression -> . str
    (66) expression -> . LBRACE int_type_array RBRACE
    (67) expression -> . LBRACE string_type_array RBRACE
    (37) math -> . math MULTIPLY math
    (38) math -> . math DIVIDE math
    (39) math -> . math MODULO math
    (40) math -> . math PLUS math
    (41) math -> . math MINUS math
    (42) math -> . math LD math
    (43) math -> . math LDEQ math
    (44) math -> . math GD math
    (45) math -> . math GDEQ math
    (46) math -> . math EQUALEQUAL math
    (47) math -> . math NOTEQ math
    (48) math -> . math AND math
    (49) math -> . math OR math
    (50) math -> . NOT math
    (51) math -> . MINUS math
    (52) math -> . INT
    (53) math -> . FLOAT
    (54) math -> . TRUE
    (55) math -> . FALSE
    (64) math -> . NAME
    (72) math -> . LPAREN math RPAREN
    (56) str -> . str PLUS str
    (57) str -> . str LD str
    (58) str -> . str LDEQ str
    (59) str -> . str GD str
    (60) str -> . str GDEQ str
    (61) str -> . str EQUALEQUAL str
    (62) str -> . str NOTEQ str
    (63) str -> . STRING
    (65) str -> . NAME
    (73) str -> . LPAREN str RPAREN

    NAME            shift and go to state 67
    LBRACE          shift and go to state 16
    NOT             shift and go to state 24
    MINUS           shift and go to state 23
    INT             shift and go to state 25
    FLOAT           shift and go to state 26
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    LPAREN          shift and go to state 18
    STRING          shift and go to state 29

    expression                     shift and go to state 127
    math                           shift and go to state 14
    str                            shift and go to state 15

state 116

    (69) int_type_array -> math COMMA int_type_array .

    RBRACE          reduce using rule 69 (int_type_array -> math COMMA int_type_array .)


state 117

    (71) string_type_array -> str COMMA string_type_array .

    RBRACE          reduce using rule 71 (string_type_array -> str COMMA string_type_array .)


state 118

    (33) var_assign -> datatype NAME EQUALS expression .

    NEWLINE         reduce using rule 33 (var_assign -> datatype NAME EQUALS expression .)
    $end            reduce using rule 33 (var_assign -> datatype NAME EQUALS expression .)
    STOP            reduce using rule 33 (var_assign -> datatype NAME EQUALS expression .)
    RETURN          reduce using rule 33 (var_assign -> datatype NAME EQUALS expression .)


state 119

    (23) first_param -> datatype . NAME COMMA first_param
    (24) first_param -> datatype . NAME

    NAME            shift and go to state 128


state 120

    (17) func_assign -> datatype NAME LPAREN parameters . RPAREN START NEWLINE language return_stmt STOP

    RPAREN          shift and go to state 129


state 121

    (21) parameters -> first_param .

    RPAREN          reduce using rule 21 (parameters -> first_param .)


state 122

    (22) parameters -> empty .

    RPAREN          reduce using rule 22 (parameters -> empty .)


state 123

    (80) iterative -> WHILE expression START NEWLINE . language STOP
    (3) language -> . language NEWLINE line
    (4) language -> . line
    (5) line -> . expression
    (6) line -> . var_assign
    (7) line -> . func_assign
    (8) line -> . iterative
    (9) line -> . conditional
    (10) line -> . func_call
    (11) line -> . output
    (12) line -> . input
    (13) line -> . empty
    (32) expression -> . NAME
    (35) expression -> . math
    (36) expression -> . str
    (66) expression -> . LBRACE int_type_array RBRACE
    (67) expression -> . LBRACE string_type_array RBRACE
    (33) var_assign -> . datatype NAME EQUALS expression
    (34) var_assign -> . NAME EQUALS expression
    (17) func_assign -> . datatype NAME LPAREN parameters RPAREN START NEWLINE language return_stmt STOP
    (80) iterative -> . WHILE expression START NEWLINE language STOP
    (74) conditional -> . IF expression START NEWLINE language STOP else_if_blocks else_block
    (14) func_call -> . NAME LPAREN pars RPAREN
    (30) output -> . output_print
    (29) input -> . READ LPAREN NAME RPAREN
    (81) empty -> .
    (37) math -> . math MULTIPLY math
    (38) math -> . math DIVIDE math
    (39) math -> . math MODULO math
    (40) math -> . math PLUS math
    (41) math -> . math MINUS math
    (42) math -> . math LD math
    (43) math -> . math LDEQ math
    (44) math -> . math GD math
    (45) math -> . math GDEQ math
    (46) math -> . math EQUALEQUAL math
    (47) math -> . math NOTEQ math
    (48) math -> . math AND math
    (49) math -> . math OR math
    (50) math -> . NOT math
    (51) math -> . MINUS math
    (52) math -> . INT
    (53) math -> . FLOAT
    (54) math -> . TRUE
    (55) math -> . FALSE
    (64) math -> . NAME
    (72) math -> . LPAREN math RPAREN
    (56) str -> . str PLUS str
    (57) str -> . str LD str
    (58) str -> . str LDEQ str
    (59) str -> . str GD str
    (60) str -> . str GDEQ str
    (61) str -> . str EQUALEQUAL str
    (62) str -> . str NOTEQ str
    (63) str -> . STRING
    (65) str -> . NAME
    (73) str -> . LPAREN str RPAREN
    (25) datatype -> . INT_TYPE
    (26) datatype -> . FLOAT_TYPE
    (27) datatype -> . STRING_TYPE
    (28) datatype -> . VOID_TYPE
    (31) output_print -> . PRINT LPAREN expression RPAREN

    NAME            shift and go to state 13
    LBRACE          shift and go to state 16
    WHILE           shift and go to state 19
    IF              shift and go to state 20
    READ            shift and go to state 22
    STOP            reduce using rule 81 (empty -> .)
    NEWLINE         reduce using rule 81 (empty -> .)
    NOT             shift and go to state 24
    MINUS           shift and go to state 23
    INT             shift and go to state 25
    FLOAT           shift and go to state 26
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    LPAREN          shift and go to state 18
    STRING          shift and go to state 29
    INT_TYPE        shift and go to state 30
    FLOAT_TYPE      shift and go to state 31
    STRING_TYPE     shift and go to state 32
    VOID_TYPE       shift and go to state 33
    PRINT           shift and go to state 34

    expression                     shift and go to state 5
    language                       shift and go to state 130
    line                           shift and go to state 4
    var_assign                     shift and go to state 6
    func_assign                    shift and go to state 7
    iterative                      shift and go to state 8
    conditional                    shift and go to state 9
    func_call                      shift and go to state 10
    output                         shift and go to state 11
    input                          shift and go to state 12
    empty                          shift and go to state 76
    math                           shift and go to state 14
    str                            shift and go to state 15
    datatype                       shift and go to state 17
    output_print                   shift and go to state 21

state 124

    (74) conditional -> IF expression START NEWLINE . language STOP else_if_blocks else_block
    (3) language -> . language NEWLINE line
    (4) language -> . line
    (5) line -> . expression
    (6) line -> . var_assign
    (7) line -> . func_assign
    (8) line -> . iterative
    (9) line -> . conditional
    (10) line -> . func_call
    (11) line -> . output
    (12) line -> . input
    (13) line -> . empty
    (32) expression -> . NAME
    (35) expression -> . math
    (36) expression -> . str
    (66) expression -> . LBRACE int_type_array RBRACE
    (67) expression -> . LBRACE string_type_array RBRACE
    (33) var_assign -> . datatype NAME EQUALS expression
    (34) var_assign -> . NAME EQUALS expression
    (17) func_assign -> . datatype NAME LPAREN parameters RPAREN START NEWLINE language return_stmt STOP
    (80) iterative -> . WHILE expression START NEWLINE language STOP
    (74) conditional -> . IF expression START NEWLINE language STOP else_if_blocks else_block
    (14) func_call -> . NAME LPAREN pars RPAREN
    (30) output -> . output_print
    (29) input -> . READ LPAREN NAME RPAREN
    (81) empty -> .
    (37) math -> . math MULTIPLY math
    (38) math -> . math DIVIDE math
    (39) math -> . math MODULO math
    (40) math -> . math PLUS math
    (41) math -> . math MINUS math
    (42) math -> . math LD math
    (43) math -> . math LDEQ math
    (44) math -> . math GD math
    (45) math -> . math GDEQ math
    (46) math -> . math EQUALEQUAL math
    (47) math -> . math NOTEQ math
    (48) math -> . math AND math
    (49) math -> . math OR math
    (50) math -> . NOT math
    (51) math -> . MINUS math
    (52) math -> . INT
    (53) math -> . FLOAT
    (54) math -> . TRUE
    (55) math -> . FALSE
    (64) math -> . NAME
    (72) math -> . LPAREN math RPAREN
    (56) str -> . str PLUS str
    (57) str -> . str LD str
    (58) str -> . str LDEQ str
    (59) str -> . str GD str
    (60) str -> . str GDEQ str
    (61) str -> . str EQUALEQUAL str
    (62) str -> . str NOTEQ str
    (63) str -> . STRING
    (65) str -> . NAME
    (73) str -> . LPAREN str RPAREN
    (25) datatype -> . INT_TYPE
    (26) datatype -> . FLOAT_TYPE
    (27) datatype -> . STRING_TYPE
    (28) datatype -> . VOID_TYPE
    (31) output_print -> . PRINT LPAREN expression RPAREN

    NAME            shift and go to state 13
    LBRACE          shift and go to state 16
    WHILE           shift and go to state 19
    IF              shift and go to state 20
    READ            shift and go to state 22
    STOP            reduce using rule 81 (empty -> .)
    NEWLINE         reduce using rule 81 (empty -> .)
    NOT             shift and go to state 24
    MINUS           shift and go to state 23
    INT             shift and go to state 25
    FLOAT           shift and go to state 26
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    LPAREN          shift and go to state 18
    STRING          shift and go to state 29
    INT_TYPE        shift and go to state 30
    FLOAT_TYPE      shift and go to state 31
    STRING_TYPE     shift and go to state 32
    VOID_TYPE       shift and go to state 33
    PRINT           shift and go to state 34

    expression                     shift and go to state 5
    language                       shift and go to state 131
    line                           shift and go to state 4
    var_assign                     shift and go to state 6
    func_assign                    shift and go to state 7
    iterative                      shift and go to state 8
    conditional                    shift and go to state 9
    func_call                      shift and go to state 10
    output                         shift and go to state 11
    input                          shift and go to state 12
    empty                          shift and go to state 76
    math                           shift and go to state 14
    str                            shift and go to state 15
    datatype                       shift and go to state 17
    output_print                   shift and go to state 21

state 125

    (29) input -> READ LPAREN NAME RPAREN .

    NEWLINE         reduce using rule 29 (input -> READ LPAREN NAME RPAREN .)
    $end            reduce using rule 29 (input -> READ LPAREN NAME RPAREN .)
    STOP            reduce using rule 29 (input -> READ LPAREN NAME RPAREN .)
    RETURN          reduce using rule 29 (input -> READ LPAREN NAME RPAREN .)


state 126

    (31) output_print -> PRINT LPAREN expression RPAREN .

    NEWLINE         reduce using rule 31 (output_print -> PRINT LPAREN expression RPAREN .)
    $end            reduce using rule 31 (output_print -> PRINT LPAREN expression RPAREN .)
    STOP            reduce using rule 31 (output_print -> PRINT LPAREN expression RPAREN .)
    RETURN          reduce using rule 31 (output_print -> PRINT LPAREN expression RPAREN .)


state 127

    (16) pars -> expression COMMA expression .

    RPAREN          reduce using rule 16 (pars -> expression COMMA expression .)


state 128

    (23) first_param -> datatype NAME . COMMA first_param
    (24) first_param -> datatype NAME .

    COMMA           shift and go to state 132
    RPAREN          reduce using rule 24 (first_param -> datatype NAME .)


state 129

    (17) func_assign -> datatype NAME LPAREN parameters RPAREN . START NEWLINE language return_stmt STOP

    START           shift and go to state 133


state 130

    (80) iterative -> WHILE expression START NEWLINE language . STOP
    (3) language -> language . NEWLINE line

    STOP            shift and go to state 134
    NEWLINE         shift and go to state 35


state 131

    (74) conditional -> IF expression START NEWLINE language . STOP else_if_blocks else_block
    (3) language -> language . NEWLINE line

    STOP            shift and go to state 135
    NEWLINE         shift and go to state 35


state 132

    (23) first_param -> datatype NAME COMMA . first_param
    (23) first_param -> . datatype NAME COMMA first_param
    (24) first_param -> . datatype NAME
    (25) datatype -> . INT_TYPE
    (26) datatype -> . FLOAT_TYPE
    (27) datatype -> . STRING_TYPE
    (28) datatype -> . VOID_TYPE

    INT_TYPE        shift and go to state 30
    FLOAT_TYPE      shift and go to state 31
    STRING_TYPE     shift and go to state 32
    VOID_TYPE       shift and go to state 33

    datatype                       shift and go to state 119
    first_param                    shift and go to state 136

state 133

    (17) func_assign -> datatype NAME LPAREN parameters RPAREN START . NEWLINE language return_stmt STOP

    NEWLINE         shift and go to state 137


state 134

    (80) iterative -> WHILE expression START NEWLINE language STOP .

    NEWLINE         reduce using rule 80 (iterative -> WHILE expression START NEWLINE language STOP .)
    $end            reduce using rule 80 (iterative -> WHILE expression START NEWLINE language STOP .)
    STOP            reduce using rule 80 (iterative -> WHILE expression START NEWLINE language STOP .)
    RETURN          reduce using rule 80 (iterative -> WHILE expression START NEWLINE language STOP .)


state 135

    (74) conditional -> IF expression START NEWLINE language STOP . else_if_blocks else_block
    (75) else_if_blocks -> . empty
    (76) else_if_blocks -> . else_if_block else_if_blocks
    (81) empty -> .
    (77) else_if_block -> . ELSE_IF expression START NEWLINE language STOP

    ELSE            reduce using rule 81 (empty -> .)
    NEWLINE         reduce using rule 81 (empty -> .)
    $end            reduce using rule 81 (empty -> .)
    STOP            reduce using rule 81 (empty -> .)
    RETURN          reduce using rule 81 (empty -> .)
    ELSE_IF         shift and go to state 141

    else_if_blocks                 shift and go to state 138
    empty                          shift and go to state 139
    else_if_block                  shift and go to state 140

state 136

    (23) first_param -> datatype NAME COMMA first_param .

    RPAREN          reduce using rule 23 (first_param -> datatype NAME COMMA first_param .)


state 137

    (17) func_assign -> datatype NAME LPAREN parameters RPAREN START NEWLINE . language return_stmt STOP
    (3) language -> . language NEWLINE line
    (4) language -> . line
    (5) line -> . expression
    (6) line -> . var_assign
    (7) line -> . func_assign
    (8) line -> . iterative
    (9) line -> . conditional
    (10) line -> . func_call
    (11) line -> . output
    (12) line -> . input
    (13) line -> . empty
    (32) expression -> . NAME
    (35) expression -> . math
    (36) expression -> . str
    (66) expression -> . LBRACE int_type_array RBRACE
    (67) expression -> . LBRACE string_type_array RBRACE
    (33) var_assign -> . datatype NAME EQUALS expression
    (34) var_assign -> . NAME EQUALS expression
    (17) func_assign -> . datatype NAME LPAREN parameters RPAREN START NEWLINE language return_stmt STOP
    (80) iterative -> . WHILE expression START NEWLINE language STOP
    (74) conditional -> . IF expression START NEWLINE language STOP else_if_blocks else_block
    (14) func_call -> . NAME LPAREN pars RPAREN
    (30) output -> . output_print
    (29) input -> . READ LPAREN NAME RPAREN
    (81) empty -> .
    (37) math -> . math MULTIPLY math
    (38) math -> . math DIVIDE math
    (39) math -> . math MODULO math
    (40) math -> . math PLUS math
    (41) math -> . math MINUS math
    (42) math -> . math LD math
    (43) math -> . math LDEQ math
    (44) math -> . math GD math
    (45) math -> . math GDEQ math
    (46) math -> . math EQUALEQUAL math
    (47) math -> . math NOTEQ math
    (48) math -> . math AND math
    (49) math -> . math OR math
    (50) math -> . NOT math
    (51) math -> . MINUS math
    (52) math -> . INT
    (53) math -> . FLOAT
    (54) math -> . TRUE
    (55) math -> . FALSE
    (64) math -> . NAME
    (72) math -> . LPAREN math RPAREN
    (56) str -> . str PLUS str
    (57) str -> . str LD str
    (58) str -> . str LDEQ str
    (59) str -> . str GD str
    (60) str -> . str GDEQ str
    (61) str -> . str EQUALEQUAL str
    (62) str -> . str NOTEQ str
    (63) str -> . STRING
    (65) str -> . NAME
    (73) str -> . LPAREN str RPAREN
    (25) datatype -> . INT_TYPE
    (26) datatype -> . FLOAT_TYPE
    (27) datatype -> . STRING_TYPE
    (28) datatype -> . VOID_TYPE
    (31) output_print -> . PRINT LPAREN expression RPAREN

    NAME            shift and go to state 13
    LBRACE          shift and go to state 16
    WHILE           shift and go to state 19
    IF              shift and go to state 20
    READ            shift and go to state 22
    NEWLINE         reduce using rule 81 (empty -> .)
    RETURN          reduce using rule 81 (empty -> .)
    STOP            reduce using rule 81 (empty -> .)
    NOT             shift and go to state 24
    MINUS           shift and go to state 23
    INT             shift and go to state 25
    FLOAT           shift and go to state 26
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    LPAREN          shift and go to state 18
    STRING          shift and go to state 29
    INT_TYPE        shift and go to state 30
    FLOAT_TYPE      shift and go to state 31
    STRING_TYPE     shift and go to state 32
    VOID_TYPE       shift and go to state 33
    PRINT           shift and go to state 34

    datatype                       shift and go to state 17
    language                       shift and go to state 142
    line                           shift and go to state 4
    expression                     shift and go to state 5
    var_assign                     shift and go to state 6
    func_assign                    shift and go to state 7
    iterative                      shift and go to state 8
    conditional                    shift and go to state 9
    func_call                      shift and go to state 10
    output                         shift and go to state 11
    input                          shift and go to state 12
    empty                          shift and go to state 76
    math                           shift and go to state 14
    str                            shift and go to state 15
    output_print                   shift and go to state 21

state 138

    (74) conditional -> IF expression START NEWLINE language STOP else_if_blocks . else_block
    (78) else_block -> . ELSE START NEWLINE language STOP
    (79) else_block -> . empty
    (81) empty -> .

    ELSE            shift and go to state 144
    NEWLINE         reduce using rule 81 (empty -> .)
    $end            reduce using rule 81 (empty -> .)
    STOP            reduce using rule 81 (empty -> .)
    RETURN          reduce using rule 81 (empty -> .)

    else_block                     shift and go to state 143
    empty                          shift and go to state 145

state 139

    (75) else_if_blocks -> empty .

    ELSE            reduce using rule 75 (else_if_blocks -> empty .)
    NEWLINE         reduce using rule 75 (else_if_blocks -> empty .)
    $end            reduce using rule 75 (else_if_blocks -> empty .)
    STOP            reduce using rule 75 (else_if_blocks -> empty .)
    RETURN          reduce using rule 75 (else_if_blocks -> empty .)


state 140

    (76) else_if_blocks -> else_if_block . else_if_blocks
    (75) else_if_blocks -> . empty
    (76) else_if_blocks -> . else_if_block else_if_blocks
    (81) empty -> .
    (77) else_if_block -> . ELSE_IF expression START NEWLINE language STOP

    ELSE            reduce using rule 81 (empty -> .)
    NEWLINE         reduce using rule 81 (empty -> .)
    $end            reduce using rule 81 (empty -> .)
    STOP            reduce using rule 81 (empty -> .)
    RETURN          reduce using rule 81 (empty -> .)
    ELSE_IF         shift and go to state 141

    else_if_block                  shift and go to state 140
    else_if_blocks                 shift and go to state 146
    empty                          shift and go to state 139

state 141

    (77) else_if_block -> ELSE_IF . expression START NEWLINE language STOP
    (32) expression -> . NAME
    (35) expression -> . math
    (36) expression -> . str
    (66) expression -> . LBRACE int_type_array RBRACE
    (67) expression -> . LBRACE string_type_array RBRACE
    (37) math -> . math MULTIPLY math
    (38) math -> . math DIVIDE math
    (39) math -> . math MODULO math
    (40) math -> . math PLUS math
    (41) math -> . math MINUS math
    (42) math -> . math LD math
    (43) math -> . math LDEQ math
    (44) math -> . math GD math
    (45) math -> . math GDEQ math
    (46) math -> . math EQUALEQUAL math
    (47) math -> . math NOTEQ math
    (48) math -> . math AND math
    (49) math -> . math OR math
    (50) math -> . NOT math
    (51) math -> . MINUS math
    (52) math -> . INT
    (53) math -> . FLOAT
    (54) math -> . TRUE
    (55) math -> . FALSE
    (64) math -> . NAME
    (72) math -> . LPAREN math RPAREN
    (56) str -> . str PLUS str
    (57) str -> . str LD str
    (58) str -> . str LDEQ str
    (59) str -> . str GD str
    (60) str -> . str GDEQ str
    (61) str -> . str EQUALEQUAL str
    (62) str -> . str NOTEQ str
    (63) str -> . STRING
    (65) str -> . NAME
    (73) str -> . LPAREN str RPAREN

    NAME            shift and go to state 67
    LBRACE          shift and go to state 16
    NOT             shift and go to state 24
    MINUS           shift and go to state 23
    INT             shift and go to state 25
    FLOAT           shift and go to state 26
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    LPAREN          shift and go to state 18
    STRING          shift and go to state 29

    expression                     shift and go to state 147
    math                           shift and go to state 14
    str                            shift and go to state 15

state 142

    (17) func_assign -> datatype NAME LPAREN parameters RPAREN START NEWLINE language . return_stmt STOP
    (3) language -> language . NEWLINE line
    (18) return_stmt -> . RETURN expression NEWLINE
    (19) return_stmt -> . RETURN NEWLINE
    (20) return_stmt -> . empty
    (81) empty -> .

    NEWLINE         shift and go to state 35
    RETURN          shift and go to state 149
    STOP            reduce using rule 81 (empty -> .)

    return_stmt                    shift and go to state 148
    empty                          shift and go to state 150

state 143

    (74) conditional -> IF expression START NEWLINE language STOP else_if_blocks else_block .

    NEWLINE         reduce using rule 74 (conditional -> IF expression START NEWLINE language STOP else_if_blocks else_block .)
    $end            reduce using rule 74 (conditional -> IF expression START NEWLINE language STOP else_if_blocks else_block .)
    STOP            reduce using rule 74 (conditional -> IF expression START NEWLINE language STOP else_if_blocks else_block .)
    RETURN          reduce using rule 74 (conditional -> IF expression START NEWLINE language STOP else_if_blocks else_block .)


state 144

    (78) else_block -> ELSE . START NEWLINE language STOP

    START           shift and go to state 151


state 145

    (79) else_block -> empty .

    NEWLINE         reduce using rule 79 (else_block -> empty .)
    $end            reduce using rule 79 (else_block -> empty .)
    STOP            reduce using rule 79 (else_block -> empty .)
    RETURN          reduce using rule 79 (else_block -> empty .)


state 146

    (76) else_if_blocks -> else_if_block else_if_blocks .

    ELSE            reduce using rule 76 (else_if_blocks -> else_if_block else_if_blocks .)
    NEWLINE         reduce using rule 76 (else_if_blocks -> else_if_block else_if_blocks .)
    $end            reduce using rule 76 (else_if_blocks -> else_if_block else_if_blocks .)
    STOP            reduce using rule 76 (else_if_blocks -> else_if_block else_if_blocks .)
    RETURN          reduce using rule 76 (else_if_blocks -> else_if_block else_if_blocks .)


state 147

    (77) else_if_block -> ELSE_IF expression . START NEWLINE language STOP

    START           shift and go to state 152


state 148

    (17) func_assign -> datatype NAME LPAREN parameters RPAREN START NEWLINE language return_stmt . STOP

    STOP            shift and go to state 153


state 149

    (18) return_stmt -> RETURN . expression NEWLINE
    (19) return_stmt -> RETURN . NEWLINE
    (32) expression -> . NAME
    (35) expression -> . math
    (36) expression -> . str
    (66) expression -> . LBRACE int_type_array RBRACE
    (67) expression -> . LBRACE string_type_array RBRACE
    (37) math -> . math MULTIPLY math
    (38) math -> . math DIVIDE math
    (39) math -> . math MODULO math
    (40) math -> . math PLUS math
    (41) math -> . math MINUS math
    (42) math -> . math LD math
    (43) math -> . math LDEQ math
    (44) math -> . math GD math
    (45) math -> . math GDEQ math
    (46) math -> . math EQUALEQUAL math
    (47) math -> . math NOTEQ math
    (48) math -> . math AND math
    (49) math -> . math OR math
    (50) math -> . NOT math
    (51) math -> . MINUS math
    (52) math -> . INT
    (53) math -> . FLOAT
    (54) math -> . TRUE
    (55) math -> . FALSE
    (64) math -> . NAME
    (72) math -> . LPAREN math RPAREN
    (56) str -> . str PLUS str
    (57) str -> . str LD str
    (58) str -> . str LDEQ str
    (59) str -> . str GD str
    (60) str -> . str GDEQ str
    (61) str -> . str EQUALEQUAL str
    (62) str -> . str NOTEQ str
    (63) str -> . STRING
    (65) str -> . NAME
    (73) str -> . LPAREN str RPAREN

    NEWLINE         shift and go to state 155
    NAME            shift and go to state 67
    LBRACE          shift and go to state 16
    NOT             shift and go to state 24
    MINUS           shift and go to state 23
    INT             shift and go to state 25
    FLOAT           shift and go to state 26
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    LPAREN          shift and go to state 18
    STRING          shift and go to state 29

    expression                     shift and go to state 154
    math                           shift and go to state 14
    str                            shift and go to state 15

state 150

    (20) return_stmt -> empty .

    STOP            reduce using rule 20 (return_stmt -> empty .)


state 151

    (78) else_block -> ELSE START . NEWLINE language STOP

    NEWLINE         shift and go to state 156


state 152

    (77) else_if_block -> ELSE_IF expression START . NEWLINE language STOP

    NEWLINE         shift and go to state 157


state 153

    (17) func_assign -> datatype NAME LPAREN parameters RPAREN START NEWLINE language return_stmt STOP .

    NEWLINE         reduce using rule 17 (func_assign -> datatype NAME LPAREN parameters RPAREN START NEWLINE language return_stmt STOP .)
    $end            reduce using rule 17 (func_assign -> datatype NAME LPAREN parameters RPAREN START NEWLINE language return_stmt STOP .)
    STOP            reduce using rule 17 (func_assign -> datatype NAME LPAREN parameters RPAREN START NEWLINE language return_stmt STOP .)
    RETURN          reduce using rule 17 (func_assign -> datatype NAME LPAREN parameters RPAREN START NEWLINE language return_stmt STOP .)


state 154

    (18) return_stmt -> RETURN expression . NEWLINE

    NEWLINE         shift and go to state 158


state 155

    (19) return_stmt -> RETURN NEWLINE .

    STOP            reduce using rule 19 (return_stmt -> RETURN NEWLINE .)


state 156

    (78) else_block -> ELSE START NEWLINE . language STOP
    (3) language -> . language NEWLINE line
    (4) language -> . line
    (5) line -> . expression
    (6) line -> . var_assign
    (7) line -> . func_assign
    (8) line -> . iterative
    (9) line -> . conditional
    (10) line -> . func_call
    (11) line -> . output
    (12) line -> . input
    (13) line -> . empty
    (32) expression -> . NAME
    (35) expression -> . math
    (36) expression -> . str
    (66) expression -> . LBRACE int_type_array RBRACE
    (67) expression -> . LBRACE string_type_array RBRACE
    (33) var_assign -> . datatype NAME EQUALS expression
    (34) var_assign -> . NAME EQUALS expression
    (17) func_assign -> . datatype NAME LPAREN parameters RPAREN START NEWLINE language return_stmt STOP
    (80) iterative -> . WHILE expression START NEWLINE language STOP
    (74) conditional -> . IF expression START NEWLINE language STOP else_if_blocks else_block
    (14) func_call -> . NAME LPAREN pars RPAREN
    (30) output -> . output_print
    (29) input -> . READ LPAREN NAME RPAREN
    (81) empty -> .
    (37) math -> . math MULTIPLY math
    (38) math -> . math DIVIDE math
    (39) math -> . math MODULO math
    (40) math -> . math PLUS math
    (41) math -> . math MINUS math
    (42) math -> . math LD math
    (43) math -> . math LDEQ math
    (44) math -> . math GD math
    (45) math -> . math GDEQ math
    (46) math -> . math EQUALEQUAL math
    (47) math -> . math NOTEQ math
    (48) math -> . math AND math
    (49) math -> . math OR math
    (50) math -> . NOT math
    (51) math -> . MINUS math
    (52) math -> . INT
    (53) math -> . FLOAT
    (54) math -> . TRUE
    (55) math -> . FALSE
    (64) math -> . NAME
    (72) math -> . LPAREN math RPAREN
    (56) str -> . str PLUS str
    (57) str -> . str LD str
    (58) str -> . str LDEQ str
    (59) str -> . str GD str
    (60) str -> . str GDEQ str
    (61) str -> . str EQUALEQUAL str
    (62) str -> . str NOTEQ str
    (63) str -> . STRING
    (65) str -> . NAME
    (73) str -> . LPAREN str RPAREN
    (25) datatype -> . INT_TYPE
    (26) datatype -> . FLOAT_TYPE
    (27) datatype -> . STRING_TYPE
    (28) datatype -> . VOID_TYPE
    (31) output_print -> . PRINT LPAREN expression RPAREN

    NAME            shift and go to state 13
    LBRACE          shift and go to state 16
    WHILE           shift and go to state 19
    IF              shift and go to state 20
    READ            shift and go to state 22
    STOP            reduce using rule 81 (empty -> .)
    NEWLINE         reduce using rule 81 (empty -> .)
    NOT             shift and go to state 24
    MINUS           shift and go to state 23
    INT             shift and go to state 25
    FLOAT           shift and go to state 26
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    LPAREN          shift and go to state 18
    STRING          shift and go to state 29
    INT_TYPE        shift and go to state 30
    FLOAT_TYPE      shift and go to state 31
    STRING_TYPE     shift and go to state 32
    VOID_TYPE       shift and go to state 33
    PRINT           shift and go to state 34

    language                       shift and go to state 159
    line                           shift and go to state 4
    expression                     shift and go to state 5
    var_assign                     shift and go to state 6
    func_assign                    shift and go to state 7
    iterative                      shift and go to state 8
    conditional                    shift and go to state 9
    func_call                      shift and go to state 10
    output                         shift and go to state 11
    input                          shift and go to state 12
    empty                          shift and go to state 76
    math                           shift and go to state 14
    str                            shift and go to state 15
    datatype                       shift and go to state 17
    output_print                   shift and go to state 21

state 157

    (77) else_if_block -> ELSE_IF expression START NEWLINE . language STOP
    (3) language -> . language NEWLINE line
    (4) language -> . line
    (5) line -> . expression
    (6) line -> . var_assign
    (7) line -> . func_assign
    (8) line -> . iterative
    (9) line -> . conditional
    (10) line -> . func_call
    (11) line -> . output
    (12) line -> . input
    (13) line -> . empty
    (32) expression -> . NAME
    (35) expression -> . math
    (36) expression -> . str
    (66) expression -> . LBRACE int_type_array RBRACE
    (67) expression -> . LBRACE string_type_array RBRACE
    (33) var_assign -> . datatype NAME EQUALS expression
    (34) var_assign -> . NAME EQUALS expression
    (17) func_assign -> . datatype NAME LPAREN parameters RPAREN START NEWLINE language return_stmt STOP
    (80) iterative -> . WHILE expression START NEWLINE language STOP
    (74) conditional -> . IF expression START NEWLINE language STOP else_if_blocks else_block
    (14) func_call -> . NAME LPAREN pars RPAREN
    (30) output -> . output_print
    (29) input -> . READ LPAREN NAME RPAREN
    (81) empty -> .
    (37) math -> . math MULTIPLY math
    (38) math -> . math DIVIDE math
    (39) math -> . math MODULO math
    (40) math -> . math PLUS math
    (41) math -> . math MINUS math
    (42) math -> . math LD math
    (43) math -> . math LDEQ math
    (44) math -> . math GD math
    (45) math -> . math GDEQ math
    (46) math -> . math EQUALEQUAL math
    (47) math -> . math NOTEQ math
    (48) math -> . math AND math
    (49) math -> . math OR math
    (50) math -> . NOT math
    (51) math -> . MINUS math
    (52) math -> . INT
    (53) math -> . FLOAT
    (54) math -> . TRUE
    (55) math -> . FALSE
    (64) math -> . NAME
    (72) math -> . LPAREN math RPAREN
    (56) str -> . str PLUS str
    (57) str -> . str LD str
    (58) str -> . str LDEQ str
    (59) str -> . str GD str
    (60) str -> . str GDEQ str
    (61) str -> . str EQUALEQUAL str
    (62) str -> . str NOTEQ str
    (63) str -> . STRING
    (65) str -> . NAME
    (73) str -> . LPAREN str RPAREN
    (25) datatype -> . INT_TYPE
    (26) datatype -> . FLOAT_TYPE
    (27) datatype -> . STRING_TYPE
    (28) datatype -> . VOID_TYPE
    (31) output_print -> . PRINT LPAREN expression RPAREN

    NAME            shift and go to state 13
    LBRACE          shift and go to state 16
    WHILE           shift and go to state 19
    IF              shift and go to state 20
    READ            shift and go to state 22
    STOP            reduce using rule 81 (empty -> .)
    NEWLINE         reduce using rule 81 (empty -> .)
    NOT             shift and go to state 24
    MINUS           shift and go to state 23
    INT             shift and go to state 25
    FLOAT           shift and go to state 26
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    LPAREN          shift and go to state 18
    STRING          shift and go to state 29
    INT_TYPE        shift and go to state 30
    FLOAT_TYPE      shift and go to state 31
    STRING_TYPE     shift and go to state 32
    VOID_TYPE       shift and go to state 33
    PRINT           shift and go to state 34

    expression                     shift and go to state 5
    language                       shift and go to state 160
    line                           shift and go to state 4
    var_assign                     shift and go to state 6
    func_assign                    shift and go to state 7
    iterative                      shift and go to state 8
    conditional                    shift and go to state 9
    func_call                      shift and go to state 10
    output                         shift and go to state 11
    input                          shift and go to state 12
    empty                          shift and go to state 76
    math                           shift and go to state 14
    str                            shift and go to state 15
    datatype                       shift and go to state 17
    output_print                   shift and go to state 21

state 158

    (18) return_stmt -> RETURN expression NEWLINE .

    STOP            reduce using rule 18 (return_stmt -> RETURN expression NEWLINE .)


state 159

    (78) else_block -> ELSE START NEWLINE language . STOP
    (3) language -> language . NEWLINE line

    STOP            shift and go to state 161
    NEWLINE         shift and go to state 35


state 160

    (77) else_if_block -> ELSE_IF expression START NEWLINE language . STOP
    (3) language -> language . NEWLINE line

    STOP            shift and go to state 162
    NEWLINE         shift and go to state 35


state 161

    (78) else_block -> ELSE START NEWLINE language STOP .

    NEWLINE         reduce using rule 78 (else_block -> ELSE START NEWLINE language STOP .)
    $end            reduce using rule 78 (else_block -> ELSE START NEWLINE language STOP .)
    STOP            reduce using rule 78 (else_block -> ELSE START NEWLINE language STOP .)
    RETURN          reduce using rule 78 (else_block -> ELSE START NEWLINE language STOP .)


state 162

    (77) else_if_block -> ELSE_IF expression START NEWLINE language STOP .

    ELSE_IF         reduce using rule 77 (else_if_block -> ELSE_IF expression START NEWLINE language STOP .)
    ELSE            reduce using rule 77 (else_if_block -> ELSE_IF expression START NEWLINE language STOP .)
    NEWLINE         reduce using rule 77 (else_if_block -> ELSE_IF expression START NEWLINE language STOP .)
    $end            reduce using rule 77 (else_if_block -> ELSE_IF expression START NEWLINE language STOP .)
    STOP            reduce using rule 77 (else_if_block -> ELSE_IF expression START NEWLINE language STOP .)
    RETURN          reduce using rule 77 (else_if_block -> ELSE_IF expression START NEWLINE language STOP .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: reduce/reduce conflict in state 3 resolved using rule (start -> empty)
WARNING: rejected rule (line -> empty) in state 3
WARNING: reduce/reduce conflict in state 13 resolved using rule (expression -> NAME)
WARNING: rejected rule (math -> NAME) in state 13
WARNING: reduce/reduce conflict in state 13 resolved using rule (math -> NAME)
WARNING: rejected rule (str -> NAME) in state 13
WARNING: reduce/reduce conflict in state 13 resolved using rule (expression -> NAME)
WARNING: rejected rule (str -> NAME) in state 13
WARNING: reduce/reduce conflict in state 62 resolved using rule (math -> NAME)
WARNING: rejected rule (str -> NAME) in state 62
WARNING: reduce/reduce conflict in state 67 resolved using rule (expression -> NAME)
WARNING: rejected rule (math -> NAME) in state 67
WARNING: reduce/reduce conflict in state 67 resolved using rule (math -> NAME)
WARNING: rejected rule (str -> NAME) in state 67
WARNING: reduce/reduce conflict in state 67 resolved using rule (expression -> NAME)
WARNING: rejected rule (str -> NAME) in state 67
